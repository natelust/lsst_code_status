<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>pex_policy</title>
<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>
</head>
<body>
<h1 id="toc_0">Comparison of the pex_policy repository</h1>

<div style="background-color:Aquamarine; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Summary of Repositories</h1>
<p>
Comparison run at 11:39AM on June 09, 2015<br>
There are <b>418</b> differences between the two repositories<br><br>
Repository <b>/Users/nate/repos_hsc/pex_policy/</b> <br> Revision <b>f4fe1684ae233ca83fcf1b6f82d3ed403780c349</b><br> Branch <b>master</b><br>Last commit was on <b>2013-11-22 15:31:45 -0500</b><br><br>
Repository <b>/Users/nate/repos_lsst/pex_policy/</b> <br> Revision <b>6cb1d70c639287cc0180106eca140eb1fcd3c7ad</b><br> Branch <b>master</b><br>Last commit was on <b>2015-06-08 16:19:47 -0700</b><br><br>
</p>
</div>

<hr>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Files only in /Users/nate/repos_hsc/pex_policy/</h1>
<h2>tests/testBadPAFWrite.cc</h2>
<pre>
commit f4fe1684ae233ca83fcf1b6f82d3ed403780c349
Merge: e946e4a 3247c88
Author: Paul Price <price@astro.princeton.edu>
Date:   Fri Nov 22 15:31:45 2013 -0500

    Merge remote-tracking branch 'lsst/master'</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Files only in /Users/nate/repos_lsst/pex_policy/</h1>
</div>

<h1 id="toc_1">List of the files in common<a name="homelist"></a></h1>

<p>Files without links do not differ</p>

<ul>
<li><code>tests/dictionary/dictionary_bad_min_policy.paf</code></li>
<li><code>include/lsst/pex/policy/PolicyStringDestination.h</code></li>
<li><code>src/PolicyStringDestination.cc</code></li>
<li><code>tests/dictionary/values_policy_bad_policy_set.paf</code></li>
<li><a href="#src/PolicyString.cc"><code>src/PolicyString.cc</code></a></li>
<li><code>examples/EventTransmitter_policy.xml</code></li>
<li><code>doc/doxygen.conf.in</code></li>
<li><code>tests/dictionary/types_policy_bad_policy.paf</code></li>
<li><code>include/lsst/pex/policy/PolicyWriter.h</code></li>
<li><code>tests/dictionary/dictionary_bad_unknown_type.paf</code></li>
<li><code>tests/dictionary/nested_dictionary_bad_1.paf</code></li>
<li><code>tests/dictionary/dictionary_bad_policyfile.paf</code></li>
<li><code>tests/SConscript</code></li>
<li><code>tests/Policy_3.cc</code></li>
<li><code>tests/urn/simple.paf</code></li>
<li><a href="#src/SupportedFormats.cc"><code>src/SupportedFormats.cc</code></a></li>
<li><code>tests/Policy_4.cc</code></li>
<li><code>tests/dictionary/nested_dictionary_2.paf</code></li>
<li><code>tests/urn/indirect_parent_typo_2.paf</code></li>
<li><code>include/lsst/pex/policy/SupportedFormats.h</code></li>
<li><code>.gitignore</code></li>
<li><code>tests/dictionary/childdef_complex_policy_good_2.paf</code></li>
<li><code>tests/test_validate.sh</code></li>
<li><code>include/lsst/pex/policy.h</code></li>
<li><code>examples/pipeline_policy.paf</code></li>
<li><a href="#tests/Policy_1.py"><code>tests/Policy_1.py</code></a></li>
<li><a href="#tests/testGet.py"><code>tests/testGet.py</code></a></li>
<li><code>tests/urn/indirect_parent.paf</code></li>
<li><code>examples/CacheManager_dict.paf</code></li>
<li><code>include/lsst/pex/policy/PolicyStreamDestination.h</code></li>
<li><code>tests/testDefaults.cc</code></li>
<li><code>tests/dictionary/values_policy_bad_max.paf</code></li>
<li><code>examples/EventTransmitter_dict.xml</code></li>
<li><code>tests/dictionary/values_policy_bad_min.paf</code></li>
<li><a href="#src/Policy.cc"><code>src/Policy.cc</code></a></li>
<li><code>tests/dictionary/types_policy_good.paf</code></li>
<li><code>python/lsst/pex/policy/SConscript</code></li>
<li><a href="#tests/Policy_1.cc"><code>tests/Policy_1.cc</code></a></li>
<li><code>doc/paf.dox</code></li>
<li><a href="#include/lsst/pex/policy/parserexceptions.h"><code>include/lsst/pex/policy/parserexceptions.h</code></a></li>
<li><code>examples/types.paf</code></li>
<li><code>tests/dictionary/nested_policy_good.paf</code></li>
<li><a href="#bin/validate.py"><code>bin/validate.py</code></a></li>
<li><code>examples/transmitter_dict.paf</code></li>
<li><code>tests/dictionary/types_policy_bad_int.paf</code></li>
<li><code>include/lsst/pex/policy/PolicySource.h</code></li>
<li><code>src/paf/PAFParser.cc</code></li>
<li><code>tests/dictionary/childdef_complex_policy_good_1.paf</code></li>
<li><code>etc/validationTests.txt</code></li>
<li><code>examples/receiver_dict.paf</code></li>
<li><code>examples/CacheManager-itemType_dict.paf</code></li>
<li><code>tests/urn/indirect_parent_typo_1.paf</code></li>
<li><code>tests/dictionary/dictionary_bad_multiple_definitions.paf</code></li>
<li><code>src/PolicyParserFactory.cc</code></li>
<li><code>tests/dictionary/nested_dictionary_bad_child.paf</code></li>
<li><code>tests/dictionary/nested_policy_bad.paf</code></li>
<li><code>src/PolicyConfigured.cc</code></li>
<li><code>tests/dictionary/defaults_policy_most.paf</code></li>
<li><a href="#src/PolicyWriter.cc"><code>src/PolicyWriter.cc</code></a></li>
<li><a href="#bin/prototype_dictionary.py"><code>bin/prototype_dictionary.py</code></a></li>
<li><code>tests/PAFtypes.cc</code></li>
<li><code>tests/dictionary/nested_dictionary_good.paf</code></li>
<li><code>tests/dictionary/childdef_simple_dictionary.paf</code></li>
<li><code>tests/dictionary/defaults_dictionary_partial.paf</code></li>
<li><code>tests/urn/indirect_parent_good.paf</code></li>
<li><a href="#include/lsst/pex/policy/Dictionary.h"><code>include/lsst/pex/policy/Dictionary.h</code></a></li>
<li><code>tests/dictionary/childdef_simple_policy_bad.paf</code></li>
<li><code>tests/dictionary/childdef_dictionary_bad_multiple.paf</code></li>
<li><code>tests/dictionary/childdef_complex_dictionary.paf</code></li>
<li><code>tests/dictionary/defaults_policy_more.paf</code></li>
<li><code>examples/pipeline_policy.json</code></li>
<li><code>tests/dictionary/types_policy_bad_bool.paf</code></li>
<li><code>tests/policy_bomb.paf</code></li>
<li><code>tests/testStringDest.py</code></li>
<li><a href="#tests/DefaultPolicyFile_1.cc"><code>tests/DefaultPolicyFile_1.cc</code></a></li>
<li><code>python/lsst/pex/policy/__init__.py</code></li>
<li><code>doc/overview.dox</code></li>
<li><code>include/lsst/pex/policy/paf/PAFWriter.h</code></li>
<li><code>src/PolicySource.cc</code></li>
<li><code>tests/dictionary/simple_dictionary.paf</code></li>
<li><code>etc/dictionary_dict.paf</code></li>
<li><code>tests/PAFBadSyntax_4.paf</code></li>
<li><code>doc/dictionaries.dox</code></li>
<li><code>tests/dictionary/types_policy_bad_file.paf</code></li>
<li><code>include/lsst/pex/policy/paf/PAFParser.h</code></li>
<li><code>python/lsst/pex/__init__.py</code></li>
<li><code>tests/dictionary/defaults_policy_all.paf</code></li>
<li><code>tests/Policy_2.cc</code></li>
<li><code>include/lsst/pex/policy/PolicyConfigured.h</code></li>
<li><code>src/UrnPolicyFile.cc</code></li>
<li><code>tests/dictionary/nested_dictionary_bad_2.paf</code></li>
<li><code>src/exceptions.cc</code></li>
<li><code>tests/dictionary/types_policy_int.paf</code></li>
<li><code>tests/dictionary/dictionary_bad_min_wrong_type.paf</code></li>
<li><a href="#python/lsst/pex/policy/policyLib.i"><code>python/lsst/pex/policy/policyLib.i</code></a></li>
<li><code>tests/dictionary/empty_subdictionary.paf</code></li>
<li><a href="#include/lsst/pex/policy/Policy.h"><code>include/lsst/pex/policy/Policy.h</code></a></li>
<li><code>tests/dictionary/defaults_dictionary_bad_1.paf</code></li>
<li><code>include/lsst/pex/policy/PolicyDestination.h</code></li>
<li><code>tests/dictionary/values_policy_bad_allowedminmax.paf</code></li>
<li><code>tests/PolicyString_1.cc</code></li>
<li><code>tests/dictionary/defaults_dictionary_indirect.paf</code></li>
<li><code>tests/dictionary/conflict_occurs_policy_1.paf</code></li>
<li><a href="#include/lsst/pex/policy/exceptions.h"><code>include/lsst/pex/policy/exceptions.h</code></a></li>
<li><code>tests/dictionary/values_policy_bad_allowed.paf</code></li>
<li><code>tests/dictionary/values_policy_bad_policy_min.paf</code></li>
<li><a href="#src/PolicyFile.cc"><code>src/PolicyFile.cc</code></a></li>
<li><code>tests/testPolicyString.py</code></li>
<li><code>SConstruct</code></li>
<li><code>tests/dictionary/dictionary_bad_max_wrong_type.paf</code></li>
<li><code>ups/pex_policy.cfg</code></li>
<li><code>examples/EventTransmitter_policy.paf</code></li>
<li><code>examples/EventTransmitter_policy.json</code></li>
<li><code>tests/dictionary/conflict_occurs_dictionary.paf</code></li>
<li><code>include/lsst/pex/policy/UrnPolicyFile.h</code></li>
<li><a href="#src/Dictionary.cc"><code>src/Dictionary.cc</code></a></li>
<li><code>ups/pex_policy.build</code></li>
<li><code>doc/PolicyDesign.txt</code></li>
<li><code>src/parserexceptions.cc</code></li>
<li><code>tests/dictionary/childdef_simple_policy_good.paf</code></li>
<li><a href="#tests/testBigBool.py"><code>tests/testBigBool.py</code></a></li>
<li><code>tests/PAFBadSyntax.cc</code></li>
<li><code>tests/dictionary/nested_policy_1.paf</code></li>
<li><code>src/PolicyParser.cc</code></li>
<li><code>tests/PAFBadSyntax_1.paf</code></li>
<li><code>doc/revision_notes.txt</code></li>
<li><code>tests/PAFBadSyntax_2.paf</code></li>
<li><code>tests/dictionary/defaults_dictionary_policy.paf</code></li>
<li><code>tests/dictionary/nested_dictionary_1.paf</code></li>
<li><code>tests/dictionary/broken_dictionary.paf</code></li>
<li><code>tests/dictionary/values_policy_good_1.paf</code></li>
<li><code>tests/dictionary/dictionary_bad_multiple_max.paf</code></li>
<li><a href="#include/lsst/pex/policy/DefaultPolicyFile.h"><code>include/lsst/pex/policy/DefaultPolicyFile.h</code></a></li>
<li><code>tests/dictionary/defaults_dictionary_good.paf</code></li>
<li><code>include/lsst/pex/policy/paf/PAFParserFactory.h</code></li>
<li><code>tests/urn/level_2.paf</code></li>
<li><code>tests/PAFBadSyntax_3.paf</code></li>
<li><code>tests/dictionary/nested_dictionary_3.paf</code></li>
<li><a href="#ups/pex_policy.table"><code>ups/pex_policy.table</code></a></li>
<li><code>tests/urn/level_5.paf</code></li>
<li><code>tests/urn/level_4.paf</code></li>
<li><code>tests/dictionary/dictionary_bad_multiple_min.paf</code></li>
<li><code>tests/dictionary/conflict_occurs_policy_2.paf</code></li>
<li><code>tests/dictionary/dictionary_bad_type_type.paf</code></li>
<li><code>src/PolicyDestination.cc</code></li>
<li><code>doc/SConscript</code></li>
<li><code>tests/dictionary/values_dictionary.paf</code></li>
<li><code>src/PolicyStreamDestination.cc</code></li>
<li><code>tests/dictionary/values_dictionary_bad_min.paf</code></li>
<li><code>tests/dictionary/nested_policy_2.paf</code></li>
<li><code>tests/dictionary/dictionary_bad_keyword.paf</code></li>
<li><a href="#tests/Dictionary_1.py"><code>tests/Dictionary_1.py</code></a></li>
<li><code>tests/dictionary/simple_policy.paf</code></li>
<li><a href="#tests/UrnPolicyFile_1.py"><code>tests/UrnPolicyFile_1.py</code></a></li>
<li><code>tests/urn/local_tests_repos.paf</code></li>
<li><code>tests/dictionary/values_policy_bad_occurs.paf</code></li>
<li><code>tests/urn/level_3.paf</code></li>
<li><code>tests/dictionary/defaults_dictionary_complete.paf</code></li>
<li><a href="#src/DefaultPolicyFile.cc"><code>src/DefaultPolicyFile.cc</code></a></li>
<li><code>tests/urn/level_1.paf</code></li>
<li><code>include/lsst/pex/policy/PolicyParser.h</code></li>
<li><code>examples/EventTransmitter_dict.json</code></li>
<li><code>tests/dictionary/values_policy_bad_policy_max.paf</code></li>
<li><code>tests/dictionary/defaults_policy_partial.paf</code></li>
<li><code>tests/dictionary/simple_policy_error.paf</code></li>
<li><code>lib/SConscript</code></li>
<li><code>python/lsst/__init__.py</code></li>
<li><code>tests/dictionary/types_dictionary.paf</code></li>
<li><code>src/paf/PAFParserFactory.cc</code></li>
<li><code>tests/dictionary/childdef_complex_policy_bad_1.paf</code></li>
<li><code>tests/dictionary/types_policy_appendix.paf</code></li>
<li><code>examples/EventTransmitter_dict.paf</code></li>
<li><code>tests/dictionary/types_policy_bad_double.paf</code></li>
<li><code>include/lsst/pex/policy/PolicyFile.h</code></li>
<li><code>include/lsst/pex/policy/PolicyString.h</code></li>
<li><code>tests/dictionary/nested_policy_3.paf</code></li>
<li><code>tests/dictionary/types_policy_bad_string.paf</code></li>
<li><code>include/lsst/pex/policy/PolicyParserFactory.h</code></li>
<li><code>src/paf/PAFWriter.cc</code></li>
</ul>

<h1 id="toc_2"><a name="src/PolicyString.cc"/></a>src/PolicyString.cc</h1>

<h3 id="toc_3">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file PolicyString.cc
                 * @author Ray Plante
                 */
                #include <sstream>
                // #include <iosfwd>
                
                #include <boost/scoped_ptr.hpp>
                
                #include "lsst/pex/policy/PolicyString.h"
                #include "lsst/pex/policy/PolicyFile.h"
                #include "lsst/pex/policy/PolicyParser.h"
                #include "lsst/pex/policy/exceptions.h"
                #include "lsst/pex/policy/parserexceptions.h"
                #include "lsst/pex/policy/paf/PAFParserFactory.h"
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                //@cond
                
                using std::string;
                using std::ifstream;
                using boost::regex;
                using boost::regex_match;
                using boost::regex_search;
                using boost::scoped_ptr;
                using lsst::pex::policy::paf::PAFParserFactory;
                
                namespace pexExcept = lsst::pex::exceptions;
                
                const regex PolicyString::SPACE_RE("^\\s*$");
                const regex PolicyString::COMMENT("^\\s*#");
                const regex 
                        PolicyString::CONTENTID("^\\s*#\\s*<\\?cfg\\s+\\w+(\\s+\\w+)*\\s*\\?>",
                                                regex::icase);
                
                /*
                 * create a "null" Policy formed from an empty string.  
                 * @param fmts           a SupportedFormats object to use.  An instance 
                 *                          encapsulates a configured set of known formats.
                 */
                PolicyString::PolicyString(const SupportedFormats::Ptr& fmts) 
                    : PolicySource(fmts), Persistable(), _data(), _pfact() 
                { }
                
                /*
                 * create a "null" Policy formed from an empty string.  
                 * @param fmts           a SupportedFormats object to use.  An instance 
                 *                          encapsulates a configured set of known formats.
                 */
                PolicyString::PolicyString(const std::string& data,
                                           const SupportedFormats::Ptr& fmts) 
                    : PolicySource(fmts), Persistable(), _data(data), _pfact() 
                { }
                
                #define PolStr_ERROR_MSG(use, msg, input)   \
                    std::ostringstream use;                 \
                    use << msg << ": '";                    \
                    if (input.length() > 40)                \
                        use << input;                       \
                    else                                    \
                        use << input.substr(0,40) << "..."; \
                    use << "'";                             
                
                /*
                 * return the name of the format that the data is stored in.  This may 
                 * cause the first few records of the source to be read.
                 * @exception IOError   if an error occurs while reading the first few
                 *                      characters of the source stream.
                 */
                const string& PolicyString::getFormatName() {
                
                    // try reading the initial characters
                    std::istringstream is(_data);
                    if (is.fail()) {
                        PolStr_ERROR_MSG(msg, "failure opening input Policy string", _data);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
101  <a href="#d4824b71">d4824b71</a> -         throw LSST_EXCEPT(pexExcept::IoErrorException, msg.str());</div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
101  <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::IoError, msg.str());</div>
                    }
                
                    // skip over comments
                    string line;
                    getline(is, line);
                    while (is.good() && 
                           (regex_match(line, SPACE_RE) || 
                            (regex_search(line, COMMENT) && !regex_search(line, COMMENT))))
                    { }
                            
                    if (is.fail()) {
                        PolStr_ERROR_MSG(msg, "failure reading input Policy string", _data);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#d4824b71">d4824b71</a> -         throw LSST_EXCEPT(pexExcept::IoErrorException, msg.str());</div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::IoError, msg.str());</div>
                    }
                    if (is.eof() && 
                        (regex_match(line, SPACE_RE) || 
                         (regex_search(line, COMMENT) && !regex_search(line, COMMENT))))
                    {
                        // empty file; let's just assume PAF (but don't cache the name).
                        return PAFParserFactory::FORMAT_NAME;
                    }
                    return cacheName(_formats->recognizeType(line));
                }
                
                /*
                 * load the data from this Policy source into a Policy object
                 * @param policy    the policy object to load the data into
                 * @exception ParserError  if an error occurs while parsing the data
                 * @exception IOError   if an I/O error occurs while reading from the 
                 *                       source stream.
                 */
                void PolicyString::load(Policy& policy) { 
                
                    PolicyParserFactory::Ptr pfactory = _pfact;
                    if (! pfactory.get()) {
                        const string& fmtname = getFormatName();
                        if (fmtname.empty()) {
                            PolStr_ERROR_MSG(ms,"Unknown Policy format for string data",_data);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
140  <a href="#d4824b71">d4824b71</a> -             throw LSST_EXCEPT(pexExcept::IoErrorException, ms.str());</div>
              ?                                                 ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
140  <a href="#826f6e19">826f6e19</a> +             throw LSST_EXCEPT(pexExcept::IoError, ms.str());</div>
                        }
                        pfactory = _formats->getFactory(fmtname);
                    }
                
                    scoped_ptr<PolicyParser> parser(pfactory->createParser(policy));
                
                    std::istringstream is(_data);
                    if (is.fail()) {
                        PolStr_ERROR_MSG(msg, "failure opening Policy string", _data);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
150  <a href="#d4824b71">d4824b71</a> -         throw LSST_EXCEPT(pexExcept::IoErrorException, msg.str());</div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
150  <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::IoError, msg.str());</div>
                    }
                    parser->parse(is);
                }
                
                //@endcond
                
                }}}   // end lsst::pex::policy
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="d4824b71"/></a>d4824b71</h3>

<pre>
commit d4824b71f66a7d366ee2740a5b4b419537c11e98
Author: rplante <rplante@git.lsstcorp.org>
Date:   Sat Apr 3 00:30:17 2010 +0000

    add classes PolicyString, PolicyDestination, and its derived classes
    (destination classes not actually needed but I'm leaving them in.)
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_4"><a name="src/SupportedFormats.cc"/></a>src/SupportedFormats.cc</h1>

<h3 id="toc_5">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file PolicyParserFactory.cc
                 * @ingroup pex
                 * @author Ray Plante
                 */
                
                #include "lsst/pex/policy/SupportedFormats.h"
                #include "lsst/pex/policy/paf/PAFParserFactory.h"
                #include "lsst/pex/exceptions.h"
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                using lsst::pex::policy::paf::PAFParserFactory;
                using lsst::pex::policy::PolicyParserFactory;
                
                void SupportedFormats::initDefaultFormats(SupportedFormats& sf) { 
                    sf.registerFormat(PolicyParserFactory::Ptr(new PAFParserFactory()));
                }
                
                /**
                 * register a factory method for policy format parsers
                 */
                void SupportedFormats::registerFormat(const PolicyParserFactory::Ptr& factory) 
                {
                    if (factory.get() == 0) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
50   <a href="#58eed0c0">58eed0c0</a> -         throw LSST_EXCEPT(pexExcept::RuntimeErrorException, </div>
              ?                                                  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
50   <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::RuntimeError, </div>
                                          std::string("attempt to register null ") + 
                                                               "PolicyParserFactory pointer");
                
                    _formats[factory->getFormatName()] = factory;
                }
                
                /**
                 * analyze the given string assuming contains the leading characters 
                 * from the data stream and determine if it is recognized as being in 
                 * the format supported by this parser.  If it is, return the name of 
                 * the this format; if not return an empty string.  
                 */
                const std::string& 
                SupportedFormats::recognizeType(const std::string& leaders) const {
                
                    Lookup::const_iterator f;
                    for(f=_formats.begin(); f != _formats.end(); ++f) {
                        if (f->second->isRecognized(leaders))
                            return f->second->getFormatName();
                    }
                
                    return PolicyParserFactory::UNRECOGNIZED;
                }
                
                /**
                 * get a pointer to a factory with a given name.  A null pointer is 
                 * returned if the name is not recognized.
                 */
                PolicyParserFactory::Ptr 
                SupportedFormats::getFactory(const std::string& name) const {
                
                    SupportedFormats *me = const_cast<SupportedFormats*>(this);
                
                    Lookup::iterator found = me->_formats.find(name);
                    return ((found != me->_formats.end()) ? found->second 
                                                          : PolicyParserFactory::Ptr());
                }
                
                }}}  // end namespace lsst::pex::policy
                
                
                
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="58eed0c0"/></a>58eed0c0</h3>

<pre>
commit 58eed0c07ea5d7f9c9c08f4478b28c756e9913cd
Author: rplante <rplante@git.lsstcorp.org>
Date:   Tue Dec 23 19:34:44 2008 +0000

    Merged revisions 6859-6863 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/458
    
    ........
      r6859 | rplante | 2008-12-23 09:56:24 -0600 (Tue, 23 Dec 2008) | 1 line
    
      branch to update to us new exceptions
    ........
      r6860 | rplante | 2008-12-23 12:15:28 -0600 (Tue, 23 Dec 2008) | 1 line
    
      initial exception update attempt (untested), #458
    ........
      r6861 | rplante | 2008-12-23 12:30:37 -0600 (Tue, 23 Dec 2008) | 1 line
    
      updated table file to add daf_base
    ........
      r6862 | rplante | 2008-12-23 13:20:00 -0600 (Tue, 23 Dec 2008) | 1 line
    
      debugged exception upgrade
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_6"><a name="tests/Policy_1.py"/></a>tests/Policy_1.py</h1>

<h3 id="toc_7">Diff:</h3>

<pre>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1    <a href="#0050b976">0050b976</a> + #!/usr/bin/env python</div>
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                #import pdb                          # we may want to say pdb.set_trace()
                import unittest
                
                import lsst.utils.tests as tests
                from lsst.pex.policy import Policy, NameNotFound
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
28   <a href="#58eed0c0">58eed0c0</a> - from lsst.pex.exceptions import LsstCppException</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
29   <a href="#0050b976">0050b976</a> + import lsst.pex.exceptions</div>
                
                #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                
                class PolicyTestCase(unittest.TestCase):
                    def testPolicySetget(self):
                        p = Policy()
                        self.assert_(not p.exists("foo"), "empty existence test failed")
                        self.assertEqual(p.valueCount("foo.bar"), 0,
                                         "empty valueCount test failed")
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
39   <a href="#58eed0c0">58eed0c0</a> -         self.assertRaises(LsstCppException, p.getTypeInfo, "foo")</div>
              ?                           ^   ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
40   <a href="#0050b976">0050b976</a> +         self.assertRaises(lsst.pex.exceptions.Exception, p.getTypeInfo, "foo")</div>
              ?                           ^   ^ +++++++ ++++++
                
                        p.set("doall", "true")
                
                        # non-existence tests on a non-empty policy
                        self.failUnless(not p.exists("foo"),
                                        "non-empty non-existence test failed")
                        self.assertEqual(p.valueCount("foo.bar"), 0,
                                         "empty valueCount test failed")
                        self.failUnless(not p.isInt("foo"),
                                        "non-empty non-existence type test failed")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
50   <a href="#58eed0c0">58eed0c0</a> -         self.assertRaises(LsstCppException, p.getTypeInfo, "foo")</div>
              ?                           ^   ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
51   <a href="#0050b976">0050b976</a> +         self.assertRaises(lsst.pex.exceptions.Exception, p.getTypeInfo, "foo")</div>
              ?                           ^   ^ +++++++ ++++++
                
                        # existence tests
                        self.assert_(p.exists("doall"), "non-empty existence test failed")
                        self.assertEquals(p.valueCount("doall"), 1,
                                          "single valueCount test failed")
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
57   <a href="#58eed0c0">58eed0c0</a> -         self.assertRaises(LsstCppException, p.getInt, "doall")</div>
              ?                           ^   ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
58   <a href="#0050b976">0050b976</a> +         self.assertRaises(lsst.pex.exceptions.Exception, p.getInt, "doall")</div>
              ?                           ^   ^ +++++++ ++++++
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
58   <a href="#58eed0c0">58eed0c0</a> -         self.assertRaises(LsstCppException, p.getDoubleArray, "doall")</div>
              ?                           ^   ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
59   <a href="#0050b976">0050b976</a> +         self.assertRaises(lsst.pex.exceptions.Exception, p.getDoubleArray, "doall")</div>
              ?                           ^   ^ +++++++ ++++++
                
                        self.assertEquals(p.get("doall"), "true",
                                          "top-level getString failed")
                        p.set("doall", "duh")
                        self.assertEquals(p.get("doall"), "duh",
                                          "top-level getString failed")
                        
                        # test array access
                        ary = p.getArray("doall")
                        self.assertEquals(len(ary), 1,
                                          "scalar property has more than one value")
                
                
                        self.assertEquals(ary[0], "duh", "scalar access via array failed")
                
                        p.add("doall", "never")
                        self.assertEquals(p.valueCount("doall"), 2,
                                          "2-elem. valueCount test failed")
                        self.assertEquals(p.get("doall"), "never", "top-level add failed")
                        ary = p.getArray("doall")
                        self.assertEquals(len(ary), 2,
                                          "scalar property has wrong number of values")
                        self.assertEquals(ary[0], "duh",
                                          "scalar access via (2-el) array failed")
                        self.assertEquals(ary[-1], "never",
                                          "scalar access via (2-el) array failed")
                
                        # test hierarchical access
                
                        # list names
                
                        # test types
                        p.set("pint", 5)
                        self.assertEquals(p.getInt("pint"), 5, "support for type int failed")
                        self.assertEquals(type(p.get("pint")), type(5),
                                          "auto-typing for int failed")
                        p.set("pdbl", 5.1)
                        self.assertAlmostEquals(p.getDouble("pdbl"), 5.1, 7, 
                                                "support for type double failed")
                        self.assertEquals(type(p.get("pdbl")), type(5.1),
                                          "auto-typing for double failed")
                        p.set("pbool", True)
                        self.assert_(p.getBool("pbool"), "support for type bool failed")
                        self.assertEquals(type(p.get("pbool")), type(True),
                                          "auto-typing for bool failed")
                        p.add("pbool", False)
                
                        # test shallow & deep copies
                
                        # test raise NameNotFound if not present
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
110  <a href="#0050b976">0050b976</a> +         self.assertRaises(NameNotFound, p.get, "nonexistent")</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#0050b976">0050b976</a> +         self.assertRaises(NameNotFound, p.getArray, "nonexistent")</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
112  <a href="#0050b976">0050b976</a> +         self.assertRaises(NameNotFound, p.getDouble, "nonexistent")</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
109  <a href="#c9e716bb">c9e716bb</a> -         try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
110  <a href="#c9e716bb">c9e716bb</a> -             p.get("nonexistent")</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#c9e716bb">c9e716bb</a> -             self.fail() # should never reach here</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
112  <a href="#c9e716bb">c9e716bb</a> -         except LsstCppException, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
113  <a href="#c9e716bb">c9e716bb</a> -             self.assert_(isinstance(e.args[0], NameNotFound))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#c9e716bb">c9e716bb</a> -         try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#c9e716bb">c9e716bb</a> -             p.getArray("nonexistent")</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
116  <a href="#c9e716bb">c9e716bb</a> -             self.fail()</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
117  <a href="#c9e716bb">c9e716bb</a> -         except LsstCppException, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
118  <a href="#c9e716bb">c9e716bb</a> -             self.assert_(isinstance(e.args[0], NameNotFound))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
119  <a href="#c9e716bb">c9e716bb</a> -         try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
120  <a href="#c9e716bb">c9e716bb</a> -             p.getDouble("nonexistent")</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
121  <a href="#c9e716bb">c9e716bb</a> -             self.fail()</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
122  <a href="#c9e716bb">c9e716bb</a> -         except LsstCppException, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
123  <a href="#c9e716bb">c9e716bb</a> -             self.assert_(isinstance(e.args[0], NameNotFound))</div>
                
                    def testSimpleLoad(self):
                #        n = mwid.Citizen_census(0)
                        p = Policy.createPolicy("examples/EventTransmitter_policy.paf")
                        self.assertEquals(p.get("transmitter.serializationFormat"), "deluxe")
                        p = None
                #        self.assertEquals(mwid.Citizen_census(0), n, "Policy apparently leaked")
                
                    def testEmptyPolicy(self):
                        p = Policy()
                
                    def testPolicyCopy(self):
                        p = Policy.createPolicy("examples/EventTransmitter_policy.paf")
                        pp = Policy(p, True)
                        self.assertEquals(p.get("transmitter.serializationFormat"), "deluxe")
                        self.assertEquals(pp.getString("transmitter.serializationFormat"), "deluxe")
                        p = None
                        self.assertEquals(pp.getString("transmitter.serializationFormat"), "deluxe")
                
                    def testSetNothing(self):
                        p = Policy()
                        try:
                            p.set("foo", None)
                            self.assert_(False, "Setting value to None succeeded.")
                        except RuntimeError:
                            self.assertFalse(p.exists("foo"))
                
                #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                
                def suite():
                    """Returns a suite containing all the test cases in this module."""
                    tests.init()
                
                    suites = []
                    suites += unittest.makeSuite(PolicyTestCase)
                    suites += unittest.makeSuite(tests.MemoryTestCase)
                
                    return unittest.TestSuite(suites)
                
                if __name__ == "__main__":
                    tests.run(suite())
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="58eed0c0"/></a>58eed0c0</h3>

<pre>
commit 58eed0c07ea5d7f9c9c08f4478b28c756e9913cd
Author: rplante <rplante@git.lsstcorp.org>
Date:   Tue Dec 23 19:34:44 2008 +0000

    Merged revisions 6859-6863 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/458
    
    ........
      r6859 | rplante | 2008-12-23 09:56:24 -0600 (Tue, 23 Dec 2008) | 1 line
    
      branch to update to us new exceptions
    ........
      r6860 | rplante | 2008-12-23 12:15:28 -0600 (Tue, 23 Dec 2008) | 1 line
    
      initial exception update attempt (untested), #458
    ........
      r6861 | rplante | 2008-12-23 12:30:37 -0600 (Tue, 23 Dec 2008) | 1 line
    
      updated table file to add daf_base
    ........
      r6862 | rplante | 2008-12-23 13:20:00 -0600 (Tue, 23 Dec 2008) | 1 line
    
      debugged exception upgrade
    ........
</pre>
<h3><a name="c9e716bb"/></a>c9e716bb</h3>

<pre>
commit c9e716bb864b956141ec3c4f2f8d4c4d7e386078
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Tue Dec 8 22:29:55 2009 +0000

    Raise exception on Policy.get(nonexistentParam)
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="0050b976"/></a>0050b976</h3>

<pre>
commit 0050b9767b605916c0d6fff20a22dd9476cf0c25
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 15:08:59 2014 -0400

    Adapt to changes in Python Swig wrappers (DM-827)
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_8"><a name="tests/testGet.py"/></a>tests/testGet.py</h1>

<h3 id="toc_9">Diff:</h3>

<pre>
                #!/usr/bin/env python
                
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                """
                Comprehensive tests reading and retrieving data of all types
                """
                import pdb                              # we may want to say pdb.set_trace()
                import os
                import sys
                import unittest
                import time
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
34   <a href="#a03a626c">a03a626c</a> + import lsst.utils</div>
                from lsst.pex.policy import Policy
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
36   <a href="#c97b1321">c97b1321</a> - proddir = os.environ["PEX_POLICY_DIR"]</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
37   <a href="#a03a626c">a03a626c</a> + proddir = lsst.utils.getPackageDir('pex_policy')</div>
                
                class GetTestCase(unittest.TestCase):
                
                    def setUp(self):
                        self.policyfile = os.path.join(proddir,"examples","types.paf")
                        self.policy = Policy.createPolicy(self.policyfile, False)
                
                    def tearDown(self):
                        pass
                
                    def testGet(self):
                        p = self.policy
                        self.assertEquals(p.get("int"), 0)
                        self.assertEquals(p.get("true"), True)
                        self.assertEquals(p.get("false"), False)
                        self.assertAlmostEquals(p.get("dbl"), -0.05, 8)
                        self.assertEquals(p.get("str"), "birthday")
                        self.assert_(p.isFile("file"),
                                     "Unexpected: 'file' is not a PolicyFile")
                        self.assert_(p.get("file") is not None, "file value returned as None")
                        self.assertEquals(p.get("file").getPath(), "CacheManager_dict.paf")
                        self.assert_(p.isPolicy("pol"), "Unexpected: 'pol' is not a Policy")
                        sp = p.get("pol")
                        self.assertEquals(sp.get("int"), 2)
                
                    def testGetIntArray(self):
                        self.assert_(self.policy.isInt("int"))
                        v = self.policy.getArray("int")
                        self.assert_(isinstance(v, list), "array value not returned as a list")
                        
                        truth = [-11, 0, 3, 42, -11, 0 , 3, 42, 0, 0]
                        self.assertEquals(len(v), len(truth),"wrong number of values in array")
                        for i in xrange(len(truth)):
                            self.assertEquals(v[i], truth[i],
                                              "wrong array element at index %d: %d != %d" %
                                              (i, v[i], truth[i]))
                
                    def testGetBoolArray(self):
                        self.assert_(self.policy.isBool("true"))
                        v = self.policy.getArray("true")
                        self.assert_(isinstance(v, list), "array value not returned as a list")
                        
                        truth = [ True ]
                        self.assertEquals(len(v), len(truth),"wrong number of values in array")
                        for i in xrange(len(truth)):
                            self.assertEquals(v[i], truth[i],
                                              "wrong array element at index %i: %s != %s" %
                                              (i, v[i], truth[i]))
                
                        self.assert_(self.policy.isBool("false"))
                        v = self.policy.getArray("false")
                        self.assert_(isinstance(v, list), "array value not returned as a list")
                        
                        truth = [ False ]
                        self.assertEquals(len(v), len(truth),"wrong number of values in array")
                        for i in xrange(len(truth)):
                            self.assertEquals(v[i], truth[i],
                                              "wrong array element at index %i: %s != %s" %
                                              (i, v[i], truth[i]))
                
                    def testGetDoublArray(self):
                        self.assert_(self.policy.isDouble("dbl"))
                        v = self.policy.getArray("dbl")
                        self.assert_(isinstance(v, list), "array value not returned as a list")
                        
                        truth = [-1.0, -65.78, -14.0, -0.12, -0.12, 1.0, 65.78, 14.0, 0.12, 
                                 0.12, 1.0, 65.78, 14.0, 0.12, 0.12, -1.0e10, -65780000.0, 
                                 -0.014, -0.12e14, 0.12e-11, 14.0, 0.12, 0.12, 1.0, 65.78, 
                                 14.0, 50000, -0.05 ]
                        self.assertEquals(len(v), len(truth),
                                          "wrong number of values in array: %i != %i" %
                                          (len(v), len(truth)))
                        for i in xrange(len(truth)):
                            self.assertAlmostEquals(v[i], truth[i], 8,
                                              "wrong array element at index %d: %g != %g" %
                                              (i, v[i], truth[i]))
                
                    def testGetStringArray(self):
                        #pdb.set_trace()
                        self.assert_(self.policy.isString("str"))
                        v = self.policy.getArray("str")
                        self.assert_(isinstance(v, list), "array value not returned as a list")
                        
                        truth = ["word", "two words", "quoted ' words", 'quoted " words',
                                 "a very long, multi-line description", "happy", "birthday" ]
                        self.assertEquals(len(v), len(truth),"wrong number of values in array")
                        for i in xrange(len(truth)):
                            self.assertEquals(v[i], truth[i],
                                              "wrong array element at index %d: %s != %s" %
                                              (i, v[i], truth[i]))
                
                    def testGetEmptyString(self):
                        p = self.policy
                        self.assertEquals(p.get("empty"), '')
                        s = p.getArray("empty")
                        self.assertEquals(len(s), 5)
                        self.assertEquals(s[0], ' description ')
                        self.assertEquals(s[1], '  ')
                        self.assertEquals(s[2], '  ')
                        self.assertEquals(s[3], ' ')
                        self.assertEquals(s[4], '')
                        
                    def testGetFileArray(self):
                        self.assert_(self.policy.isFile("file"))
                        v = self.policy.getArray("file")
                        self.assert_(v is not None, "file array returned as None")
                
                        # this is be fixed in another ticket
                        self.assert_(isinstance(v, list), "array value not returned as a list")
                        
                        truth = ["EventTransmitter_policy.paf", "CacheManager_dict.paf"]
                        self.assertEquals(len(v), len(truth),"wrong number of values in array")
                        for i in xrange(len(truth)):
                            self.assertEquals(v[i].getPath(), truth[i],
                                          "wrong array element at index %d: %s != %s" %
                                          (i, v[i], truth[i]))
                
                    def testGetPolicyArray(self):
                        self.assert_(self.policy.isPolicy("pol"))
                        v = self.policy.getArray("pol")
                        # this is be fixed in another ticket
                        self.assert_(isinstance(v, list), "array value not returned as a list")
                        
                        self.assertEquals(len(v), 2,"wrong number of values in array")
                        self.assertEquals(v[0].get("int"), 1)
                        self.assertEquals(v[1].get("int"), 2)
                        self.assertAlmostEquals(v[0].get("dbl"), 0.0003, 8)
                        self.assertAlmostEquals(v[1].get("dbl"), -5.2, 8)
                    
                
                
                __all__ = "GetTestCase".split()        
                
                if __name__ == "__main__":
                    unittest.main()
                
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="c97b1321"/></a>c97b1321</h3>

<pre>
commit c97b1321436415cc39500b14aad8805ed55ae4e3
Author: rplante <rplante@git.lsstcorp.org>
Date:   Tue Feb 9 16:55:19 2010 +0000

    fix #1159, added test
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="a03a626c"/></a>a03a626c</h3>

<pre>
commit a03a626ca159348edad2d2d5b0809dfd7d8d1a36
Author: Joshua Hoblitt <josh@hoblitt.com>
Date:   Fri May 22 15:11:15 2015 -0700

    replace eups.productDir() calls with lsst.utils.getPackageDir()
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_10"><a name="src/Policy.cc"/></a>src/Policy.cc</h1>

<h3 id="toc_11">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * \file Policy.cc
                 */
                #include "lsst/pex/policy/Policy.h"
                #include "lsst/pex/policy/PolicyFile.h"
                #include "lsst/pex/policy/UrnPolicyFile.h"
                #include "lsst/pex/policy/PolicySource.h"
                #include "lsst/pex/policy/Dictionary.h"
                #include "lsst/pex/policy/parserexceptions.h"
                // #include "lsst/pex/logging/Trace.h"
                
                #include <boost/make_shared.hpp>
                #include <boost/scoped_ptr.hpp>
                #include <boost/filesystem/path.hpp>
                
                #include <stdexcept>
                #include <string>
                #include <cctype>
                #include <algorithm>
                #include <sstream>
                
                using namespace std;
                namespace fs = boost::filesystem;
                namespace pexExcept = lsst::pex::exceptions;
                namespace dafBase = lsst::daf::base;
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                //@cond
                
                using dafBase::PropertySet;
                using dafBase::Persistable;
                
                const char * const Policy::typeName[] = {
                    "undefined",
                    "bool",
                    "int",
                    "double",
                    "string",
                    "Policy",
                    "PolicyFile"
                };
                
                /*
                 * Create an empty policy
                 */
                Policy::Policy() 
                    : Citizen(typeid(this)), Persistable(), _data(new PropertySet()) 
                { }
                
                /*
                 * Create policy
                 */
                Policy::Policy(const PolicySource& source) 
                    : Citizen(typeid(this)), Persistable(), _data(new PropertySet()) 
                { 
                    source.load(*this);
                }
                
                /*
                 * Create a Policy from a named file or URN.
                 */
                Policy::Policy(const string& pathOrUrn) 
                    : Citizen(typeid(this)), Persistable(), _data(new PropertySet()) 
                {
                    createPolicyFile(pathOrUrn, true)->load(*this);
                }
                
                /*
                 * Create a Policy from a named file or URN.
                 */
                Policy::Policy(const char *pathOrUrn)
                    : Citizen(typeid(this)), Persistable(), _data(new PropertySet()) 
                {
                    createPolicyFile(pathOrUrn, true)->load(*this);
                }
                
                /**
                 * Create a PolicyFile or UrnPolicyFile from `pathOrUrn`.
                 * @param pathOrUrn if this looks like a Policy URN, create a UrnPolicyFile;
                 *                  otherwise, create a plain PolicyFile.
                 * @param strict if false, "@" will be accepted as a substitute for
                 *               "urn:eupspkg:"; if true, urn:eupspkg must be present in a URN.
                 */
                Policy::FilePtr Policy::createPolicyFile(const string& pathOrUrn, bool strict) {
                    if (UrnPolicyFile::looksLikeUrn(pathOrUrn, strict))
                    // return boost::make_shared<PolicyFile>(new UrnPolicyFile(pathOrUrn));
                    return Policy::FilePtr(new UrnPolicyFile(pathOrUrn));
                    else
                    // return boost::make_shared<PolicyFile>(new PolicyFile(pathOrUrn));
                    return Policy::FilePtr(new PolicyFile(pathOrUrn));
                }
                
                /* Extract defaults from dict into target.  Note any errors in ve. */
                void extractDefaults(Policy& target, const Dictionary& dict, ValidationError& ve) {
                    list<string> names;
                    dict.definedNames(names);
                
                    for(list<string>::iterator it = names.begin(); it != names.end(); ++it) {
                        const string& name = *it;
                        std::auto_ptr<Definition> def(dict.makeDef(name));
                        def->setDefaultIn(target, &ve);
                        // recurse into sub-dictionaries
                        if (def->getType() == Policy::POLICY && dict.hasSubDictionary(name)) {
                            Policy::Ptr subp = boost::make_shared<Policy>();
                            extractDefaults(*subp, *dict.getSubDictionary(name), ve);
                            if (subp->nameCount() > 0)
                                target.add(name, subp);
                        }
                    }
                }
                
                /**
                 * Create a default Policy from a Dictionary.  If the Dictionary references
                 * files containing dictionaries for sub-Policies, an attempt is made to
                 * open them and extract the default data, and if that attempt fails, an
                 * exception is thrown.
                 *
                 * @param validate    if true, a shallow copy of the Dictionary will be
                 *                    held onto by this Policy and used to validate future
                 *                    updates.
                 * @param dict        the Dictionary to load defaults from
                 * @param repository  the directory to look for dictionary files referenced
                 *                    in \c dict.  The default is the current directory.
                 */
                Policy::Policy(bool validate, const Dictionary& dict, 
                               const fs::path& repository)
                    : Citizen(typeid(this)), Persistable(), _data(new PropertySet()) 
                { 
                    DictPtr loadedDict; // the dictionary that has all policy files loaded
                    if (validate) { // keep loadedDict around for future validation
                        setDictionary(dict);
                        loadedDict = _dictionary;
                    }
                    else { // discard loadedDict when we finish constructor
                        loadedDict.reset(new Dictionary(dict));
                    }
                    loadedDict->loadPolicyFiles(repository, true);
                
                    ValidationError ve(LSST_EXCEPT_HERE);
                    extractDefaults(*this, *loadedDict, ve);
                    if (ve.getParamCount() > 0) throw ve;
                }
                
                /*
                 * copy a Policy.  Sub-policy objects will not be shared.  
                 */
                Policy::Policy(const Policy& pol) 
                    : Citizen(typeid(this)), Persistable(), _data() 
                {
                    _data = pol._data->deepCopy();
                }
                
                /*
                 * copy a Policy.  Sub-policy objects will be shared unless deep is true
                 */
                Policy::Policy(Policy& pol, bool deep) 
                    : Citizen(typeid(this)), Persistable(), _data() 
                {
                    if (deep)
                        _data = pol._data->deepCopy();
                    else
                        _data = pol._data;
                }
                
                Policy* Policy::_createPolicy(PolicySource& source, bool doIncludes, 
                                              const fs::path& repository, bool validate) 
                {
                    auto_ptr<Policy> pol(new Policy());
                    source.load(*pol);
                
                    if (pol->isDictionary()) {
                        Dictionary d(*pol);
                        pol.reset(new Policy(validate, d, repository));
                    }
                
                    if (doIncludes) pol->loadPolicyFiles(repository, true);
                
                    return pol.release();
                }
                
                Policy* Policy::_createPolicy(const string& input, bool doIncludes, 
                                              const fs::path& repository, bool validate) 
                {
                    fs::path repos = repository;
                    if (repos.empty()) {
                        fs::path filepath(input);
                        if (filepath.has_parent_path()) repos = filepath.parent_path();
                    }
                    PolicyFile file(input);
                    return _createPolicy(file, doIncludes, repos, validate);
                }
                
                Policy* Policy::createPolicyFromUrn(const std::string& urn, bool validate)
                {
                    // Note: Don't request doIncludes because UrnPolicyFile will load the whole
                    // thing anyway.
                    UrnPolicyFile upf(urn, true, true);
                    return _createPolicy(upf, true, fs::path(), false);
                }
                
                /*
                 * Create an empty policy
                 */
                Policy::~Policy() { }
                
                /**
                 * Can this policy validate itself -- that is, does it have a dictionary
                 * that it can use to validate itself?  If true, then set() and add()
                 * operations will be checked against it.
                 */
                bool Policy::canValidate() const {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
237  <a href="#a938e0ae">a938e0ae</a> -     return _dictionary;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
237  <a href="#c3a8a0d3">c3a8a0d3</a> +     return static_cast<bool>(_dictionary);</div>
                }
                
                /**
                 * The dictionary (if any) that this policy uses to validate itself,
                 * including checking set() and add() operations for validity.
                 */
                const Policy::ConstDictPtr Policy::getDictionary() const {
                    return _dictionary;
                }
                
                /**
                 * Update this policy's dictionary that it uses to validate itself.  Note
                 * that this will *not* trigger validation -- you will need to call \code
                 * validate() \endcode afterwards.
                 */
                void Policy::setDictionary(const Dictionary& dict) {
                    _dictionary = boost::make_shared<Dictionary>(dict);
                }
                
                /**
                 * Validate this policy, using its stored dictionary.  If \code
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
259  <a href="#a938e0ae">a938e0ae</a> -  * canValidate() \endcode is false, this will throw a LogicErrorException.</div>
              ?                                                                 ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
259  <a href="#826f6e19">826f6e19</a> +  * canValidate() \endcode is false, this will throw a LogicError.</div>
                 *
                 * If validation errors are found and \code err \endcode is null, a
                 * ValidationError will be thrown.
                 *
                 * @param errs if non-null, any validation errors will be stored here
                 * instead of being thrown.
                 */
                void Policy::validate(ValidationError *errs) const {
                    if (!_dictionary) throw LSST_EXCEPT(DictionaryError, "No dictionary set.");
                    else _dictionary->validate(*this, errs);
                }
                
                /** 
                 * Given the human-readable name of a type ("bool", "int", "policy", etc),
                 * what is its ValueType (BOOL, STRING, etc.)?  Throws BadNameError if
                 * unknown.
                 */
                Policy::ValueType Policy::getTypeByName(const string& name) {
                    static map<string, Policy::ValueType> nameTypeMap;
                
                    if (nameTypeMap.size() == 0) {
                        map<string, Policy::ValueType> tmp;
                        int n = sizeof(Policy::typeName) / sizeof(char *);
                        for (int i = 0; i < n; ++i) {
                            // remember both capitalized and lowercase versions (eg Policy)
                            tmp[Policy::typeName[i]] = (Policy::ValueType) i;
                            string lowered(Policy::typeName[i]);
                            transform(lowered.begin(), lowered.end(), lowered.begin(), ::tolower);
                            tmp[lowered] = (Policy::ValueType) i;
                        }
                        // a few extras
                        tmp["file"] = Policy::FILE;
                        tmp["boolean"] = Policy::BOOL;
                        tmp["integer"] = Policy::INT;
                        tmp["undef"] = Policy::UNDEF;
                        // assign after initializationto avoid concurrency problems
                        nameTypeMap = tmp;
                
                        if (tmp.count(name) == 1) return tmp[name];
                    }
                    else
                        if (nameTypeMap.count(name) == 1) return nameTypeMap[name];
                    
                    throw LSST_EXCEPT(BadNameError, name);
                }
                
                /*
                 * load the names of parameters into a given list.  
                 * 
                 * @param prepend       the names string to prepend to any names found.
                 * @param names         the list object to be loaded
                 * @param topLevelOnly  if true, only parameter names at the top of the 
                 *                         hierarchy will be returned; no hierarchical 
                 *                         names will be included.
                 * @param append        if false, the contents of the given list will 
                 *                         be erased before loading the names.  
                 * @param want          a bit field indicating which is desired (1=Policies,
                 *                         2=PolicyFiles, 4=parameters, 7=all).
                 * @return int  the number of names added
                 */
                int Policy::_names(vector<string>& names, 
                                   bool topLevelOnly, bool append, int want) const
                {
                    bool shouldCheck = true;
                    vector<string> src;
                    int have = 0, count = 0;
                    if (want == 1) {
                        src = _data->propertySetNames(topLevelOnly);
                        have = 1;
                        shouldCheck = false;
                    }
                    else if (want == 7) 
                        src = _data->names(topLevelOnly);
                    else 
                        src = _data->paramNames(topLevelOnly);
                
                    if (!append) names.erase(names.begin(), names.end());
                
                    StringArray::iterator i;
                    for(i = src.begin(); i != src.end(); ++i) {
                        if (shouldCheck) {
                            if (isPolicy(*i)) 
                                have = 1;
                            else if (isFile(*i)) 
                                have = 2;
                            else 
                                have = 4;
                        }
                        if ((have&want) > 0) {
                            names.push_back(*i);
                            count++;
                        }
                    }
                
                    return count;
                }
                
                /*
                 * load the names of parameters into a given list.  
                 * 
                 * @param prepend       the names string to prepend to any names found.
                 * @param names         the list object to be loaded
                 * @param topLevelOnly  if true, only parameter names at the top of the 
                 *                         hierarchy will be returned; no hierarchical 
                 *                         names will be included.
                 * @param append        if false, the contents of the given list will 
                 *                         be erased before loading the names.  
                 * @param want          a bit field indicating which is desired (1=Policies,
                 *                         2=PolicyFiles, 4=parameters, 7=all).
                 * @return int  the number of names added
                 */
                int Policy::_names(list<string>& names, 
                                   bool topLevelOnly, bool append, int want) const
                {
                    bool shouldCheck = true;
                    vector<string> src;
                    int have = 0, count = 0;
                    if (want == 1) {
                        src = _data->propertySetNames(topLevelOnly);
                        have = 1;
                        shouldCheck = false;
                    }
                    else if (want == 7) 
                        src = _data->names(topLevelOnly);
                    else 
                        src = _data->paramNames(topLevelOnly);
                
                    if (!append) names.erase(names.begin(), names.end());
                
                    StringArray::iterator i;
                    for(i = src.begin(); i != src.end(); ++i) {
                        if (shouldCheck) {
                            if (isPolicy(*i)) 
                                have = 1;
                            else if (isFile(*i)) 
                                have = 2;
                            else 
                                have = 4;
                        }
                        if ((have&want) > 0) {
                            names.push_back(*i);
                            count++;
                        }
                    }
                
                    return count;
                }
                
                template <class T> void Policy::_validate(const std::string& name, const T& value, int curCount) {
                    if (_dictionary) {
                        try {
                            boost::scoped_ptr<Definition> def(_dictionary->makeDef(name));
                            def->validateBasic(name, value, curCount);
                        } catch(NameNotFound& e) {
                            ValidationError ve(LSST_EXCEPT_HERE);
                            ve.addError(name, ValidationError::UNKNOWN_NAME);
                            throw ve;
                        }
                    }
                }
                
                template void Policy::_validate<Policy::Ptr>(std::string const&, Policy::Ptr const&, int);    
                template void Policy::_validate<std::string >(std::string const&, std::string const&, int);
                template void Policy::_validate<bool>(std::string const&, bool const&, int);
                template void Policy::_validate<double>(std::string const&, double const&, int);
                template void Policy::_validate<int>(std::string const&, int const&, int);
                
                /*
                 * return the type information for the underlying type associated with
                 * a given name.  
                 */
                Policy::ValueType Policy::getValueType(const string& name) const {
                    try {
                        const std::type_info& tp = _data->typeOf(name);
                
                        // handle the special case of FilePtr first
                        if (tp == typeid(Persistable::Ptr)) {
                            try {  
                                getFile(name); 
                                return FILE;
                            } catch(...) { }
                        }
                
                        if (tp == typeid(bool)) {
                            return BOOL;
                        }
                        else if(tp == typeid(int)) {
                            return INT;
                        }
                        else if (tp == typeid(double)) {
                            return DOUBLE;
                        }
                        else if (tp == typeid(string)) {
                            return STRING;
                        }
                        else if (tp == typeid(PropertySet::Ptr)) {
                            return POLICY;
                        }
                        else {
                            throw LSST_EXCEPT
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
460  <a href="#a938e0ae">a938e0ae</a> -                 (pexExcept::LogicErrorException,</div>
              ?                                       ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
460  <a href="#826f6e19">826f6e19</a> +                 (pexExcept::LogicError,</div>
                                 string("Policy: illegal type held by PropertySet: ") + tp.name());
                        }
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
463  <a href="#dcd1814e">dcd1814e</a> -     } catch (pexExcept::NotFoundException&) {</div>
              ?                                  ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
463  <a href="#826f6e19">826f6e19</a> +     } catch (pexExcept::NotFoundError&) {</div>
              ?                                  ^^ ^
                        return UNDEF;
                    }
                }
                
                template <> bool Policy::getValue <bool> (const string& name) const {
                    return getBool(name);
                }
                template <> int Policy::getValue <int> (const string& name) const {
                    return getInt(name);
                }
                template <> double Policy::getValue <double> (const string& name) const {
                    return getDouble(name);
                }
                template <> string Policy::getValue <string> (const string& name) const {
                    return getString(name);
                }
                template <>
                Policy::FilePtr Policy::getValue <Policy::FilePtr> (const string& name) const {
                    return getFile(name);
                }
                template <>
                Policy::ConstPtr Policy::getValue <Policy::ConstPtr> (const string& name) const {
                    return getPolicy(name);
                }
                
                template <> vector<bool> Policy::getValueArray<bool>(const string& name) const {
                    return getBoolArray(name);
                }
                template <> vector<int> Policy::getValueArray<int>(const string& name) const {
                    return getIntArray(name);
                }
                template <> vector<double> Policy::getValueArray<double>(const string& name) const {
                    return getDoubleArray(name);
                }
                template <> vector<string> Policy::getValueArray<string>(const string& name) const {
                    return getStringArray(name);
                }
                template <> Policy::FilePtrArray Policy::getValueArray<Policy::FilePtr>(const string& name) const {
                    return getFileArray(name);
                }
                template <> Policy::PolicyPtrArray Policy::getValueArray<Policy::Ptr>(const string& name) const {
                    return getPolicyArray(name);
                }
                template <> Policy::ConstPolicyPtrArray Policy::getValueArray<Policy::ConstPtr>(const string& name) const {
                    return getConstPolicyArray(name);
                }
                
                template <> Policy::ValueType Policy::getValueType<bool>() { return BOOL; }
                template <> Policy::ValueType Policy::getValueType<int>() { return INT; }
                template <> Policy::ValueType Policy::getValueType<double>() { return DOUBLE; }
                template <> Policy::ValueType Policy::getValueType<string>() { return STRING; }
                template <> Policy::ValueType Policy::getValueType<Policy>() { return POLICY; }
                template <> Policy::ValueType Policy::getValueType<Policy::FilePtr>() { return FILE; }
                template <> Policy::ValueType Policy::getValueType<Policy::Ptr>() { return POLICY; }
                template <> Policy::ValueType Policy::getValueType<Policy::ConstPtr>() { return POLICY; }
                
                template <> void Policy::setValue(const string& name, const bool& value) {
                    set(name, value); }
                template <> void Policy::setValue(const string& name, const int& value) {
                    set(name, value); }
                template <> void Policy::setValue(const string& name, const double& value) {
                    set(name, value); }
                template <> void Policy::setValue(const string& name, const string& value) {
                    set(name, value); }
                template <> void Policy::setValue(const string& name, const Ptr& value) {
                    set(name, value); }
                template <> void Policy::setValue(const string& name, const FilePtr& value) {
                    set(name, value); }
                
                template <> void Policy::addValue(const string& name, const bool& value) {
                    add(name, value); }
                template <> void Policy::addValue(const string& name, const int& value) {
                    add(name, value); }
                template <> void Policy::addValue(const string& name, const double& value) {
                    add(name, value); }
                template <> void Policy::addValue(const string& name, const string& value) {
                    add(name, value); }
                template <> void Policy::addValue(const string& name, const Ptr& value) {
                    add(name, value); }
                template <> void Policy::addValue(const string& name, const FilePtr& value) {
                    add(name, value); }
                
                Policy::ConstPolicyPtrArray Policy::getConstPolicyArray(const string& name) const {
                    ConstPolicyPtrArray out;
                    vector<PropertySet::Ptr> psa = _getPropSetList(name);
                    vector<PropertySet::Ptr>::const_iterator i;
                    for(i=psa.begin(); i != psa.end(); ++i) 
                        out.push_back(ConstPtr(new Policy(*i)));
                    return out;
                }
                
                Policy::PolicyPtrArray Policy::getPolicyArray(const string& name) const {
                    PolicyPtrArray out;
                    vector<PropertySet::Ptr> psa = _getPropSetList(name);
                    vector<PropertySet::Ptr>::const_iterator i;
                    for(i=psa.begin(); i != psa.end(); ++i) 
                        out.push_back(Ptr(new Policy(*i)));
                    return out;
                }
                
                Policy::FilePtr Policy::getFile(const string& name) const {
                    FilePtr out = 
                        boost::dynamic_pointer_cast<PolicyFile>(_data->getAsPersistablePtr(name));
                    if (! out.get()) 
                        throw LSST_EXCEPT(TypeError, name, string(typeName[FILE]));
                    return out;
                }
                
                Policy::FilePtrArray Policy::getFileArray(const string& name) const
                {
                    FilePtrArray out;
                    vector<Persistable::Ptr> pfa = _getPersistList(name);
                    vector<Persistable::Ptr>::const_iterator i;
                    FilePtr fp;
                    for(i = pfa.begin(); i != pfa.end(); ++i) {
                        fp = boost::dynamic_pointer_cast<PolicyFile>(*i);
                        if (! fp.get())
                            throw LSST_EXCEPT(TypeError, name, string(typeName[FILE]));
                        out.push_back(fp);
                    }
                
                    return out;
                }
                
                void Policy::set(const string& name, const FilePtr& value) {
                    _data->set(name, boost::dynamic_pointer_cast<Persistable>(value));
                }
                
                void Policy::add(const string& name, const FilePtr& value) {
                    _data->add(name, boost::dynamic_pointer_cast<Persistable>(value));
                }
                
                /**
                 * Recursively replace all PolicyFile values with the contents of the 
                 * files they refer to.  The type of a parameter containing a PolicyFile
                 * will consequently change to a Policy upon successful completion.  If
                 * the value is an array, all PolicyFiles in the array must load without
                 * error before the PolicyFile values themselves are erased.
                 * @param strict      If true, throw an exception if an error occurs 
                 *                    while reading and/or parsing the file.  Otherwise,
                 *                    replace the file reference with a partial or empty
                 *                    (that is, "{}") sub-policy.
                 * @param repository  a directory to look in for the referenced files.  
                 *                    If the name of the file to be included is an absolute
                 *                    path, the repository will be ignored.  If empty or not
                 *                    provided, the directory will be assumed to be the current
                 *                    one.
                 */
                int Policy::loadPolicyFiles(const fs::path& repository, bool strict) {
                    fs::path repos = repository;
                    int result = 0;
                    if (repos.empty()) repos = ".";
                
                    // iterate through the top-level names in this Policy
                    list<string> names;
                    fileNames(names, true);
                    for(list<string>::iterator it=names.begin(); it != names.end(); it++) {
                
                        // iterate through the files in the value array
                        const FilePtrArray& pfiles = getFileArray(*it);
                        PolicyPtrArray pols;
                        pols.reserve(pfiles.size());
                
                        FilePtrArray::const_iterator pfi;
                        for(pfi=pfiles.begin(); pfi != pfiles.end(); pfi++) {
                        // increment even if fail, since we will remove the file record
                        ++result;
                
                            Ptr policy = boost::make_shared<Policy>();
                            try {
                        fs::path path = (*pfi)->getPath();
                        // if possible, use the policy file's own loading mechanism
                        if (path.is_complete()) {
                            (*pfi)->load(*policy);
                        }
                        else {
                            fs::path localPath = repos / (*pfi)->getPath();
                            PolicyFile(localPath.string()).load(*policy);
                        }
                            }
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
644  <a href="#58eed0c0">58eed0c0</a> -             catch (pexExcept::IoErrorException& e) {</div>
              ?                                      ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
644  <a href="#826f6e19">826f6e19</a> +             catch (pexExcept::IoError& e) {</div>
                                if (strict) {
                                    throw e;
                                }
                                // TODO: log a problem
                            }
                            catch (ParserError& e) {
                                if (strict) {
                                    throw e;
                                }
                                // TODO: log a problem
                            }
                            // everything else will get sent up the stack
                
                            pols.push_back(policy);
                        }
                
                        remove(*it);
                        for (PolicyPtrArray::iterator pi = pols.begin(); pi != pols.end(); ++pi)
                            add(*it, *pi);
                    }
                
                    // Now iterate again to recurse into sub-Policy values
                    policyNames(names, true);
                    for(list<string>::iterator it=names.begin(); it != names.end(); it++) {
                        PolicyPtrArray policies = getPolicyArray(*it);
                
                        // iterate through the Policies in this array
                        PolicyPtrArray::iterator pi;
                        for(pi = policies.begin(); pi != policies.end(); pi++)
                            result += (*pi)->loadPolicyFiles(repos, strict);
                    }
                
                    return result;
                }
                
                
                /**
                 * use the values found in the given policy as default values for parameters not
                 * specified in this policy.  This function will iterate through the parameter
                 * names in the given policy, and if the name is not found in this policy, the
                 * value from the given one will be copied into this one.  No attempt is made to
                 * match the number of values available per name.
                 * @param defaultPol  the policy to pull default values from.  This may be a
                 *                    Dictionary; if so, the default values will drawn from the
                 *                    appropriate default keyword.
                 * @param keepForValidation if true, and if defaultPol is a Dictionary, keep
                 *                    a reference to it for validation future updates to
                 *                    this Policy.
                 * @param errs        an exception to load errors into -- only relevant if
                 *                    defaultPol is a Dictionary or if this Policy already has a
                 *                    dictionary to validate against; if a validation error is
                 *                    encountered, it will be added to errs if errs is non-null,
                 *                    and an exception will not be raised; however, if errs is
                 *                    null, an exception will be thrown if a validation error is
                 *                    encountered.
                 * @return int        the number of parameter names copied over
                 */
                int Policy::mergeDefaults(const Policy& defaultPol, bool keepForValidation, 
                                          ValidationError *errs) 
                {
                    int added = 0;
                
                    // if defaultPol is a dictionary, extract the default values
                    auto_ptr<Policy> pol(0);
                    const Policy *def = &defaultPol;
                    if (def->isDictionary()) {
                        // extract default values from dictionary
                        pol.reset(new Policy(false, Dictionary(*def)));
                        def = pol.get();
                    }
                
                    list<string> params;
                    def->paramNames(params);
                    list<string>::iterator nm;
                    for(nm = params.begin(); nm != params.end(); ++nm) {
                        if (! exists(*nm)) {
                            const std::type_info& tp = def->getTypeInfo(*nm);
                            if (tp == typeid(bool)) {
                                BoolArray a = def->getBoolArray(*nm);
                                BoolArray::iterator vi;
                                for(vi=a.begin(); vi != a.end(); ++vi) 
                                    add(*nm, *vi);
                            }
                            else if (tp == typeid(int)) {
                                IntArray a = def->getIntArray(*nm);
                                IntArray::iterator vi;
                                for(vi=a.begin(); vi != a.end(); ++vi) 
                                    add(*nm, *vi);
                            }
                            else if (tp == typeid(double)) {
                                DoubleArray a = def->getDoubleArray(*nm);
                                DoubleArray::iterator vi;
                                for(vi=a.begin(); vi != a.end(); ++vi) 
                                    add(*nm, *vi);
                            }
                            else if (tp == typeid(string)) {
                                StringArray a = def->getStringArray(*nm);
                                StringArray::iterator vi;
                                for(vi=a.begin(); vi != a.end(); ++vi) 
                                    add(*nm, *vi);
                            }
                            else if (def->isFile(*nm)) {
                                FilePtrArray a = def->getFileArray(*nm);
                                FilePtrArray::iterator vi;
                                for(vi=a.begin(); vi != a.end(); ++vi) 
                                    add(*nm, *vi);
                            }
                            else {
                                // should not happen
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
754  <a href="#a938e0ae">a938e0ae</a> -                 throw LSST_EXCEPT(pexExcept::LogicErrorException,</div>
              ?                                                        ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
754  <a href="#826f6e19">826f6e19</a> +                 throw LSST_EXCEPT(pexExcept::LogicError,</div>
                                                  string("Unknown type for \"") + *nm 
                                                  + "\": \"" + getTypeName(*nm) + "\"");
                                // added--;
                            }
                            added++;
                        }
                    }
                
                    // if a dictionary is available, validate after all defaults are added
                    // propagate dictionary?  If so, look for one and use it to validate
                    if (keepForValidation) {
                    if (defaultPol.isDictionary())
                        setDictionary(Dictionary(defaultPol));
                    else if (defaultPol.canValidate())
                        setDictionary(*defaultPol.getDictionary());
                    // if we couldn't find a dictionary, don't complain -- the API should
                    // work with default values even if defaultPol is a Policy without an
                    // attached Dictionary
                    if (canValidate())
                        getDictionary()->validate(*this, errs);
                    }
                    // don't keep a dictionary around, but validate anyway only if defaultPol is
                    // a Dictionary (if keepForValidation is false, there is a possibility that
                    // we don't want to use the attached Dictionary for validation)
                    else if (defaultPol.isDictionary())
                    Dictionary(defaultPol).validate(*this, errs);
                
                    return added;
                }
                
                /*
                 * return a string representation of the value given by a name.  The
                 * string "<null>" is printed if the name does not exist.
                 */
                string Policy::str(const string& name, const string& indent) const {
                    ostringstream out;
                
                    try {
                        const std::type_info& tp = _data->typeOf(name);
                        if (tp == typeid(bool)) {
                            BoolArray b = getBoolArray(name);
                            BoolArray::iterator vi;
                            for(vi=b.begin(); vi != b.end(); ++vi) {
                                out << *vi;
                                if (vi+1 != b.end()) out << ", ";
                            }
                        }
                        else if (tp == typeid(int)) {
                            IntArray i = getIntArray(name);
                            IntArray::iterator vi;
                            for(vi=i.begin(); vi != i.end(); ++vi) {
                                out << *vi;
                                if (vi+1 != i.end()) out << ", ";
                            }
                        }
                        else if (tp == typeid(double)) {
                            DoubleArray d = getDoubleArray(name);
                            DoubleArray::iterator vi;
                            for(vi=d.begin(); vi != d.end(); ++vi) {
                                out << *vi;
                                if (vi+1 != d.end()) out << ", ";
                            }
                        }
                        else if (tp == typeid(string)) {
                            StringArray s = _data->getArray<string>(name);
                            StringArray::iterator vi;
                            for(vi= s.begin(); vi != s.end(); ++vi) {
                                out << '"' << *vi << '"';
                                if (vi+1 != s.end()) out << ", ";
                            }
                        }
                        else if (tp == typeid(PropertySet::Ptr)) {
                            vector<PropertySet::Ptr> p = 
                                _data->getArray<PropertySet::Ptr>(name);
                            vector<PropertySet::Ptr>::iterator vi;
                            for(vi= p.begin(); vi != p.end(); ++vi) {
                                out << "{\n";
                                Policy(*vi).print(out, "", indent+"  ");
                                out << indent << "}";
                                if (vi+1 != p.end()) out << ", ";
                                out.flush();
                            }
                        }
                        else if (tp == typeid(Persistable::Ptr)) {
                            FilePtrArray f = getFileArray(name);
                            FilePtrArray::iterator vi;
                            for(vi= f.begin(); vi != f.end(); ++vi) {
                                out << "FILE:" << (*vi)->getPath();
                                if (vi+1 != f.end()) out << ", ";
                                out.flush();
                            }
                        }
                        else {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
848  <a href="#a938e0ae">a938e0ae</a> -             throw LSST_EXCEPT(pexExcept::LogicErrorException,</div>
              ?                                                    ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
848  <a href="#826f6e19">826f6e19</a> +             throw LSST_EXCEPT(pexExcept::LogicError,</div>
                                              "Policy: unexpected type held by any");
                        }
                    }
                    catch (NameNotFound&) {
                        out << "<null>";
                    }
                
                    // out << ends;   // unnecessary but problematic, according to #316
                    return out.str();
                }
                
                /*
                 * print the contents of this policy to an output stream
                 */
                void Policy::print(ostream& out, const string& label, 
                                   const string& indent) const 
                {
                    list<string> nms;
                    names(nms, true);
                    if (label.size() > 0) 
                        out << indent << label << ":\n";
                    for(list<string>::iterator n = nms.begin(); n != nms.end(); ++n) {
                        out << indent << "  " << *n << ": " << str(*n, indent+"  ") << endl;
                    }
                }
                
                /*
                 * convert the entire contents of this policy to a string.  This 
                 * is mainly intended for debugging purposes.  
                 */
                string Policy::toString() const {
                    ostringstream os;
                    print(os);
                    return os.str();
                }
                
                //@endcond
                
                } // namespace policy
                } // namespace pex
                } // namespace lsst
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="58eed0c0"/></a>58eed0c0</h3>

<pre>
commit 58eed0c07ea5d7f9c9c08f4478b28c756e9913cd
Author: rplante <rplante@git.lsstcorp.org>
Date:   Tue Dec 23 19:34:44 2008 +0000

    Merged revisions 6859-6863 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/458
    
    ........
      r6859 | rplante | 2008-12-23 09:56:24 -0600 (Tue, 23 Dec 2008) | 1 line
    
      branch to update to us new exceptions
    ........
      r6860 | rplante | 2008-12-23 12:15:28 -0600 (Tue, 23 Dec 2008) | 1 line
    
      initial exception update attempt (untested), #458
    ........
      r6861 | rplante | 2008-12-23 12:30:37 -0600 (Tue, 23 Dec 2008) | 1 line
    
      updated table file to add daf_base
    ........
      r6862 | rplante | 2008-12-23 13:20:00 -0600 (Tue, 23 Dec 2008) | 1 line
    
      debugged exception upgrade
    ........
</pre>
<h3><a name="dcd1814e"/></a>dcd1814e</h3>

<pre>
commit dcd1814ef4726014e169971f2141ca2b35de70dc
Author: rplante <rplante@git.lsstcorp.org>
Date:   Fri Feb 27 23:24:12 2009 +0000

    Primarily updated for use of PropertySet
    Cleaned up use of "using"
    bug fix: add workaround to swig bug to support bool types
    improve exception handling
    improve test scripts (explicitly test all types)
</pre>
<h3><a name="a938e0ae"/></a>a938e0ae</h3>

<pre>
commit a938e0ae6e04eb065113480c098a5e9f681a0bb9
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Nov 18 20:48:24 2009 +0000

    Merged revisions 10237-10239,10263,10278-10279,10318-10320,10332,10334-10336,10359,10383,10390,10439,10445-10446,10449,10469-10471,10485,10499-10501,10570,10572-10574,10581-10584,10617,10619-10623,10627,10674-10677,10691,10890,10918,10985-10986,11436-11438,11482,11489-11490 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/872
    
    ........
      r10237 | bbaker | 2009-07-24 13:40:06 -0500 (Fri, 24 Jul 2009) | 1 line
    
      add rough childDefinition definition
    ........
      r10238 | bbaker | 2009-07-24 13:40:33 -0500 (Fri, 24 Jul 2009) | 1 line
    
      rough list of validation tests, from examining the spec in Dictionary.h
    ........
      r10239 | bbaker | 2009-07-24 13:41:18 -0500 (Fri, 24 Jul 2009) | 1 line
    
      comment
    ........
      r10263 | bbaker | 2009-07-27 09:44:48 -0500 (Mon, 27 Jul 2009) | 1 line
    
      add details to list of tests
    ........
      r10278 | bbaker | 2009-07-29 15:00:10 -0500 (Wed, 29 Jul 2009) | 1 line
    
      typos
    ........
      r10279 | bbaker | 2009-07-29 15:00:41 -0500 (Wed, 29 Jul 2009) | 1 line
    
      add some missing fields
    ........
      r10318 | bbaker | 2009-07-31 18:16:01 -0500 (Fri, 31 Jul 2009) | 1 line
    
      primitive examples for development
    ........
      r10319 | bbaker | 2009-07-31 18:16:29 -0500 (Fri, 31 Jul 2009) | 1 line
    
      debugging validation
    ........
      r10320 | bbaker | 2009-07-31 18:17:06 -0500 (Fri, 31 Jul 2009) | 1 line
    
      placeholder
    ........
      r10332 | bbaker | 2009-08-04 11:03:53 -0500 (Tue, 04 Aug 2009) | 1 line
    
      correct typos; tweak constants
    ........
      r10334 | bbaker | 2009-08-04 11:40:31 -0500 (Tue, 04 Aug 2009) | 1 line
    
      fix unit test -- mixed types
    ........
      r10335 | bbaker | 2009-08-04 11:54:01 -0500 (Tue, 04 Aug 2009) | 1 line
    
      dictionary unit test stub
    ........
      r10336 | bbaker | 2009-08-04 13:00:11 -0500 (Tue, 04 Aug 2009) | 1 line
    
      move unit test files into tests; add simple validate
    ........
      r10359 | bbaker | 2009-08-05 17:33:18 -0500 (Wed, 05 Aug 2009) | 1 line
    
      rigorize dictionary type handling
    ........
      r10383 | bbaker | 2009-08-07 13:32:20 -0500 (Fri, 07 Aug 2009) | 1 line
    
      cleaning up values validation
    ........
      r10390 | bbaker | 2009-08-07 17:55:15 -0500 (Fri, 07 Aug 2009) | 1 line
    
      templates templates templates
    ........
      r10439 | bbaker | 2009-08-12 17:26:49 -0500 (Wed, 12 Aug 2009) | 1 line
    
      improve error messages, and other testing
    ........
      r10445 | bbaker | 2009-08-13 14:23:31 -0500 (Thu, 13 Aug 2009) | 1 line
    
      getTypeByName -- whew
    ........
      r10446 | bbaker | 2009-08-13 15:16:55 -0500 (Thu, 13 Aug 2009) | 1 line
    
      more dictionary integrity tests
    ........
      r10449 | bbaker | 2009-08-13 16:37:22 -0500 (Thu, 13 Aug 2009) | 1 line
    
      confirm that policy validation is only partial
    ........
      r10469 | bbaker | 2009-08-14 15:56:35 -0500 (Fri, 14 Aug 2009) | 1 line
    
      value validation
    ........
      r10470 | bbaker | 2009-08-14 15:57:51 -0500 (Fri, 14 Aug 2009) | 1 line
    
      remove finished TODO
    ........
      r10471 | bbaker | 2009-08-14 16:15:24 -0500 (Fri, 14 Aug 2009) | 1 line
    
      detect missing required items
    ........
      r10485 | bbaker | 2009-08-17 17:39:50 -0500 (Mon, 17 Aug 2009) | 1 line
    
      nested validation
    ........
      r10499 | bbaker | 2009-08-18 15:34:33 -0500 (Tue, 18 Aug 2009) | 1 line
    
      childDefinition implementation and tests
    ........
      r10500 | bbaker | 2009-08-18 16:19:48 -0500 (Tue, 18 Aug 2009) | 1 line
    
      comments
    ........
      r10501 | bbaker | 2009-08-18 16:22:02 -0500 (Tue, 18 Aug 2009) | 1 line
    
      TODOs
    ........
      r10570 | bbaker | 2009-09-01 18:06:33 -0500 (Tue, 01 Sep 2009) | 1 line
    
      more validation when loading from defaults
    ........
      r10572 | bbaker | 2009-09-01 21:58:01 -0500 (Tue, 01 Sep 2009) | 1 line
    
      quick emacs cmd
    ........
      r10573 | bbaker | 2009-09-01 22:22:45 -0500 (Tue, 01 Sep 2009) | 1 line
    
      obsolete
    ........
      r10574 | bbaker | 2009-09-01 22:23:08 -0500 (Tue, 01 Sep 2009) | 1 line
    
      validate on set/add -- step 1
    ........
      r10581 | bbaker | 2009-09-03 16:17:42 -0500 (Thu, 03 Sep 2009) | 1 line
    
      accessors for policy.dictionary, test policy self-validation
    ........
      r10582 | bbaker | 2009-09-03 16:22:51 -0500 (Thu, 03 Sep 2009) | 1 line
    
      more set/add tests
    ........
      r10583 | bbaker | 2009-09-03 16:23:40 -0500 (Thu, 03 Sep 2009) | 1 line
    
      comment
    ........
      r10584 | bbaker | 2009-09-03 16:25:31 -0500 (Thu, 03 Sep 2009) | 1 line
    
      oops, test failed
    ........
      r10617 | bbaker | 2009-09-11 15:27:09 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fixes related to nested dictionaries and policies
    ........
      r10619 | bbaker | 2009-09-11 16:09:40 -0500 (Fri, 11 Sep 2009) | 1 line
    
      remove debugging printouts, convert to constants instead of literal strings
    ........
      r10620 | bbaker | 2009-09-11 16:16:57 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fix spelling of EventTranmitter
    ........
      r10621 | bbaker | 2009-09-11 16:22:59 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test condensed dictionary syntax, update docs and TODOs
    ........
      r10622 | bbaker | 2009-09-11 16:24:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test without 'target' field in dictionary
    ........
      r10623 | bbaker | 2009-09-11 16:27:34 -0500 (Fri, 11 Sep 2009) | 1 line
    
      resolve TODO comments
    ........
      r10627 | bbaker | 2009-09-11 17:15:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      deep dictionary loading
    ........
      r10674 | bbaker | 2009-09-18 15:02:18 -0500 (Fri, 18 Sep 2009) | 1 line
    
      use boost::make_shared where possible
    ........
      r10675 | bbaker | 2009-09-18 15:07:03 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10676 | bbaker | 2009-09-18 15:07:42 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10677 | bbaker | 2009-09-18 17:39:14 -0500 (Fri, 18 Sep 2009) | 1 line
    
      working on validation script
    ........
      r10691 | bbaker | 2009-09-21 18:18:48 -0500 (Mon, 21 Sep 2009) | 1 line
    
      validation script for dictionary & policy authors
    ........
      r10890 | bbaker | 2009-10-06 12:22:53 -0500 (Tue, 06 Oct 2009) | 1 line
    
      uses of Policy C++ and Python interfaces
    ........
      r10918 | bbaker | 2009-10-07 13:09:45 -0500 (Wed, 07 Oct 2009) | 1 line
    
      hide certain swig warnings
    ........
      r10985 | bbaker | 2009-10-12 15:44:45 -0500 (Mon, 12 Oct 2009) | 1 line
    
      improve formatting
    ........
      r10986 | bbaker | 2009-10-12 15:46:30 -0500 (Mon, 12 Oct 2009) | 1 line
    
      list of policy files
    ........
      r11436 | bbaker | 2009-11-10 14:02:15 -0600 (Tue, 10 Nov 2009) | 1 line
    
      move validate.py test script into tests dir
    ........
      r11437 | bbaker | 2009-11-10 14:02:40 -0600 (Tue, 10 Nov 2009) | 1 line
    
      reference to --help
    ........
      r11438 | bbaker | 2009-11-10 14:03:28 -0600 (Tue, 10 Nov 2009) | 1 line
    
      pex_policy: add options to mergeDefaults to validate and to keep dictionary
    ........
      r11482 | bbaker | 2009-11-17 15:40:53 -0600 (Tue, 17 Nov 2009) | 1 line
    
      more mergeDefaults -- deep Policy merge
    ........
      r11489 | bbaker | 2009-11-18 12:43:19 -0600 (Wed, 18 Nov 2009) | 1 line
    
      improve standards compliance
    ........
      r11490 | bbaker | 2009-11-18 12:50:15 -0600 (Wed, 18 Nov 2009) | 1 line
    
      more standards compliance
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="c3a8a0d3"/></a>c3a8a0d3</h3>

<pre>
commit c3a8a0d3ded4e6909c3250e8e36e143cd0b790ca
Author: Russell Owen <rowen@uw.edu>
Date:   Sun Oct 5 07:00:45 2014 -0700

    Add static cast for shared_ptr -> bool.
</pre>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_12"><a name="tests/Policy_1.cc"/></a>tests/Policy_1.cc</h1>

<h3 id="toc_13">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file Policy_1.cc
                 *
                 * This test tests the basic access and update methods of the Policy class.
                 */
                #include <iostream>
                #include <sstream>
                #include <string>
                #include <stdexcept>
                #include "lsst/pex/policy.h"
                #include "lsst/pex/policy/PolicyFile.h"
                
                using namespace std;
                using lsst::pex::policy::Policy;
                using lsst::pex::policy::PolicyFile;
                using lsst::pex::policy::TypeError;
                using lsst::pex::policy::NameNotFound;
                
                #define Assert(b, m) tattle(b, m, __LINE__)
                
                void tattle(bool mustBeTrue, const string& failureMsg, int line) {
                    if (! mustBeTrue) {
                        ostringstream msg;
                        msg << __FILE__ << ':' << line << ":\n" << failureMsg << ends;
                        throw runtime_error(msg.str());
                    }
                }
                
                int main() {
                
                    Policy p;
                
                    // tests on an empty policy
                    Assert(! p.exists("foo"), "empty existence test failed");
                    Assert(p.valueCount("foo.bar") == 0, "empty valueCount test failed");
                    Assert(! p.isInt("foo"), "empty existence type test failed");
                
                    try {
                        p.getTypeInfo("foo");
                        Assert(false, "type info available for non-existent value");
                    }
                    catch (NameNotFound&) { }
                
                    // disallow null values
                    try {
                        const char *nothing = NULL;
                        p.set("foo", nothing);
                        Assert(false, "no error when setting value to NULL");
                    }
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
72   <a href="#91663765">91663765</a> -     catch (lsst::pex::exceptions::InvalidParameterException e) { }</div>
              ?                                                    ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
72   <a href="#826f6e19">826f6e19</a> +     catch (lsst::pex::exceptions::InvalidParameterError e) { }</div>
              ?                                                    ^^ ^
                
                    p.set("doall", "true");
                
                    // non-existence tests on a non-empty policy
                    Assert(! p.exists("foo"), "non-empty non-existence test failed");
                    Assert(p.valueCount("foo.bar") == 0, "empty valueCount test failed");
                    Assert(! p.isInt("foo"), "non-empty non-existence type test failed");
                
                    try {
                        p.getTypeInfo("foo");
                        Assert(false, "type info available for non-existent value");
                    }
                    catch (NameNotFound& e) { 
                        cout << "foo confirmed not to exist: " << e.what() << endl;
                    }
                
                    // existence tests
                    Assert(p.exists("doall"), "non-empty existence test failed");
                    Assert(p.valueCount("doall") == 1, "single valueCount test failed");
                
                    // test out our newly added parameter
                    try {  p.getInt("doall"); }
                    catch (TypeError& e) { 
                        cout << "doall confirmed not an Int: " << e.what() << endl;
                    }
                    try {  p.getDoubleArray("doall"); }
                    catch (TypeError&) { }
                
                    cout << "doall: " << p.getString("doall") << endl;
                    Assert(p.getString("doall") == "true", "top-level getString failed");
                    p.set("doall", "duh");
                    cout << "doall: " << p.getString("doall") << endl;
                    Assert(p.getString("doall") == "duh", "top-level reset failed");
                
                    // test that we can access this property as an array
                    vector<std::string> ary = p.getStringArray("doall");
                    Assert(ary.size() == 1, "scalar property has more than one value");
                    Assert(ary[0] == "duh", "scalar access via array failed");
                
                    p.add("doall", "never");
                    cout << "doall: " << p.getString("doall") << endl;
                
                    Assert(p.valueCount("doall") == 2, "2-elem. valueCount test failed");
                
                    // make sure that we can access an array as a scalar properly
                    Assert(p.getString("doall") == "never", "top-level add failed");
                
                    // test array access
                    ary = p.getStringArray("doall");
                    cout << "doall (" << ary.size() << "):";
                    for(vector<std::string>::iterator pi=ary.begin();pi!=ary.end();++pi) 
                        cout << ' ' << *pi;
                    cout << endl;
                    Assert(ary.size() == 2, "scalar property has wrong number of values");
                    Assert(ary[0] == "duh", "scalar access via (2-el) array failed");
                    Assert(ary.back() == "never", "scalar access via (2-el) array failed");
                
                    // test type support
                    p.set("pint", 5);
                    Assert(p.getInt("pint") == 5, "support for type int failed");
                    p.set("pdbl", 5.1);
                    Assert(abs(p.getDouble("pdbl") - 5.1) < 0.0000001, 
                           "support for type double failed");
                    p.set("ptrue", true);
                    Assert(p.getBool("ptrue"), "support for boolean true failed");
                    p.set("pfalse", false);
                    Assert(! p.getBool("pfalse"), "support for boolean false failed");
                
                    // test PolicyFile type
                    string pfile("test.paf");
                    p.add("test", Policy::FilePtr(new PolicyFile(pfile)));
                    Assert(p.getValueType("test") == Policy::FILE, 
                           "Wrong ValueType for PolicyFile");
                    Assert(p.isFile("test"), "PolicyFile's type not recognized");
                    Policy::FilePtr pf = p.getFile("test");
                    Assert(pf->getPath() == pfile, "Corrupted PolicyFile name");
                        
                    // test hierarchical access
                    string standalone("Dictionary.definition.standalone");
                    string minOccurs = standalone+".minOccurs";
                    p.set(minOccurs, 1);
                    cout << minOccurs << ": " << p.getInt(minOccurs) << endl;
                    Assert(p.getInt(minOccurs) == 1, "hierarchical property set failed");
                    Assert(p.exists(minOccurs), "hierarchical existence test failed");
                    Assert(p.valueCount(minOccurs) == 1,"hierarchical valueCount test failed");
                
                    Policy::Ptr sp = p.getPolicy(standalone);
                    sp->set("type", "int");
                    cout <<  standalone+".type"<< ": " << p.getString(standalone+".type") 
                         << endl;
                    Assert(p.getString(standalone+".type") == "int", "encapsulated set failed");
                    sp->set("required", false);
                    cout << standalone+".required"<< ": " << p.getBool(standalone+".required") 
                         << endl;
                    Assert(!p.getBool(standalone+".required"), "boolean set failed");
                
                    sp->add("score", 3.4);
                    cout <<  standalone+".score"<< ": " << p.getDouble(standalone+".score") 
                         << endl;
                    Assert(sp->getDouble("score") - 3.4 < 0.0000000000001, 
                           "double type set failed");
                
                    // list names
                    list<string> names;
                    int npol = p.policyNames(names);
                    int nprm = p.paramNames(names);
                    int nfile = p.fileNames(names);
                    int nall = p.names(names);
                    cout << "policy now has " << nall << " names (" << npol << " policies, "
                         << nprm << " parameters):" << endl;
                    for(list<string>::iterator i=names.begin(); i!=names.end(); ++i) 
                        cout << "   " << *i << ": " << p.getTypeName(*i) << endl;
                    Assert(npol + nfile + nprm == nall, "name listing failed");
                
                    // show Types
                    cout << "Types:" << endl;
                    cout << "\tdoall: " << p.getTypeInfo("doall").name() << endl;
                    cout << "\tminOccurs: " << sp->getTypeInfo("minOccurs").name() << endl;
                    cout << "\tscore: " << sp->getTypeInfo("score").name() << endl;
                    cout << "\trequired: " << sp->getTypeInfo("required").name() << endl;
                    cout << "\tstandalone: " 
                         << p.getTypeInfo("Dictionary.definition.standalone").name() << endl;
                    cout << "\ttest: " << p.getTypeInfo("test").name() << endl;
                
                    // Test shallow and deep copies
                    Policy shallow(p);
                    const Policy& cp = p;
                    Policy deep(cp);
                    sp->add("score", 1.355);
                    double deepscore = deep.getDouble(standalone + ".score");
                    double shallowscore = shallow.getDouble(standalone + ".score");
                    cout << "shallow copy score: " << shallowscore << endl;
                    cout << "deep copy score: " << deepscore << endl;
                    Assert(abs(shallowscore - 1.355) < 0.000000001,
                           "shallow copy failure: score should = 1.355");
                    Assert(abs(deepscore - 3.4) < 0.000000001,
                           "deep copy failure: score should = 3.4");
                }
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="91663765"/></a>91663765</h3>

<pre>
commit 916637653dca141b6deda4653980ed228e7c2696
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Dec 2 23:29:08 2009 +0000

    Ticket #1050 - handle values of Nothing (throw a clear exception)
    
    Merged revisions 11673,11688 via svnmerge from
    svn+ssh://bbaker@svn.lsstcorp.org/DMS/pex/policy/tickets/1050
    
    ........
      r11673 | bbaker | 2009-12-02 15:05:35 -0600 (Wed, 02 Dec 2009) | 1 line
    
      ticket #1050 - assertion failure when set a value to None
    ........
      r11688 | bbaker | 2009-12-02 17:12:42 -0600 (Wed, 02 Dec 2009) | 1 line
    
      disallow value of Nothing in Policy
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_14"><a name="include/lsst/pex/policy/parserexceptions.h"/></a>include/lsst/pex/policy/parserexceptions.h</h1>

<h3 id="toc_15">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file parserexceptions.h
                 * @ingroup pex
                 * @brief definition of Policy parsing exceptions
                 * @author Ray Plante
                 */
                
                #ifndef LSST_PEX_POLICY_PARSER_EXCEPTIONS_H
                #define LSST_PEX_POLICY_PARSER_EXCEPTIONS_H
                
                #include "lsst/pex/policy/exceptions.h"
                #include <sstream>
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                /**
                 * an parent exception for errors that occur during the parsing of policy 
                 * files.  
                 */
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
46   <a href="#ffbde6ab">ffbde6ab</a> - class ParserError : public lsst::pex::exceptions::RuntimeErrorException {</div>
              ?                                                               ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
46   <a href="#826f6e19">826f6e19</a> + class ParserError : public lsst::pex::exceptions::RuntimeError {</div>
                public:
                
                    /**
                     * Create an exception the exception with a default message.
                     */
                    ParserError(POL_EARGS_TYPED) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
53   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::RuntimeErrorException(</div>
              ?                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
53   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::RuntimeError(</div>
                                POL_EARGS_UNTYPED, "Unspecified parsing error encountered") 
                    { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     */
                    ParserError(POL_EARGS_TYPED, const std::string& msg) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
62   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::RuntimeErrorException(POL_EARGS_UNTYPED, msg) </div>
              ?                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
62   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::RuntimeError(POL_EARGS_UNTYPED, msg) </div>
                    { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     * @param lineno  a line number in the file (or stream) being parsed 
                     *                  where the problem occurred.  The first line of the 
                     *                  file is typically line 1.  
                     */
                    ParserError(POL_EARGS_TYPED, const std::string& msg, int lineno) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
73   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::RuntimeErrorException(</div>
              ?                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
73   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::RuntimeError(</div>
                                POL_EARGS_UNTYPED, makeLocatedMessage(msg,lineno)) 
                    { }
                
                    static std::string makeLocatedMessage(const std::string& msg, int lineno) {
                        std::ostringstream out;
                        out << "Policy Parsing Error:" << lineno << ": " << msg << std::ends;
                        return out.str();
                    }
                
                    virtual char const *getType() const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                /**
                 * an exception indicated that the stream being parsed ended prematurely.
                 */
                class EOFError : public ParserError {
                public:
                
                    /**
                     * Create an exception the exception with a default message.
                     */
                    EOFError(POL_EARGS_TYPED) 
                        : ParserError(POL_EARGS_UNTYPED, 
                                      "Unexpected end of Policy data stream") 
                    { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     */
                    EOFError(POL_EARGS_TYPED, const std::string& msg) 
                        : ParserError(POL_EARGS_UNTYPED, msg) { }
                
                    /**
                     * Create an exception the exception with a default message.
                     * @param lineno  a line number in the file (or stream) being parsed 
                     *                  where the problem occurred.  The first line of the 
                     *                  file is typically line 1.  
                     */
                    EOFError(POL_EARGS_TYPED, int lineno) 
                        : ParserError(POL_EARGS_UNTYPED, 
                                      "Unexpected end of Policy data stream", lineno) 
                    { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     * @param lineno  a line number in the file (or stream) being parsed 
                     *                  where the problem occurred.  The first line of the 
                     *                  file is typically line 1.  
                     */
                    EOFError(POL_EARGS_TYPED, const std::string& msg, int lineno) 
                        : ParserError(POL_EARGS_UNTYPED, msg, lineno) { }
                
                    virtual char const *getType() const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                /**
                 * an exception thrown because a general syntax error was encountered.
                 */
                class SyntaxError : public ParserError {
                public:
                
                    /**
                     * Create an exception the exception with a default message.
                     */
                    SyntaxError(POL_EARGS_TYPED) 
                        : ParserError(POL_EARGS_UNTYPED, "Unknonwn syntax error") { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     */
                    SyntaxError(POL_EARGS_TYPED, const std::string& msg) 
                        : ParserError(POL_EARGS_UNTYPED, msg) { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     * @param lineno  a line number in the file (or stream) being parsed 
                     *                  where the problem occurred.  The first line of the 
                     *                  file is typically line 1.  
                     */
                    SyntaxError(POL_EARGS_TYPED, const std::string& msg, int lineno) 
                        : ParserError(POL_EARGS_UNTYPED, msg, lineno) { }
                
                    virtual char const *getType() const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                /**
                 * an exception thrown because a syntax error specific to the format
                 * being parsed was encountered.
                 */
                class FormatSyntaxError : public SyntaxError {
                public:
                
                    /**
                     * Create an exception the exception with a default message.
                     */
                    FormatSyntaxError(POL_EARGS_TYPED) 
                        : SyntaxError(POL_EARGS_UNTYPED, "Unknonwn syntax error") { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     */
                    FormatSyntaxError(POL_EARGS_TYPED, const std::string& msg) 
                        : SyntaxError(POL_EARGS_UNTYPED, msg) { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     * @param lineno  a line number in the file (or stream) being parsed 
                     *                  where the problem occurred.  The first line of the 
                     *                  file is typically line 1.  
                     */
                    FormatSyntaxError(POL_EARGS_TYPED, const std::string& msg, int lineno) 
                        : SyntaxError(POL_EARGS_UNTYPED, msg, lineno) { }
                
                    virtual char const *getType() const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                /**
                 * an exception thrown because syntax was encountered that is legal for the 
                 * format being parsed but which is not supported for encoding Policies.  
                 */
                class UnsupportedSyntax : public SyntaxError {
                public:
                
                    /**
                     * Create an exception the exception with a default message.
                     */
                    UnsupportedSyntax(POL_EARGS_TYPED) 
                        : SyntaxError(POL_EARGS_UNTYPED, "Unsupported syntax error") { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     */
                    UnsupportedSyntax(POL_EARGS_TYPED, const std::string& msg) 
                        : SyntaxError(POL_EARGS_UNTYPED, msg) { }
                
                    /**
                     * Create an exception the exception with a given message.
                     * @param msg     a message describing the problem.
                     * @param lineno  a line number in the file (or stream) being parsed 
                     *                  where the problem occurred.  The first line of the 
                     *                  file is typically line 1.  
                     */
                    UnsupportedSyntax(POL_EARGS_TYPED, const std::string& msg, int lineno) 
                        : SyntaxError(POL_EARGS_UNTYPED, msg, lineno) { }
                
                    virtual char const *getType() const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                
                
                
                }}}  // end namespace lsst::pex::policy
                
                
                #endif // LSST_PEX_POLICY_PARSER_EXCEPTIONS_H
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="ffbde6ab"/></a>ffbde6ab</h3>

<pre>
commit ffbde6abe48212de8420148bd05e9ef2b5e96ffe
Author: smm <smm@git.lsstcorp.org>
Date:   Mon Nov 7 21:41:56 2011 +0000

    pex_policy Winter2012b: remove namespace aliases in headers, upgrade to swig 2.x
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_16"><a name="bin/validate.py"/></a>bin/validate.py</h1>

<h3 id="toc_17">Diff:</h3>

<pre>
                #! /usr/bin/env python
                
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                #
                import optparse
                import sys
                import os
                
                from lsst.pex.policy import Policy, Dictionary
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
31   <a href="#a938e0ae">a938e0ae</a> - from lsst.pex.exceptions import LsstCppException</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
31   <a href="#0050b976">0050b976</a> + import lsst.pex.exceptions</div>
                
                usage = """usage: %prog [--help] <options> [policy] [dictionary]"""
                
                desc = """
                Validate a policy file against a dictionary (policy schema).
                """
                
                class PolicyValidator:
                    def __init__(self):
                        self.verbose = False
                
                    def main(self, argv=None):
                        self.parseArgs(argv)
                
                        # 1. load policy
                        policy = self.tryThis(Policy,
                                              "reading policy file \"" + self.policyFile + "\"",
                                              self.policyFile)
                
                        # resolve policy file references
                        polLoadDir = self.options.loadPolicy
                        polLoadDesc = polLoadDir
                        if polLoadDir == None:
                            if self.verbose:
                                print "No policy load dir specified; using current dir."
                            polLoadDir = ""
                            polLoadDesc = "current directory; " \
                                          "try -l DIR or --load-policy-references=DIR"
                        message = "resolving references in " + self.policyFile + ",\n    using " \
                                  + polLoadDesc
                        self.tryThis(policy.loadPolicyFiles, message, polLoadDir, True)
                
                        # 2. load dictionary
                        dictionary = self.tryThis(Dictionary,
                                                  "reading dictionary file \"" + self.dictFile + "\"",
                                                  self.dictFile)
                
                        # resolve dictionary file references
                        dictLoadDir = self.options.loadDict
                        dictLoadDesc = dictLoadDir
                        if (dictLoadDir == None):
                            if self.verbose:
                                print "No dictionary load dir specified; using policy load dir", \
                                      polLoadDesc
                            if polLoadDir != "":
                                dictLoadDir = polLoadDir
                                dictLoadDesc = polLoadDesc
                            else:
                                dictLoadDir = ""
                                dictLoadDesc = "current directory; " \
                                               "try -l DIR or --load-dictionary-references=DIR"
                        message = "resolving references in " + self.dictFile + ",\n" \
                                  "    using " + dictLoadDesc
                        self.tryThis(dictionary.loadPolicyFiles, message, dictLoadDir, True)
                    
                        # 3. merge defaults into policy
                        defaults = None
                        defaultsFile = self.options.defaults
                        if (defaultsFile != None):
                            defaults = self.tryThis(Policy,
                                                    "reading defaults from \"" + defaultsFile + "\"",
                                                    defaultsFile)
                        else: defaults = dictionary # if no defaults file specified, use dictionary
                        self.tryThis(policy.mergeDefaults, "merging defaults into policy", defaults)
                
                        # 4. validate
                        self.tryThis(dictionary.validate,
                                     "validating " + self.policyFile + "\n    against " + self.dictFile,
                                     policy)
                
                        if self.verbose:
                            print
                        print "Validation passed:"
                        print "      policy: " + self.policyFile
                        print "                  is a valid instance of"
                        print "  dictionary: " + self.dictFile
                
                    def tryThis(self, callableObj, explain, *args, **kwargs):
                        try:
                            if self.verbose: print explain
                            result = callableObj(*args, **kwargs)
                            return result
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#a938e0ae">a938e0ae</a> -         except LsstCppException, e:</div>
              ?                ^   ^           ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#0050b976">0050b976</a> +         except lsst.pex.exceptions.Exception as e:</div>
              ?                ^   ^ +++++++ ++++++         ^^^
                            print "error", explain + ":"
                            print e.args[0].what()
                            sys.exit(2)
                
                    def parseArgs(self, argv=None):
                        # see http://docs.python.org/library/optparse.html
                        self.parser = optparse.OptionParser(usage=usage, description=desc) # parasoft-suppress W0201
                        self.parser.add_option("-d", "--dictionary", dest="dictionary", metavar="FILE",
                                               help="The dictionary to validate a policy against.")
                        self.parser.add_option("-p", "--policy", dest="policy", metavar="FILE",
                                               help="the policy to validate")
                        self.parser.add_option("-l", "--load-policy-references", dest="loadPolicy",
                                               metavar="DIR",
                                               help="Directory from which to load policy file "
                                               "references (if not specified, load from "
                                               "current directory).")
                        self.parser.add_option("-L", "--load-dictionary-references", dest="loadDict",
                                               metavar="DIR",
                                               help="Directory from which to load dictionary "
                                               "file references (if not specified, load from "
                                               "policy references dir).")
                        self.parser.add_option("-D", "--load-defaults", dest="defaults", metavar="FILE",
                                               help="Load defaults from FILE, which can be a policy "
                                               "or dictionary.  If not specified, load defaults from "
                                               "the dictionary being used for validation.")
                        self.parser.add_option("-v", "--verbose", dest="verbose",
                                               action="store_const", const=True,
                                               help="Print extra messages.")
                
                        if argv is None:
                            argv = sys.argv
                        (self.options, args) = self.parser.parse_args(argv) # parasoft-suppress W0201
                        # print "args =", args, len(args)
                        # print "options =", self.options
                        if (self.options.verbose != None):
                            self.verbose = self.options.verbose
                        
                        self.policyFile = self.options.policy               # parasoft-suppress W0201
                        self.dictFile = self.options.dictionary             # parasoft-suppress W0201
                        del args[0] # script name
                        if (self.policyFile == None):
                            if len(args) < 1:
                                self.parser.error("no policy specified")
                            self.policyFile = args[0]
                            del(args[0])
                        if (self.dictFile == None):
                            if len(args) < 1:
                                self.parser.error("no dictionary specified")
                            self.dictFile = args[0]
                            del(args[0])
                
                        if not os.path.exists(self.policyFile):
                            self.parser.error("file not found: " + self.policyFile)
                        if not os.path.exists(self.dictFile):
                            self.parser.error("file not found: " + self.dictFile)
                
                        if len(args) != 0:
                            self.parser.error("too many arguments: " + str(args) + " were not parsed.")
                
                if __name__ == "__main__":
                    pv = PolicyValidator()
                    pv.main()
                    sys.exit(0)
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="a938e0ae"/></a>a938e0ae</h3>

<pre>
commit a938e0ae6e04eb065113480c098a5e9f681a0bb9
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Nov 18 20:48:24 2009 +0000

    Merged revisions 10237-10239,10263,10278-10279,10318-10320,10332,10334-10336,10359,10383,10390,10439,10445-10446,10449,10469-10471,10485,10499-10501,10570,10572-10574,10581-10584,10617,10619-10623,10627,10674-10677,10691,10890,10918,10985-10986,11436-11438,11482,11489-11490 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/872
    
    ........
      r10237 | bbaker | 2009-07-24 13:40:06 -0500 (Fri, 24 Jul 2009) | 1 line
    
      add rough childDefinition definition
    ........
      r10238 | bbaker | 2009-07-24 13:40:33 -0500 (Fri, 24 Jul 2009) | 1 line
    
      rough list of validation tests, from examining the spec in Dictionary.h
    ........
      r10239 | bbaker | 2009-07-24 13:41:18 -0500 (Fri, 24 Jul 2009) | 1 line
    
      comment
    ........
      r10263 | bbaker | 2009-07-27 09:44:48 -0500 (Mon, 27 Jul 2009) | 1 line
    
      add details to list of tests
    ........
      r10278 | bbaker | 2009-07-29 15:00:10 -0500 (Wed, 29 Jul 2009) | 1 line
    
      typos
    ........
      r10279 | bbaker | 2009-07-29 15:00:41 -0500 (Wed, 29 Jul 2009) | 1 line
    
      add some missing fields
    ........
      r10318 | bbaker | 2009-07-31 18:16:01 -0500 (Fri, 31 Jul 2009) | 1 line
    
      primitive examples for development
    ........
      r10319 | bbaker | 2009-07-31 18:16:29 -0500 (Fri, 31 Jul 2009) | 1 line
    
      debugging validation
    ........
      r10320 | bbaker | 2009-07-31 18:17:06 -0500 (Fri, 31 Jul 2009) | 1 line
    
      placeholder
    ........
      r10332 | bbaker | 2009-08-04 11:03:53 -0500 (Tue, 04 Aug 2009) | 1 line
    
      correct typos; tweak constants
    ........
      r10334 | bbaker | 2009-08-04 11:40:31 -0500 (Tue, 04 Aug 2009) | 1 line
    
      fix unit test -- mixed types
    ........
      r10335 | bbaker | 2009-08-04 11:54:01 -0500 (Tue, 04 Aug 2009) | 1 line
    
      dictionary unit test stub
    ........
      r10336 | bbaker | 2009-08-04 13:00:11 -0500 (Tue, 04 Aug 2009) | 1 line
    
      move unit test files into tests; add simple validate
    ........
      r10359 | bbaker | 2009-08-05 17:33:18 -0500 (Wed, 05 Aug 2009) | 1 line
    
      rigorize dictionary type handling
    ........
      r10383 | bbaker | 2009-08-07 13:32:20 -0500 (Fri, 07 Aug 2009) | 1 line
    
      cleaning up values validation
    ........
      r10390 | bbaker | 2009-08-07 17:55:15 -0500 (Fri, 07 Aug 2009) | 1 line
    
      templates templates templates
    ........
      r10439 | bbaker | 2009-08-12 17:26:49 -0500 (Wed, 12 Aug 2009) | 1 line
    
      improve error messages, and other testing
    ........
      r10445 | bbaker | 2009-08-13 14:23:31 -0500 (Thu, 13 Aug 2009) | 1 line
    
      getTypeByName -- whew
    ........
      r10446 | bbaker | 2009-08-13 15:16:55 -0500 (Thu, 13 Aug 2009) | 1 line
    
      more dictionary integrity tests
    ........
      r10449 | bbaker | 2009-08-13 16:37:22 -0500 (Thu, 13 Aug 2009) | 1 line
    
      confirm that policy validation is only partial
    ........
      r10469 | bbaker | 2009-08-14 15:56:35 -0500 (Fri, 14 Aug 2009) | 1 line
    
      value validation
    ........
      r10470 | bbaker | 2009-08-14 15:57:51 -0500 (Fri, 14 Aug 2009) | 1 line
    
      remove finished TODO
    ........
      r10471 | bbaker | 2009-08-14 16:15:24 -0500 (Fri, 14 Aug 2009) | 1 line
    
      detect missing required items
    ........
      r10485 | bbaker | 2009-08-17 17:39:50 -0500 (Mon, 17 Aug 2009) | 1 line
    
      nested validation
    ........
      r10499 | bbaker | 2009-08-18 15:34:33 -0500 (Tue, 18 Aug 2009) | 1 line
    
      childDefinition implementation and tests
    ........
      r10500 | bbaker | 2009-08-18 16:19:48 -0500 (Tue, 18 Aug 2009) | 1 line
    
      comments
    ........
      r10501 | bbaker | 2009-08-18 16:22:02 -0500 (Tue, 18 Aug 2009) | 1 line
    
      TODOs
    ........
      r10570 | bbaker | 2009-09-01 18:06:33 -0500 (Tue, 01 Sep 2009) | 1 line
    
      more validation when loading from defaults
    ........
      r10572 | bbaker | 2009-09-01 21:58:01 -0500 (Tue, 01 Sep 2009) | 1 line
    
      quick emacs cmd
    ........
      r10573 | bbaker | 2009-09-01 22:22:45 -0500 (Tue, 01 Sep 2009) | 1 line
    
      obsolete
    ........
      r10574 | bbaker | 2009-09-01 22:23:08 -0500 (Tue, 01 Sep 2009) | 1 line
    
      validate on set/add -- step 1
    ........
      r10581 | bbaker | 2009-09-03 16:17:42 -0500 (Thu, 03 Sep 2009) | 1 line
    
      accessors for policy.dictionary, test policy self-validation
    ........
      r10582 | bbaker | 2009-09-03 16:22:51 -0500 (Thu, 03 Sep 2009) | 1 line
    
      more set/add tests
    ........
      r10583 | bbaker | 2009-09-03 16:23:40 -0500 (Thu, 03 Sep 2009) | 1 line
    
      comment
    ........
      r10584 | bbaker | 2009-09-03 16:25:31 -0500 (Thu, 03 Sep 2009) | 1 line
    
      oops, test failed
    ........
      r10617 | bbaker | 2009-09-11 15:27:09 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fixes related to nested dictionaries and policies
    ........
      r10619 | bbaker | 2009-09-11 16:09:40 -0500 (Fri, 11 Sep 2009) | 1 line
    
      remove debugging printouts, convert to constants instead of literal strings
    ........
      r10620 | bbaker | 2009-09-11 16:16:57 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fix spelling of EventTranmitter
    ........
      r10621 | bbaker | 2009-09-11 16:22:59 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test condensed dictionary syntax, update docs and TODOs
    ........
      r10622 | bbaker | 2009-09-11 16:24:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test without 'target' field in dictionary
    ........
      r10623 | bbaker | 2009-09-11 16:27:34 -0500 (Fri, 11 Sep 2009) | 1 line
    
      resolve TODO comments
    ........
      r10627 | bbaker | 2009-09-11 17:15:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      deep dictionary loading
    ........
      r10674 | bbaker | 2009-09-18 15:02:18 -0500 (Fri, 18 Sep 2009) | 1 line
    
      use boost::make_shared where possible
    ........
      r10675 | bbaker | 2009-09-18 15:07:03 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10676 | bbaker | 2009-09-18 15:07:42 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10677 | bbaker | 2009-09-18 17:39:14 -0500 (Fri, 18 Sep 2009) | 1 line
    
      working on validation script
    ........
      r10691 | bbaker | 2009-09-21 18:18:48 -0500 (Mon, 21 Sep 2009) | 1 line
    
      validation script for dictionary & policy authors
    ........
      r10890 | bbaker | 2009-10-06 12:22:53 -0500 (Tue, 06 Oct 2009) | 1 line
    
      uses of Policy C++ and Python interfaces
    ........
      r10918 | bbaker | 2009-10-07 13:09:45 -0500 (Wed, 07 Oct 2009) | 1 line
    
      hide certain swig warnings
    ........
      r10985 | bbaker | 2009-10-12 15:44:45 -0500 (Mon, 12 Oct 2009) | 1 line
    
      improve formatting
    ........
      r10986 | bbaker | 2009-10-12 15:46:30 -0500 (Mon, 12 Oct 2009) | 1 line
    
      list of policy files
    ........
      r11436 | bbaker | 2009-11-10 14:02:15 -0600 (Tue, 10 Nov 2009) | 1 line
    
      move validate.py test script into tests dir
    ........
      r11437 | bbaker | 2009-11-10 14:02:40 -0600 (Tue, 10 Nov 2009) | 1 line
    
      reference to --help
    ........
      r11438 | bbaker | 2009-11-10 14:03:28 -0600 (Tue, 10 Nov 2009) | 1 line
    
      pex_policy: add options to mergeDefaults to validate and to keep dictionary
    ........
      r11482 | bbaker | 2009-11-17 15:40:53 -0600 (Tue, 17 Nov 2009) | 1 line
    
      more mergeDefaults -- deep Policy merge
    ........
      r11489 | bbaker | 2009-11-18 12:43:19 -0600 (Wed, 18 Nov 2009) | 1 line
    
      improve standards compliance
    ........
      r11490 | bbaker | 2009-11-18 12:50:15 -0600 (Wed, 18 Nov 2009) | 1 line
    
      more standards compliance
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="0050b976"/></a>0050b976</h3>

<pre>
commit 0050b9767b605916c0d6fff20a22dd9476cf0c25
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 15:08:59 2014 -0400

    Adapt to changes in Python Swig wrappers (DM-827)
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_18"><a name="src/PolicyWriter.cc"/></a>src/PolicyWriter.cc</h1>

<h3 id="toc_19">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * \file PolicyWriter.cc
                 */
                #include "lsst/pex/policy/PolicyWriter.h"
                #include "lsst/pex/policy/Policy.h"
                #include "lsst/pex/policy/PolicyFile.h"
                
                #include <fstream>
                #include <sstream>
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                //@cond
                using lsst::daf::base::PropertySet;
                using lsst::daf::base::Persistable;
                
                /*
                 * create a writer attached to an output stream
                 * @param out     the output stream to write data to
                 */
                PolicyWriter::PolicyWriter(std::ostream *out) : _myos(0), _os(out) {
                    if (! out) {
                        _myos = new std::ostringstream();
                        _os = _myos;
                    }
                }
                
                /*
                 * create a writer attached to a file.  The file will be immediately 
                 * opened for writing.
                 * @param file     the path to the output file
                 */
                PolicyWriter::PolicyWriter(const std::string& file, bool append) 
                    : _myos(new std::ofstream(file.c_str(), append ? std::ios_base::app 
                                                                   : std::ios_base::trunc)),
                      _os(0)
                {
                    _myos->exceptions(std::ofstream::failbit | std::ofstream::badbit);
                    _os = _myos;
                }
                
                PolicyWriter::~PolicyWriter() {
                    if (_myos) delete _myos;
                }
                
                /*
                 * return the written data as a string.  This string will be non-empty 
                 * only if this class was was instantiated without an attached stream.
                 */
                std::string PolicyWriter::toString() {
                    std::ostringstream *ss = dynamic_cast<std::ostringstream*>(_os);
                    if (ss) return ss->str();
                    return std::string();
                }
                
                /*
                 * close the output stream.  This has no effect if the attached 
                 * stream is not a file stream.  
                 */
                void PolicyWriter::close() {  
                    std::ofstream *fs = dynamic_cast<std::ofstream*>(_os);
                    if (fs) fs->close();
                }
                
                /*
                 * write the contents of a policy the attached stream.  Each top-level
                 * parameter will be recursively printed.
                 * @param policy     the policy data to write
                 */
                void PolicyWriter::write(const Policy& policy, bool doDecl) {
                    if (doDecl) 
                        (*_os) << "#<?cfg paf policy ?>" << std::endl;
                
                    Policy::StringArray names = policy.names(true);
                    Policy::StringArray::const_iterator ni;
                    for(ni=names.begin(); ni != names.end(); ++ni) {
                        try {
                            const std::type_info& tp = policy.typeOf(*ni);
                            if (tp == typeid(bool)) {
                                writeBools(*ni, policy.getBoolArray(*ni));
                            }
                            else if (tp == typeid(int)) {
                                writeInts(*ni, policy.getIntArray(*ni));
                            }
                            else if (tp == typeid(double)) {
                                writeDoubles(*ni, policy.getDoubleArray(*ni));
                            }
                            else if (tp == typeid(std::string)) {
                                writeStrings(*ni, policy.getStringArray(*ni));
                            }
                            else if (tp == typeid(PropertySet::Ptr)) {
                                writePolicies(*ni, policy.getPolicyArray(*ni));
                            }
                            else if (tp == typeid(Persistable::Ptr)) {
                                writeFiles(*ni, policy.getFileArray(*ni));
                            }
                            else {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
122  <a href="#a111e091">a111e091</a> -                 throw LSST_EXCEPT(pexExcept::LogicErrorException, "Policy: unexpected type for name=" + *ni);</div>
              ?                                                        ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
122  <a href="#826f6e19">826f6e19</a> +                 throw LSST_EXCEPT(pexExcept::LogicError, "Policy: unexpected type for name=" + *ni);</div>
                            }
                        }
                        catch (NameNotFound&) {
                            // shouldn't happen
                            writeString(*ni, "<missing data>");
                        }
                    }
                
                }
                
                void PolicyWriter::writeBool(const std::string& name, bool value) { 
                    std::vector<bool> vals;
                    vals.push_back(value);
                    writeBools(name, vals);
                }
                
                void PolicyWriter::writeInt(const std::string& name, int value) { 
                    std::vector<int> vals;
                    vals.push_back(value);
                    writeInts(name, vals);
                }
                
                void PolicyWriter::writeDouble(const std::string& name, double value) { 
                    std::vector<double> vals;
                    vals.push_back(value);
                    writeDoubles(name, vals);
                }
                
                void PolicyWriter::writeString(const std::string& name, 
                                               const std::string& value) 
                {
                    std::vector<std::string> vals; 
                    vals.push_back(value); 
                    writeStrings(name, vals); 
                }
                
                void PolicyWriter::writePolicy(const std::string& name, const Policy& value) {
                    std::vector<Policy::Ptr> vals; 
                    vals.push_back(Policy::Ptr(new Policy(value))); 
                    writePolicies(name, vals); 
                }
                
                void PolicyWriter::writeFile(const std::string& name, 
                                             const PolicyFile& value) 
                { 
                    std::vector<Policy::FilePtr> vals; 
                    vals.push_back(Policy::FilePtr(new PolicyFile(value))); 
                    writeFiles(name, vals); 
                }
                
                
                //@endcond
                
                }}}  // end lsst::pex::policy
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="a111e091"/></a>a111e091</h3>

<pre>
commit a111e091f4689f9ca13d563fe09ad43f23d002f7
Author: rplante <rplante@git.lsstcorp.org>
Date:   Thu Mar 5 08:05:14 2009 +0000

    initial implemenation of writers
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_20"><a name="bin/prototype_dictionary.py"/></a>bin/prototype_dictionary.py</h1>

<h3 id="toc_21">Diff:</h3>

<pre>
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                import optparse
                import sys
                import os
                
                from lsst.pex.policy import Policy, Dictionary, PAFWriter
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
28   <a href="#be0cfb8b">be0cfb8b</a> - from lsst.pex.exceptions import LsstCppException</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
28   <a href="#0050b976">0050b976</a> + import lsst.pex.exceptions</div>
                
                usage = """usage: %prog [--help] <options> <policy>"""
                
                desc = """
                Extrapolate a Dictionary from a Policy in such a way that the Policy is a valid
                instance of the Dictionary.  In practice, the Dictionary will probably be overly
                strict, and you will want to loosen it up by hand.
                """
                
                class PolicyValidator:
                    def __init__(self):
                        self.verbose = False
                
                    def main(self, argv=None):
                        self.parseArgs(argv)
                
                        # 1. load policy
                        policy = self.tryThis(Policy,
                                              "Reading policy file \"" + self.policyFile + "\"",
                                              self.policyFile)
                
                        # resolve policy file references
                        polLoadDir = self.options.loadPolicy
                        polLoadDesc = polLoadDir
                        if polLoadDir == None:
                            if self.policyFile.find("/") >= 0:
                                polLoadDir = self.policyFile.rpartition("/")[0]
                                polLoadDesc = polLoadDir
                            else:
                                polLoadDir = ""
                                polLoadDesc = "current directory; " \
                                              "try -l DIR or --load-policy-references=DIR"
                            if self.verbose:
                                print "No policy load dir specified; defaulting to " + polLoadDesc
                        message = "Resolving references in " + self.policyFile \
                                  + ",\n    using " + polLoadDesc
                        self.tryThis(policy.loadPolicyFiles, message, polLoadDir, True)
                
                        # derive short name by trimming off path & suffix
                        shortname = self.policyFile
                        if shortname.endswith(".paf"):
                            shortname = shortname.rpartition(".paf")[0]
                        if shortname.find("/") >= 0:
                            shortname = shortname.rpartition("/")[2]
                
                        if self.verbose:
                            print "Short name =", shortname
                
                        # 2. create a dictionary from it
                        dictionary = Policy()
                
                        dictionary.set("target", shortname)
                        self.generateDict(policy, dictionary)
                
                        # TODO: remove commas from lists
                        if self.verbose:
                            print "Generating Dictionary for Policy " + self.policyFile + ":"
                            print "---------------------------Policy---------------------------"
                            print policy
                            print "-------------------------Dictionary-------------------------"
                
                        realDict = Dictionary(dictionary)
                        try:
                            realDict.validate(policy)
                            print "#<?cfg paf dictionary ?>"
                            writer = PAFWriter()
                            writer.write(dictionary)
                            print writer.toString()
                            #print dictionary
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
98   <a href="#be0cfb8b">be0cfb8b</a> -         except LsstCppException, e:</div>
              ?                ^   ^           ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
98   <a href="#0050b976">0050b976</a> +         except lsst.pex.exceptions.Exception as e:</div>
              ?                ^   ^ +++++++ ++++++         ^^^
                            ve = e.args[0]
                            print "Internal error: validation fails against extrapolated dictionary:"
                            print ve.describe("  - ")
                
                    def generateDict(self, policy, dictionary, prefix=""):
                        definitions = Policy()
                        dictionary.set("definitions", definitions)
                        names = policy.names(True)
                        for name in names:
                            values = policy.getArray(name)
                            defin = Policy()
                            definitions.set(name, defin)
                            defin.set("type", policy.getTypeName(name))
                            defin.set("minOccurs", 1)
                            defin.set("maxOccurs", len(values))
                            type = policy.getValueType(name)
                
                            if type == Policy.POLICY:
                                newPrefix = prefix + "." + name
                                subdict = Policy()
                                defin.set("dictionary", subdict)
                                if len(values) > 1:
                                    print "# Warning: only using first value of", newPrefix
                                self.generateDict(values[0], subdict, newPrefix)
                            else:
                                allowed = Policy()
                                defin.set("allowed", allowed)
                                orderable = type == Policy.INT or type == Policy.DOUBLE \
                                            or type == Policy.STRING
                                if orderable:
                                    allowed.set("min", min(values))
                                    allowed.set("max", max(values))
                                for value in values:
                                    defin.add("default", value)
                                    allowed.add("value", value)
                
                    def tryThis(self, callableObj, explain, *args, **kwargs):
                        try:
                            if self.verbose: print explain
                            result = callableObj(*args, **kwargs)
                            return result
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
140  <a href="#be0cfb8b">be0cfb8b</a> -         except LsstCppException, e:</div>
              ?                ^   ^           ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
140  <a href="#0050b976">0050b976</a> +         except lsst.pex.exceptions.Exception as e:</div>
              ?                ^   ^ +++++++ ++++++         ^^^
                            print "error", explain + ":"
                            print e.args[0].what()
                            sys.exit(2)
                
                    def parseArgs(self, argv=None):
                        # see http://docs.python.org/library/optparse.html
                        self.parser = optparse.OptionParser(usage=usage, description=desc) # parasoft-suppress W0201
                        self.parser.add_option("-p", "--policy", dest="policy", metavar="FILE",
                                               help="the policy to validate")
                        self.parser.add_option("-l", "--load-policy-references", dest="loadPolicy",
                                               metavar="DIR",
                                               help="Directory from which to load policy file "
                                               "references (if not specified, load from "
                                               "current directory).")
                        self.parser.add_option("-v", "--verbose", dest="verbose",
                                               action="store_const", const=True,
                                               help="Print extra messages.")
                
                        if argv is None:
                            argv = sys.argv
                        (self.options, args) = self.parser.parse_args(argv) # parasoft-suppress W0201
                        # print "args =", args, len(args)
                        # print "options =", self.options
                        if (self.options.verbose != None):
                            self.verbose = self.options.verbose
                        
                        self.policyFile = self.options.policy               # parasoft-suppress W0201
                        del args[0] # script name
                        if (self.policyFile == None):
                            if len(args) < 1:
                                self.parser.error("no policy specified")
                            self.policyFile = args[0]
                            del(args[0])
                
                        if not os.path.exists(self.policyFile):
                            self.parser.error("file not found: " + self.policyFile)
                
                        if len(args) != 0:
                            self.parser.error("too many arguments: " + str(args) + " were not parsed.")
                
                if __name__ == "__main__":
                    pv = PolicyValidator()
                    pv.main()
                    sys.exit(0)
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="be0cfb8b"/></a>be0cfb8b</h3>

<pre>
commit be0cfb8b2500e5a4615f3e1da3c8e42e2de8b00a
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Dec 9 23:04:50 2009 +0000

    fix bug with multiple permitted values; script to prototype dictionaries
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="0050b976"/></a>0050b976</h3>

<pre>
commit 0050b9767b605916c0d6fff20a22dd9476cf0c25
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 15:08:59 2014 -0400

    Adapt to changes in Python Swig wrappers (DM-827)
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_22"><a name="include/lsst/pex/policy/Dictionary.h"/></a>include/lsst/pex/policy/Dictionary.h</h1>

<h3 id="toc_23">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file Dictionary.h
                 * @ingroup pex
                 * @brief definition of the Dictionary class
                 * @author Ray Plante
                 */
                
                #ifndef LSST_PEX_POLICY_DICTIONARY_H
                #define LSST_PEX_POLICY_DICTIONARY_H
                
                #include "lsst/pex/policy/Policy.h"
                #include "lsst/pex/policy/exceptions.h"
                #include <boost/regex.hpp>
                #include <sstream>
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                class PolicySource;
                class PolicyFile;
                
                /**
                 * @brief an exception for holding errors detected while validating a Policy.
                 *
                 * The errors captured by this exception indicate that the value of one or
                 * more Policy parameters do not conform with the definition given in a
                 * Policy Dictionary.  Each error is represented by an enumeration constant
                 * which maps to an error message.  
                 */
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#ffbde6ab">ffbde6ab</a> - class ValidationError : public lsst::pex::exceptions::LogicErrorException {</div>
              ?                                                                 ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#826f6e19">826f6e19</a> + class ValidationError : public lsst::pex::exceptions::LogicError {</div>
                public:
                
                    /**
                     * the possible validation errors that could be encountered.  Theses
                     * are intended to be bit-wise compared with the error value held in
                     * a ValidationError.  
                     */
                    enum ErrorType {
                        /** no error found */
                        OK = 0,
                
                        /** value has the incorrect type */
                        WRONG_TYPE = 1,
                
                        /** a required parameter was not specified */
                        MISSING_REQUIRED = 2,
                
                        /** a scalar was found where an array is required */
                        NOT_AN_ARRAY = 4,
                
                        /** array does not have enough values */
                        ARRAY_TOO_SHORT = 8,
                
                        /** 
                         * parameter contains too few array values.  This bit-wise ORs 
                         * MISSING_REQUIRED, ARRAY_TOO_SHORT, and NOT_AN_ARRAY
                         */
                        TOO_FEW_VALUES = 14, 
                
                        /** parameter contains too many array values */
                        TOO_MANY_VALUES = 16,
                
                        /** 
                         * array has an incorrect number of values.   This bit-wise ORs 
                         * MISSING_REQUIRED, NOT_AN_ARRAY, ARRAY_TOO_SHORT, and 
                         * TOO_MANY_VALUES.
                         */
                        WRONG_OCCURRENCE_COUNT = 30,
                
                        /** the value is not one of the explicit values allowed. */
                        VALUE_DISALLOWED = 32,
                
                        /** 
                         * the value is out of range, either below the minimum or above the 
                         * maximum.
                         */
                        VALUE_OUT_OF_RANGE = 64,
                
                        /**
                         * the value falls outside of the supported domain of values.
                         * This bit-wise ORs VALUE_DISALLOWED and VALUE_OUT_OF_RANGE.
                         */
                        BAD_VALUE = 96,
                
                        /** The value's name is not recognized. */
                        UNKNOWN_NAME = 128,
                
                        /** The value's dictionary definition is malformed. */
                        BAD_DEFINITION = 256,
                
                        /** Policy sub-files have not been loaded -- need to call loadPolicyFiles(). */
                        NOT_LOADED = 512,
                
                        /** an unknown error.  This is the highest error number. */
                        UNKNOWN_ERROR = 1024
                    };
                
                    static const std::string& getErrorMessageFor(ErrorType err) {
                        if (_errmsgs.size() == 0) _loadMessages();
                        MsgLookup::iterator it = _errmsgs.find(err);
                        if (it != _errmsgs.end())
                            return it->second;
                        else {
                            // if it's a compound error that we don't have a pre-written
                            // description of, then compile a description
                        static std::string result; // avoid memory issues
                        // TODO: at cost of concurrence?
                            std::ostringstream os;
                        bool first = true;
                            for (std::map<int,std::string>::const_iterator j = _errmsgs.begin();
                                 j != _errmsgs.end(); ++j) {
                                if (j->first != OK && (err & j->first) == j->first) {
                                    os << (first ? "" : "; ") << j->second;
                            first = false;
                        }
                        }
                        result = os.str();
                            return result;
                    }
                    }
                
                    static const std::string EMPTY;
                
                    // TODO: create way to change message when an error actually occurs
                    /**
                     * create an empty ValidationError message
                     */
                    ValidationError(char const* ex_file, int ex_line, char const* ex_func) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
154  <a href="#ffbde6ab">ffbde6ab</a> -     : lsst::pex::exceptions::LogicErrorException(ex_file, ex_line, ex_func,</div>
              ?                                        ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
154  <a href="#826f6e19">826f6e19</a> +     : lsst::pex::exceptions::LogicError(ex_file, ex_line, ex_func,</div>
                                                 "Policy has unknown validation errors"), 
                       _errors() 
                    { }
                
                    virtual lsst::pex::exceptions::Exception *clone() const;
                    virtual char const *getType(void) const throw();
                
                    /**
                     * Copy constructor.
                     */
                    ValidationError(const ValidationError& that) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
166  <a href="#ffbde6ab">ffbde6ab</a> -     : lsst::pex::exceptions::LogicErrorException(that), _errors(that._errors) </div>
              ?                                        ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
166  <a href="#826f6e19">826f6e19</a> +     : lsst::pex::exceptions::LogicError(that), _errors(that._errors) </div>
                    { }
                
                    ValidationError& operator=(const ValidationError& that) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
170  <a href="#a938e0ae">a938e0ae</a> -     LogicErrorException::operator=(that);</div>
              ?               ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
170  <a href="#826f6e19">826f6e19</a> +     LogicError::operator=(that);</div>
                    _errors = that._errors;
                    return *this;
                    }
                
                // Swig is having trouble with this macro
                //    ValidationError(POL_EARGS_TYPED) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
177  <a href="#ffbde6ab">ffbde6ab</a> - //       : lsst::pex::exceptions::LogicErrorException(POL_EARGS_UNTYPED, </div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
177  <a href="#826f6e19">826f6e19</a> + //       : lsst::pex::exceptions::LogicError(POL_EARGS_UNTYPED, </div>
                //                                                    "policy has unknown validation errors"), 
                //       _errors() 
                //    { }
                
                    /**
                     * destroy the exception
                     */
                    virtual ~ValidationError() throw();
                
                    /**
                     * return the number of named parameters containing validation problems
                     */
                    int getParamCount() const { return _errors.size(); }
                
                    /**
                     * load the names of the parameters that had problems into the given 
                     * list
                     */
                    void paramNames(std::list<std::string>& names) const {
                        ParamLookup::const_iterator it;
                        for(it = _errors.begin(); it != _errors.end(); it++)
                            names.push_back(it->first);
                    }
                
                    /**
                     * The names of the parameters that had problems.
                     * Same functionality as paramNames(), but more SWIGable.
                     */
                    std::vector<std::string> getParamNames() const;
                
                    /**
                     * get the errors encountered for the given parameter name
                     */
                    int getErrors(const std::string& name) const {
                        ParamLookup::const_iterator it = _errors.find(name);
                        if (it != _errors.end()) 
                            return it->second;
                        else
                            return 0;
                    }
                
                    /**
                     * add an error code to this exception
                     */
                    void addError(const std::string& name, ErrorType e) {
                        _errors[name] |= e;
                    }
                
                    /**
                     * get all the errors collectively encountered for all parameters 
                     * examined.  
                     */
                    int getErrors() const {
                        int out = 0;
                        ParamLookup::const_iterator it;
                        for(it = _errors.begin(); it != _errors.end(); it++)
                            out |= it->second;
                        return out;
                    }
                
                    /**
                     * Describe this validation error in human-readable terms.  Each parameter
                     * that has an error is given one line, delimited by a newline character.
                     * @param prefix appended to beginning of each line of output
                     */
                    std::string describe(std::string prefix = "") const;
                
                    /**
                     * Override lsst::pex::exceptions::Exception::what()
                     */
                    virtual char const* what(void) const throw();
                
                protected:
                    typedef std::map<int, std::string> MsgLookup;
                    typedef std::map<std::string, int> ParamLookup;
                
                    static MsgLookup _errmsgs;
                
                    static void _loadMessages();
                
                    ParamLookup _errors;
                };
                
                /**
                 * @brief a convenience container for a single parameter definition from a
                 * dictionary.
                 */
                class Definition : public lsst::daf::base::Citizen {
                public:
                
                    /**
                     * create an empty definition
                     * @param paramName   the name of the parameter being defined.
                     */
                    Definition(const std::string& paramName = "")
                        : lsst::daf::base::Citizen(typeid(*this)), _type(Policy::UNDETERMINED), 
                    _name(paramName), _policy(), _wildcard(false)
                    {
                        _policy.reset(new Policy());
                    }
                
                    /**
                     * create a definition from a data contained in a Policy
                     * @param paramName   the name of the parameter being defined.
                     * @param defn        the policy containing the definition data
                     */
                    Definition(const std::string& paramName, const Policy::Ptr& defn) 
                        : lsst::daf::base::Citizen(typeid(*this)), _type(Policy::UNDETERMINED), 
                          _name(paramName), _policy(defn), _wildcard(false)
                    { }
                
                    /**
                     * create a definition from a data contained in a Policy
                     * @param defn        the policy containing the definition data
                     */
                    Definition(const Policy::Ptr& defn) 
                        : lsst::daf::base::Citizen(typeid(*this)), _type(Policy::UNDETERMINED), 
                          _name(), _policy(defn), _wildcard(false)
                    { }
                
                    /**
                     * create a copy of a definition
                     */
                    Definition(const Definition& that) 
                        : lsst::daf::base::Citizen(typeid(*this)), _type(Policy::UNDETERMINED), 
                          _name(that._name), _policy(that._policy), _wildcard(false)
                    { }
                
                    /**
                     * reset this definition to another one
                     */
                    Definition& operator=(const Definition& that) {
                        _type = Policy::UNDETERMINED;
                        _name = that._name;
                        _policy = that._policy;
                    _prefix = that._prefix;
                    _wildcard = that._wildcard;
                        return *this;
                    }
                
                    /**
                     * reset this definition's data to another one.  The name of the parameter
                     * will remain the same.
                     */
                    Definition& operator=(const Policy::Ptr& defdata) { 
                        setData(defdata);
                        return *this;
                    }
                
                    virtual ~Definition();
                
                    /**
                     * return the name of the parameter
                     */
                    const std::string& getName() const { return _name; }
                
                    //@{
                    /**
                     * The prefix to this definition's parameter name -- relevant to validation
                     * of sub-policies.
                     */
                    const std::string getPrefix() const { return _prefix; }
                    void setPrefix(const std::string& prefix) { _prefix = prefix; }
                    //@}
                
                    //@{
                    /**
                     * Was this definition created from a wildcard "childDefinition" definition
                     * in a Dictionary?  Default false.
                     */
                    const bool isChildDefinition() const { return _wildcard; }
                    void setChildDefinition(bool wildcard) { _wildcard = wildcard; }
                    const bool isWildcard() const { return _wildcard; }
                    void setWildcard(bool wildcard) { _wildcard = wildcard; }
                    //@}
                
                    /**
                     * set the name of the parameter.  Note that this will not effect the 
                     * name in Dictionary that this Definition came from.  
                     */
                    void setName(const std::string& newname) { _name = newname; }
                
                    /**
                     * return the definition data as a Policy pointer
                     */
                    const Policy::Ptr& getData() const { return _policy; }
                
                    /**
                     * return the definition data as a Policy pointer
                     */
                    void setData(const Policy::Ptr& defdata) { 
                        _type = Policy::UNDETERMINED;
                        _policy = defdata; 
                    }
                
                    /**
                     * return the type identifier for the parameter
                     */
                    Policy::ValueType getType() const {
                        if (_type == Policy::UNDETERMINED) _type = _determineType();
                        return _type;
                    }
                
                    /**
                     * The human-readable name of this definition's type
                     * ("string", "double", etc.).
                     */
                    std::string getTypeName() const {
                    return Policy::typeName[getType()];
                    }
                
                    /**
                     * return the default value as a string
                     */
                    std::string getDefault() const {
                        return _policy->str("default");
                    }
                
                    /**
                     * Return the semantic definition for the parameter, empty string if none is
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
398  <a href="#a938e0ae">a938e0ae</a> -      * specified, or throw a TypeError if it is the wrong type.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
398  <a href="#826f6e19">826f6e19</a> +      * specified, or throw a pexPolicy::TypeError if it is the wrong type.</div>
              ?                              +++++++++++
                     */
                    const std::string getDescription() const;
                
                    /**
                     * return the maximum number of occurrences allowed for this parameter, 
                     * or -1 if there is no limit.
                     */
                    const int getMaxOccurs() const;
                
                    /**
                     * return the minimum number of occurrences allowed for this parameter.
                     * Zero is returned if a minimum is not specified.
                     */
                    const int getMinOccurs() const;
                
                    /**
                     * Insert the default value into the given policy
                     * @param policy  the policy object update
                     * @param errs  a validation error to add complaints to, if there are any.
                     * @exception ValidationError if the value does not conform to this definition.
                     */
                    void setDefaultIn(Policy& policy, ValidationError* errs=0) const {
                        setDefaultIn(policy, _name, errs);
                    }
                
                    /**
                     * @copydoc setDefaultIn(Policy&) const
                     * @param withName  the name to look for the value under.  If not given
                     *                    the name set in this definition will be used.
                     */
                    void setDefaultIn(Policy& policy, const std::string& withName,
                              ValidationError* errs=0) const;
                
                    /**
                     * @copydoc setDefaultIn(Policy&) const
                     */
                    template <typename T> void setDefaultIn(Policy& policy,
                                        const std::string& withName,
                                        ValidationError* errs=0) const;
                
                    /**
                     * confirm that a Policy parameter conforms to this definition.  
                     *   If a ValidationError instance is provided, any errors detected will be
                     *   loaded into it.  If no ValidationError is provided, then any errors
                     *   detected will cause a ValidationError exception to be thrown.
                     * @param policy   the policy object to inspect
                     * @param name     the name to look for the value under.  If not given
                     *                 the name set in this definition will be used.
                     * @param errs     a pointer to a ValidationError instance to load errors 
                     *                 into. 
                     * @exception ValidationError   if errs is not provided and the value 
                     *                 does not conform.  
                     */
                    void validate(const Policy& policy, const std::string& name, 
                                  ValidationError *errs=0) const;
                
                    /**
                     * confirm that a Policy parameter conforms to this definition.  
                     *   If a ValidationError instance is provided, any errors detected 
                     *   will be loaded into it.  If no ValidationError is provided,
                     *   then any errors detected will cause a ValidationError exception
                     *   to be thrown.  
                     * @param policy   the policy object to inspect
                     * @param errs     a pointer to a ValidationError instance to load errors 
                     *                  into. 
                     * @exception ValidationError   if errs is not provided and the value 
                     *                  does not conform.  
                     */
                    void validate(const Policy& policy, ValidationError *errs=0) const {
                        validate(policy, _name, errs);
                    }
                
                    //@{
                    /**
                     * confirm that a Policy parameter name-value combination is consistent 
                     * with this dictionary.  This does not check the minimum occurrence 
                     * requirement; however, it will check if adding this will exceed the 
                     * maximum, assuming that there are currently curcount values.  This 
                     * method is intended for use by the Policy object to do on-the-fly
                     * validation.
                     *
                     * If a ValidationError instance is provided, any errors detected 
                     * will be loaded into it.  If no ValidationError is provided,
                     * then any errors detected will cause a ValidationError exception
                     * to be thrown.  
                     *
                     * @param name      the name of the parameter being checked
                     * @param value     the value of the parameter to check.
                     * @param curcount  the number of values assumed to already stored under
                     *                  the given name.  If < 0, limit checking is not done.
                     * @param errs      a pointer to a ValidationError instance to load errors 
                     *                  into. 
                     * @exception ValidationError   if the value does not conform.  The message
                     *                 should explain why.
                     */
                
                    void validate(const std::string& name, bool value, int curcount=-1, 
                                  ValidationError *errs=0) const;
                    void validate(const std::string& name, int value, int curcount=-1, 
                                  ValidationError *errs=0) const;
                    void validate(const std::string& name, double value, int curcount=-1, 
                                  ValidationError *errs=0) const;
                    void validate(const std::string& name, std::string value, int curcount=-1, 
                                  ValidationError *errs=0) const;
                    void validate(const std::string& name, const Policy& value, int curcount=-1, 
                                  ValidationError *errs=0) const;
                    //@}
                
                    //@{
                    /**
                     * confirm that a Policy parameter name-array value combination is 
                     * consistent with this dictionary.  Unlike the scalar version, 
                     * this does check occurrence compliance.  
                     *
                     * If a ValidationError instance is provided, any errors detected 
                     * will be loaded into it.  If no ValidationError is provided,
                     * then any errors detected will cause a ValidationError exception
                     * to be thrown.  
                     *
                     * @param name     the name of the parameter being checked
                     * @param value    the value of the parameter to check.
                     * @param errs     a pointer to a ValidationError instance to load errors 
                     *                  into. 
                     * @exception ValidationError   if the value does not conform.  The message
                     *                 should explain why.
                     */
                    void validate(const std::string& name, const Policy::BoolArray& value, 
                                  ValidationError *errs=0) const;
                    void validate(const std::string& name, const Policy::IntArray& value, 
                                  ValidationError *errs=0) const;
                    void validate(const std::string& name, const Policy::DoubleArray& value, 
                                  ValidationError *errs=0) const;
                    void validate(const std::string& name, 
                                  const Policy::StringArray& value, 
                                  ValidationError *errs=0) const;
                    void validate(const std::string& name, 
                                  const Policy::ConstPolicyPtrArray& value, 
                                  ValidationError *errs=0) const;
                    //@}
                
                    /**
                     * confirm that a Policy parameter name-array value combination is 
                     * consistent with this dictionary.  Unlike the scalar version, 
                     * this does check occurrence compliance.  
                     *
                     * If a ValidationError instance is provided, any errors detected 
                     * will be loaded into it.  If no ValidationError is provided,
                     * then any errors detected will cause a ValidationError exception
                     * to be thrown.
                     *
                     * Only does basic validation (min, max, minOccurs, maxOccurs, allowed
                     * values); doesn't recursively check sub-dictionaries.
                     *
                     * @param name     the name of the parameter being checked
                     * @param policy   the policy whose named parameter is being checked
                     * @param errs     the ValidationError instance to load errors into
                     * @exception ValidationError   if the value does not conform.  The message
                     *                 should explain why.
                     */
                    template <typename T> void validateBasic
                    (const std::string& name, const Policy& policy,
                     ValidationError *errs=0) const;
                
                    //@{
                    /**
                     * Confirm that a policy value is consistent with this dictionary; does
                     * basic checks (min, max, minOccurs, maxOccurs, allowed values), but does
                     * not recurse if \code value \endcode is itself a Policy with a
                     * sub-dictionary.
                     *
                     * Equivalent to <tt>validate(name, value, errs)</tt> for basic types, but
                     * not for Policies.
                     */
                    template <typename T> void validateBasic
                    (const std::string& name, const T& value, int curcount=-1,
                     ValidationError *errs=0) const;
                    template <typename T> void validateBasic
                    (const std::string& name, const std::vector<T>& value,
                     ValidationError *errs=0) const;
                    //@}
                
                    //@{
                    /**
                     * Recursively validate \code value \endcode, using a sub-definition, if
                     * present in this Dictionary.
                     * @param name  the name of the parameter being checked
                     * @param value the value being checked against name's definition
                     * @param errs  used to store errors that are found (not allowed to be null)
                     */
                    void validateRecurse(const std::string& name, Policy::ConstPolicyPtrArray value,
                             ValidationError *errs) const;
                
                    void validateRecurse(const std::string& name, const Policy& value,
                             ValidationError *errs) const;
                    //@}
                
                    /**
                     * Check this definition's internal integrity.  Does not recursively check
                     * sub-dictionaries.
                     */
                    void check() const;
                
                protected:
                    Policy::ValueType _determineType() const;
                
                    /**
                     * Validate the number of values for a field. Used internally by the
                     * validate() functions. 
                     * @param name   the name of the parameter being checked
                     * @param count  the number of values this name actually has
                     * @param errs   report validation errors here (must exist)
                     */
                    void validateCount(const std::string& name, int count,
                               ValidationError *errs) const;
                
                    static const std::string EMPTY;
                
                private:
                    mutable Policy::ValueType _type;
                    std::string _prefix; // for recursive validation, eg "foo.bar."
                    std::string _name;
                    Policy::Ptr _policy;
                    bool _wildcard;
                };
                
                inline std::ostream& operator<<(std::ostream& os, const Definition& d) {
                    d.getData()->print(os, d.getName());
                    return os;
                }
                
                /**
                 * @brief   a class representing the allowed or expected contents of a Policy
                 *
                 * This class keeps in memory a definition of a Policy "schema".  In other
                 * words, it provides definitions of each name that is expected or allowed 
                 * in a conforming Policy not only in terms of its semantic meaning but also
                 * its value type, default and allowed values, and how often it must or can 
                 * occur.  
                 *  
                 * A Dictionary is envisioned to play two important roles.  First, its 
                 * serialized form can provide the documentation for the Policy parameters 
                 * that a Policy-supporting class will be looking for.  Second, it can be 
                 * used to validate that an instance of a Policy is conformant with the 
                 * expectations of such a class.  
                 *
                 * A Dictionary is a specialization of the Policy class itself.  This means
                 * that not only can a Dictionary be handled as any other Policy, but also
                 * any Policy format can be used to author a Dictionary.  
                 *
                 * A Dictionary policy, however, is assumed to follow a specific schema.  
                 * The expected parameter names at the top level are:
                 * \verbatim
                 * Name          Required?    Type    Defintion
                 * ------------- -----------  ------  --------------------------------------
                 * target        recommended  string  The name of an object or system that 
                 *                                      this dictionary is intended for
                 * definitions   required     Policy  The definitions of each term, where 
                 *                                      each parameter name is a Policy
                 *                                      parameter being defined.
                 * \endverbatim
                 * 
                 * Each of the parameters contained under definitions represents a term 
                 * being defined and is of type Policy.  Each definition is expected to 
                 * follow the following schema:
                 * \verbatim
                 * Name          Required?    Type    Defintion
                 * ------------- -----------  ------  --------------------------------------
                 * type          recommended  string  the type of the value expected, one of
                 *                                      "int", "bool", "double", "string", and
                 *                                      "Policy".  If not provided, any type
                 *                                      ("undefined") should be assumed.  If 
                 *                                      The type is Policy, a dictionary for 
                 *                                      its terms can be provided via 
                 *                                      "dictionary"/"dictionaryFile".
                 *                                      Note that "PolicyFile" is not allowed;
                 *                                      "Policy" should be used in its place,
                 *                                      and policy.loadPolicyFiles() should
                 *                                      be called before validating a policy.
                 * description   recommended  string  The semantic meaning of the term or 
                 *                                      explanation of how it will be used.
                 * minOccurs     optional     int     The minimun number of values expected.
                 *                                      0 means that the parameter is optional,
                 *                                      > 0 means that it is required,
                 *                                      > 1 means that a vector is required.
                 *                                      If not specified or < 0, 0 should be 
                 *                                      assumed.
                 * maxOccurs     optional     int     The maximun number of values expected.
                 *                                      0 means that the parameter is forbidden
                 *                                      to occur, 1 means that the value must
                 *                                      be a scalar, and > 1 means that an
                 *                                      array value is allowed.  If 
                 *                                      not specified or < 0, any number of 
                 *                                      of values is allowed; the user should
                 *                                      assume a vector value.  
                 * default       optional     *       A value that will be assumed if none is 
                 *                                      provided.  
                 * dictionaryFile  optional   string  A file path to the definition of the 
                 *                                      sub-policy parameters.  This is ignored
                 *                                      unless "type" equals "Policy".
                 * dictionary    optional     Policy  the dictionary policy object that defines
                 *                                      sub-policy parameters using this above,
                 *                                      top-level schema.  
                 * allowed       optional     Policy  A description of the allowed values.  
                 * allowed.value   optional   *       One allowed value.  This should not be an
                 *                                      an array of values.
                 * allowed.description  opt.  *       a description of what this value 
                 *                                      indicates.
                 * allowed.min   optional     *       The minimum allowed value, used for 
                 *                                      int and double typed parameters.
                 * allowed.max   optional     *       The maximum allowed value, used for 
                 *                                      int and double typed parameters.
                 * childDefinition optional   Policy    A general definition for wildcard policy
                 *                                      elements whose names may or may not be
                 *                                      known ahead of time; all such elements
                 *                                      must be of uniform type
                 * -------------------------------------------------------------------------
                 * *the type must be that specified by the type parameter. 
                 * \endverbatim
                 *
                 */
                class Dictionary : public Policy {
                public:
                
                    // keywords
                    static const char *KW_DICT;
                    static const char *KW_DICT_FILE;
                    static const char *KW_TYPE;
                    static const char *KW_DESCRIPTION;
                    static const char *KW_DEFAULT;
                    static const char *KW_DEFINITIONS;
                    static const char *KW_CHILD_DEF;
                    static const char *KW_ALLOWED;
                    static const char *KW_MIN_OCCUR;
                    static const char *KW_MAX_OCCUR;
                    static const char *KW_MIN;
                    static const char *KW_MAX;
                    static const char *KW_VALUE;
                
                    /**
                     * return an empty dictionary.  This can be passed to a parser to be 
                     * filled.
                     */
                    Dictionary() : Policy() { }
                
                    /**
                     * Check that the given Policy follows the Dictionary schema and return a
                     * dictionary that is a copy of the given Policy.  If the policy has a
                     * top-level Policy parameter called "dictionary", its contents will be
                     * copied into this dictionary.
                     */
                    Dictionary(const Policy& pol) 
                        : Policy( (pol.isPolicy("dictionary")) ? *(pol.getPolicy("dictionary"))
                                                               : pol )
                    {
                    check();
                    }
                
                    /**
                     * return a dictionary that is a copy of another dictionary
                     */
                    Dictionary(const Dictionary& dict) : Policy(dict) {
                    check();
                    }
                
                    //@{
                    /**
                     * load a dictionary from a file
                     */
                    explicit Dictionary(const char *filePath);
                    explicit Dictionary(const std::string& filePath);
                    explicit Dictionary(const PolicyFile& filePath);
                    //@}
                
                    //@{
                    /**
                     * return the parameter name definitions as a Policy object
                     */
                    Policy::ConstPtr getDefinitions() const {
                        return getPolicy("definitions");
                    }
                    Policy::Ptr getDefinitions() {
                        return getPolicy("definitions");
                    }
                    //@}
                
                    /**
                     * Check this Dictionary's internal integrity.  Load up all definitions and
                     * sanity-check them.
                     */
                    void check() const;
                
                    /**
                     * load the top-level parameter names defined in this Dictionary into 
                     * a given list.  
                     */
                    int definedNames(std::list<std::string>& names, bool append=false) const {
                        return getDefinitions()->names(names, true, append); 
                    }
                
                    /**
                     * return the top-level parameter names defined in this Dictionary
                     */
                    StringArray definedNames() const {
                        return getDefinitions()->names(true); 
                    }
                
                    /**
                     * return a definition for the named parameter
                     * @param name    the hierarchical name for the parameter
                     */
                    Definition getDef(const std::string& name) {
                        Definition *def = makeDef(name);
                        Definition out(*def);
                        delete def;
                        return out;
                    }
                
                    /**
                     * return a definition for the named parameter.  The caller is responsible
                     * for deleting the returned object.  This is slightly more efficient than
                     * getDef().
                     * @param name    the hierarchical name for the parameter
                     * @exception     NameNotFoundError if no definition by this name exists
                     *                DictionaryError if this dictionary is found to be malformed
                     */
                    Definition* makeDef(const std::string& name) const;
                
                    /**
                     * Does this dictionary have a branch named \code name \endcode that is also
                     * a dictionary?
                     * @see getSubDictionary
                     */
                    bool hasSubDictionary(const std::string& name) const {
                    std::string key = std::string("definitions.") + name + "." + KW_DICT;
                    // could also check isPolicy(key), but we would rather have
                    // getSubDictionary(name) fail with a DictionaryError if the
                    // sub-dictionary is the wrong type
                    return exists(key);
                    }
                
                    //@{
                    /**
                     * Return a branch of this dictionary, if this dictionary describes a
                     * complex policy structure -- that is, if it describes a policy with
                     * sub-policies.
                     */
                    DictPtr getSubDictionary(const std::string& name) const;
                    // DictPtr getSubDictionary(const std::string& name) const;
                    //@}
                
                    /**
                     * Validate a Policy against this Dictionary.  All relevant file references
                     * in the dictionary, including "dictionaryFile" references, must be
                     * resolved first, or else a DictionaryError will be thrown.
                     *
                     * If a ValidationError instance is provided, any errors detected 
                     * will be loaded into it.  If no ValidationError is provided,
                     * then any errors detected will cause a ValidationError exception
                     * to be thrown.  
                     *
                     * @param pol    the policy to validate
                     * @param errs   a pointer to a ValidationError instance to load errors 
                     *                 into. 
                     * @exception ValidationError   if the value does not conform.  The message
                     *                 should explain why.
                     */
                    void validate(const Policy& pol, ValidationError *errs=0) const;
                
                    // C++ inheritance & function overloading limitations require us to
                    // re-declare this here, even though an identical function is declared in
                    // Policy
                    /**
                     * Recursively replace all PolicyFile values with the contents of the 
                     * files they refer to.  The type of a parameter containing a PolicyFile
                     * will consequently change to a Policy upon successful completion.  If
                     * the value is an array, all PolicyFiles in the array must load without
                     * error before the PolicyFile values themselves are erased.
                     * @param strict      If true, throw an exception if an error occurs 
                     *                    while reading and/or parsing the file (probably an
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
878  <a href="#a938e0ae">a938e0ae</a> -      *                    IoErrorException or ParseError).  Otherwise, replace</div>
              ?                                  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
878  <a href="#826f6e19">826f6e19</a> +      *                    IoError or ParseError).  Otherwise, replace</div>
                     *                    the file reference with a partial or empty sub-policy
                     *                    (that is, "{}").
                     * @return            the number of files loaded
                     */
                    int loadPolicyFiles(bool strict=true) {
                    return loadPolicyFiles(boost::filesystem::path(), strict);
                    }
                
                    /**
                     * \copydoc loadPolicyFiles()
                     * @param repository  a directory to look in for the referenced files.  
                     *                    Only when the name of the file to be included is an
                     *                    absolute path will this.  If empty or not provided,
                     *                    the directorywill be assumed to be the current one.
                     * @return            the number of files loaded
                     */
                    virtual int loadPolicyFiles(const boost::filesystem::path& repository,
                                                bool strict=true);
                
                    //@{
                    /**
                     * The prefix to this Dictionary's parameter names, for user messages during
                     * validation of sub-policies.
                     */
                    const std::string getPrefix() const { return _prefix; }
                    void setPrefix(const std::string& prefix) { _prefix = prefix; }
                    //@}
                
                
                protected:
                    static const boost::regex FIELDSEP_RE;
                
                private:
                    std::string _prefix; // for recursive validation, eg "foo.bar."
                };
                
                template <typename T>
                void Definition::validateBasic(const std::string& name, const Policy& policy,
                                   ValidationError *errs) const
                {
                    validateBasic(name, policy.getValueArray<T>(name), errs);
                }
                
                template <typename T>
                void Definition::validateBasic(const std::string& name, const std::vector<T>& value,
                                   ValidationError *errs) const
                {
                    ValidationError ve(LSST_EXCEPT_HERE);
                    ValidationError *use = &ve;
                    if (errs != 0) use = errs;
                
                    validateCount(name, value.size(), use);
                
                    for (typename std::vector<T>::const_iterator i = value.begin();
                     i != value.end();
                     ++i)
                    validateBasic<T>(name, *i, -1, use);
                
                    if (errs == 0 && ve.getParamCount() > 0) throw ve;
                }
                
                template <typename T>
                void Definition::setDefaultIn(Policy& policy, const std::string& withName,
                                  ValidationError *errs) const 
                {
                    ValidationError ve(LSST_EXCEPT_HERE);
                    ValidationError *use = (errs == 0 ? &ve : errs);
                
                    if (_policy->exists("default")) {
                    const std::vector<T> defs = _policy->getValueArray<T>("default");
                    validateBasic(withName, defs, use);
                    if (use->getErrors(withName) == ValidationError::OK) {
                        policy.remove(withName);
                        for (typename std::vector<T>::const_iterator i = defs.begin();
                         i != defs.end();
                         ++i)
                        policy.addValue<T>(withName, *i);
                    }
                    }
                
                    if (errs == 0 && ve.getParamCount() > 0) throw ve;
                }
                
                }}}  // end namespace lsst::pex::policy
                
                #endif // LSST_PEX_POLICY_POLICY_H
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="ffbde6ab"/></a>ffbde6ab</h3>

<pre>
commit ffbde6abe48212de8420148bd05e9ef2b5e96ffe
Author: smm <smm@git.lsstcorp.org>
Date:   Mon Nov 7 21:41:56 2011 +0000

    pex_policy Winter2012b: remove namespace aliases in headers, upgrade to swig 2.x
</pre>
<h3><a name="a938e0ae"/></a>a938e0ae</h3>

<pre>
commit a938e0ae6e04eb065113480c098a5e9f681a0bb9
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Nov 18 20:48:24 2009 +0000

    Merged revisions 10237-10239,10263,10278-10279,10318-10320,10332,10334-10336,10359,10383,10390,10439,10445-10446,10449,10469-10471,10485,10499-10501,10570,10572-10574,10581-10584,10617,10619-10623,10627,10674-10677,10691,10890,10918,10985-10986,11436-11438,11482,11489-11490 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/872
    
    ........
      r10237 | bbaker | 2009-07-24 13:40:06 -0500 (Fri, 24 Jul 2009) | 1 line
    
      add rough childDefinition definition
    ........
      r10238 | bbaker | 2009-07-24 13:40:33 -0500 (Fri, 24 Jul 2009) | 1 line
    
      rough list of validation tests, from examining the spec in Dictionary.h
    ........
      r10239 | bbaker | 2009-07-24 13:41:18 -0500 (Fri, 24 Jul 2009) | 1 line
    
      comment
    ........
      r10263 | bbaker | 2009-07-27 09:44:48 -0500 (Mon, 27 Jul 2009) | 1 line
    
      add details to list of tests
    ........
      r10278 | bbaker | 2009-07-29 15:00:10 -0500 (Wed, 29 Jul 2009) | 1 line
    
      typos
    ........
      r10279 | bbaker | 2009-07-29 15:00:41 -0500 (Wed, 29 Jul 2009) | 1 line
    
      add some missing fields
    ........
      r10318 | bbaker | 2009-07-31 18:16:01 -0500 (Fri, 31 Jul 2009) | 1 line
    
      primitive examples for development
    ........
      r10319 | bbaker | 2009-07-31 18:16:29 -0500 (Fri, 31 Jul 2009) | 1 line
    
      debugging validation
    ........
      r10320 | bbaker | 2009-07-31 18:17:06 -0500 (Fri, 31 Jul 2009) | 1 line
    
      placeholder
    ........
      r10332 | bbaker | 2009-08-04 11:03:53 -0500 (Tue, 04 Aug 2009) | 1 line
    
      correct typos; tweak constants
    ........
      r10334 | bbaker | 2009-08-04 11:40:31 -0500 (Tue, 04 Aug 2009) | 1 line
    
      fix unit test -- mixed types
    ........
      r10335 | bbaker | 2009-08-04 11:54:01 -0500 (Tue, 04 Aug 2009) | 1 line
    
      dictionary unit test stub
    ........
      r10336 | bbaker | 2009-08-04 13:00:11 -0500 (Tue, 04 Aug 2009) | 1 line
    
      move unit test files into tests; add simple validate
    ........
      r10359 | bbaker | 2009-08-05 17:33:18 -0500 (Wed, 05 Aug 2009) | 1 line
    
      rigorize dictionary type handling
    ........
      r10383 | bbaker | 2009-08-07 13:32:20 -0500 (Fri, 07 Aug 2009) | 1 line
    
      cleaning up values validation
    ........
      r10390 | bbaker | 2009-08-07 17:55:15 -0500 (Fri, 07 Aug 2009) | 1 line
    
      templates templates templates
    ........
      r10439 | bbaker | 2009-08-12 17:26:49 -0500 (Wed, 12 Aug 2009) | 1 line
    
      improve error messages, and other testing
    ........
      r10445 | bbaker | 2009-08-13 14:23:31 -0500 (Thu, 13 Aug 2009) | 1 line
    
      getTypeByName -- whew
    ........
      r10446 | bbaker | 2009-08-13 15:16:55 -0500 (Thu, 13 Aug 2009) | 1 line
    
      more dictionary integrity tests
    ........
      r10449 | bbaker | 2009-08-13 16:37:22 -0500 (Thu, 13 Aug 2009) | 1 line
    
      confirm that policy validation is only partial
    ........
      r10469 | bbaker | 2009-08-14 15:56:35 -0500 (Fri, 14 Aug 2009) | 1 line
    
      value validation
    ........
      r10470 | bbaker | 2009-08-14 15:57:51 -0500 (Fri, 14 Aug 2009) | 1 line
    
      remove finished TODO
    ........
      r10471 | bbaker | 2009-08-14 16:15:24 -0500 (Fri, 14 Aug 2009) | 1 line
    
      detect missing required items
    ........
      r10485 | bbaker | 2009-08-17 17:39:50 -0500 (Mon, 17 Aug 2009) | 1 line
    
      nested validation
    ........
      r10499 | bbaker | 2009-08-18 15:34:33 -0500 (Tue, 18 Aug 2009) | 1 line
    
      childDefinition implementation and tests
    ........
      r10500 | bbaker | 2009-08-18 16:19:48 -0500 (Tue, 18 Aug 2009) | 1 line
    
      comments
    ........
      r10501 | bbaker | 2009-08-18 16:22:02 -0500 (Tue, 18 Aug 2009) | 1 line
    
      TODOs
    ........
      r10570 | bbaker | 2009-09-01 18:06:33 -0500 (Tue, 01 Sep 2009) | 1 line
    
      more validation when loading from defaults
    ........
      r10572 | bbaker | 2009-09-01 21:58:01 -0500 (Tue, 01 Sep 2009) | 1 line
    
      quick emacs cmd
    ........
      r10573 | bbaker | 2009-09-01 22:22:45 -0500 (Tue, 01 Sep 2009) | 1 line
    
      obsolete
    ........
      r10574 | bbaker | 2009-09-01 22:23:08 -0500 (Tue, 01 Sep 2009) | 1 line
    
      validate on set/add -- step 1
    ........
      r10581 | bbaker | 2009-09-03 16:17:42 -0500 (Thu, 03 Sep 2009) | 1 line
    
      accessors for policy.dictionary, test policy self-validation
    ........
      r10582 | bbaker | 2009-09-03 16:22:51 -0500 (Thu, 03 Sep 2009) | 1 line
    
      more set/add tests
    ........
      r10583 | bbaker | 2009-09-03 16:23:40 -0500 (Thu, 03 Sep 2009) | 1 line
    
      comment
    ........
      r10584 | bbaker | 2009-09-03 16:25:31 -0500 (Thu, 03 Sep 2009) | 1 line
    
      oops, test failed
    ........
      r10617 | bbaker | 2009-09-11 15:27:09 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fixes related to nested dictionaries and policies
    ........
      r10619 | bbaker | 2009-09-11 16:09:40 -0500 (Fri, 11 Sep 2009) | 1 line
    
      remove debugging printouts, convert to constants instead of literal strings
    ........
      r10620 | bbaker | 2009-09-11 16:16:57 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fix spelling of EventTranmitter
    ........
      r10621 | bbaker | 2009-09-11 16:22:59 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test condensed dictionary syntax, update docs and TODOs
    ........
      r10622 | bbaker | 2009-09-11 16:24:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test without 'target' field in dictionary
    ........
      r10623 | bbaker | 2009-09-11 16:27:34 -0500 (Fri, 11 Sep 2009) | 1 line
    
      resolve TODO comments
    ........
      r10627 | bbaker | 2009-09-11 17:15:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      deep dictionary loading
    ........
      r10674 | bbaker | 2009-09-18 15:02:18 -0500 (Fri, 18 Sep 2009) | 1 line
    
      use boost::make_shared where possible
    ........
      r10675 | bbaker | 2009-09-18 15:07:03 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10676 | bbaker | 2009-09-18 15:07:42 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10677 | bbaker | 2009-09-18 17:39:14 -0500 (Fri, 18 Sep 2009) | 1 line
    
      working on validation script
    ........
      r10691 | bbaker | 2009-09-21 18:18:48 -0500 (Mon, 21 Sep 2009) | 1 line
    
      validation script for dictionary & policy authors
    ........
      r10890 | bbaker | 2009-10-06 12:22:53 -0500 (Tue, 06 Oct 2009) | 1 line
    
      uses of Policy C++ and Python interfaces
    ........
      r10918 | bbaker | 2009-10-07 13:09:45 -0500 (Wed, 07 Oct 2009) | 1 line
    
      hide certain swig warnings
    ........
      r10985 | bbaker | 2009-10-12 15:44:45 -0500 (Mon, 12 Oct 2009) | 1 line
    
      improve formatting
    ........
      r10986 | bbaker | 2009-10-12 15:46:30 -0500 (Mon, 12 Oct 2009) | 1 line
    
      list of policy files
    ........
      r11436 | bbaker | 2009-11-10 14:02:15 -0600 (Tue, 10 Nov 2009) | 1 line
    
      move validate.py test script into tests dir
    ........
      r11437 | bbaker | 2009-11-10 14:02:40 -0600 (Tue, 10 Nov 2009) | 1 line
    
      reference to --help
    ........
      r11438 | bbaker | 2009-11-10 14:03:28 -0600 (Tue, 10 Nov 2009) | 1 line
    
      pex_policy: add options to mergeDefaults to validate and to keep dictionary
    ........
      r11482 | bbaker | 2009-11-17 15:40:53 -0600 (Tue, 17 Nov 2009) | 1 line
    
      more mergeDefaults -- deep Policy merge
    ........
      r11489 | bbaker | 2009-11-18 12:43:19 -0600 (Wed, 18 Nov 2009) | 1 line
    
      improve standards compliance
    ........
      r11490 | bbaker | 2009-11-18 12:50:15 -0600 (Wed, 18 Nov 2009) | 1 line
    
      more standards compliance
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_24"><a name="tests/DefaultPolicyFile_1.cc"/></a>tests/DefaultPolicyFile_1.cc</h1>

<h3 id="toc_25">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file Policy_1.cc
                 *
                 * This test tests the basic access and update methods of the Policy class.
                 */
                #include <iostream>
                #include <sstream>
                #include <string>
                #include <stdexcept>
                #include "lsst/pex/policy/DefaultPolicyFile.h"
                #include "boost/filesystem.hpp"
                
                using namespace std;
                using lsst::pex::policy::Policy;
                using lsst::pex::policy::DefaultPolicyFile;
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
38   <a href="#dcd1814e">dcd1814e</a> - using lsst::pex::policy::TypeError;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
39   <a href="#dcd1814e">dcd1814e</a> - using lsst::pex::policy::NameNotFound;</div>
                
                namespace fs = boost::filesystem;
                
                #define Assert(b, m) tattle(b, m, __LINE__)
                
                void tattle(bool mustBeTrue, const string& failureMsg, int line) {
                    if (! mustBeTrue) {
                        ostringstream msg;
                        msg << __FILE__ << ':' << line << ":\n" << failureMsg << ends;
                        throw runtime_error(msg.str());
                    }
                }
                
                int main() {
                
                    fs::path ipath = DefaultPolicyFile::installPathFor("pex_policy");
                    cout << "Policy installation directory: " << ipath << endl;
                    Assert(fs::exists(ipath), "Policy installation directory does not exist");
                
                    DefaultPolicyFile df("pex_policy", "EventTransmitter_policy.paf", 
                                         "examples", true);
                    ipath = df.getInstallPath("pex_policy");
                    Assert(fs::exists(ipath), "DefaultPolicyFile failed to find product dir: "+
                                              ipath.string());
                
                    ipath = df.getPath();
                    Assert(fs::exists(ipath), "DefaultPolicyFile failed to find file path: " +
                                              ipath.string());
                
                    Policy p(df);
                    Assert(p.exists("standalone"), "Failed to load default data");
                
                    // test failures
                    try {
                        ipath = DefaultPolicyFile::installPathFor("pex_goober");
                        Assert(false, "Ignored undefined product name (pex_goober)");
                    }
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
77   <a href="#5d362dce">5d362dce</a> -     catch (lsst::pex::exceptions::NotFoundException ex) {</div>
              ?                                            ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
75   <a href="#826f6e19">826f6e19</a> +     catch (lsst::pex::exceptions::NotFoundError ex) {</div>
              ?                                            ^^ ^
                        cout << "Detected missing product" << endl;
                    }
                
                    df = DefaultPolicyFile("pex_policy", "EventTransmitter_policy.paf", 
                                           "goober", true);
                    ipath = df.getPath();
                    Assert(! fs::exists(ipath), "Failed to detect missing file: "+
                                                ipath.string());
                }
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="dcd1814e"/></a>dcd1814e</h3>

<pre>
commit dcd1814ef4726014e169971f2141ca2b35de70dc
Author: rplante <rplante@git.lsstcorp.org>
Date:   Fri Feb 27 23:24:12 2009 +0000

    Primarily updated for use of PropertySet
    Cleaned up use of "using"
    bug fix: add workaround to swig bug to support bool types
    improve exception handling
    improve test scripts (explicitly test all types)
</pre>
<h3><a name="5d362dce"/></a>5d362dce</h3>

<pre>
commit 5d362dced87411c64694564ff10b8b7dadefb438
Author: rplante <rplante@git.lsstcorp.org>
Date:   Wed Mar 18 11:12:08 2009 +0000

    Improved support for default policy data:
      o  Policy: added mergeDefaults()
      o  bug fix: properly load subPolicy defaults
      o  make DefaultPolicyFile available from python
    TODO:  dereference dictionary files
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_26"><a name="python/lsst/pex/policy/policyLib.i"/></a>python/lsst/pex/policy/policyLib.i</h1>

<h3 id="toc_27">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                %define policy_DOCSTRING
                "
                Access to the policy classes from the pex module
                "
                %enddef
                
                %feature("autodoc", "1");
                %module(package="lsst.pex.policy", docstring=policy_DOCSTRING) policyLib
                
                // Supress warnings
                #pragma SWIG nowarn=314     // print is a python keyword (--> _print)
                #pragma SWIG nowarn=509     // overloaded method is shadowed
                
                %{
                #include "lsst/daf/base.h"
                #include "lsst/pex/policy/exceptions.h"
                #include "lsst/pex/policy/parserexceptions.h"
                #include "lsst/pex/policy/Policy.h"
                #include "lsst/pex/policy/Dictionary.h"
                #include "lsst/pex/policy/PolicyFile.h"
                #include "lsst/pex/policy/DefaultPolicyFile.h"
                #include "lsst/pex/policy/UrnPolicyFile.h"
                #include "lsst/pex/policy/PolicyString.h"
                #include "lsst/pex/policy/PolicyStreamDestination.h"
                #include "lsst/pex/policy/PolicyStringDestination.h"
                #include "lsst/pex/policy/paf/PAFWriter.h"
                
                using lsst::pex::policy::SupportedFormats;
                using lsst::pex::policy::PolicyParserFactory;
                %}
                
                %include "lsst/p_lsstSwig.i"
                
                %lsst_exceptions()
                
                %import "lsst/pex/exceptions/exceptionsLib.i"    // for Exceptions
                %import "lsst/daf/base/baseLib.i"
                
                %shared_ptr(lsst::pex::policy::Policy);
                %shared_ptr(lsst::pex::policy::Dictionary);
                %shared_ptr(lsst::pex::policy::Definition);
                %shared_ptr(lsst::pex::policy::PolicySource);
                %shared_ptr(lsst::pex::policy::PolicyFile);
                %shared_ptr(lsst::pex::policy::DefaultPolicyFile);
                %shared_ptr(lsst::pex::policy::UrnPolicyFile);
                %shared_ptr(lsst::pex::policy::PolicyString);
                %shared_ptr(lsst::pex::policy::PolicyDestination);
                %shared_ptr(lsst::pex::policy::PolicyStreamDestination);
                %shared_ptr(lsst::pex::policy::PolicyStringDestination);
                
                %newobject lsst::pex::policy::Policy::createPolicy;
                %newobject lsst::pex::policy::Policy::createPolicyFromUrn;
                %newobject lsst::pex::policy::Dictionary::makeDef;
                
                %feature("notabstract") lsst::pex::policy::paf::PAFWriter;
                
                %ignore lsst::pex::policy::Policy::Policy(const Policy& pol);
                %ignore lsst::pex::policy::PolicySource::defaultFormats;
                %ignore lsst::pex::policy::PolicyFile::SPACE_RE;
                %ignore lsst::pex::policy::PolicyFile::COMMENT;
                %ignore lsst::pex::policy::PolicyFile::CONTENTID;
                %ignore lsst::pex::policy::PolicyString::SPACE_RE;
                %ignore lsst::pex::policy::PolicyString::COMMENT;
                %ignore lsst::pex::policy::PolicyString::CONTENTID;
                %ignore lsst::pex::policy::ValidationError::operator=;
                
                %immutable lsst::pex::policy::Dictionary::KW_DICT;
                %immutable lsst::pex::policy::Dictionary::KW_DICT_FILE;
                %immutable lsst::pex::policy::Dictionary::KW_TYPE;
                %immutable lsst::pex::policy::Dictionary::KW_DESCRIPTION;
                %immutable lsst::pex::policy::Dictionary::KW_DEFAULT;
                %immutable lsst::pex::policy::Dictionary::KW_DEFINITIONS;
                %immutable lsst::pex::policy::Dictionary::KW_CHILD_DEF;
                %immutable lsst::pex::policy::Dictionary::KW_ALLOWED;
                %immutable lsst::pex::policy::Dictionary::KW_MIN_OCCUR;
                %immutable lsst::pex::policy::Dictionary::KW_MAX_OCCUR;
                %immutable lsst::pex::policy::Dictionary::KW_MIN;
                %immutable lsst::pex::policy::Dictionary::KW_MAX;
                %immutable lsst::pex::policy::Dictionary::KW_VALUE;
                
                
                %inline %{
                namespace boost { namespace filesystem { } }
                %}
                
                %typemap(out) std::vector<double,std::allocator<double > > {
                    int len = ($1).size();
                    $result = PyList_New(len);
                    for (int i = 0; i < len; i++) {
                        PyList_SetItem($result,i,PyFloat_FromDouble(($1)[i]));
                    }
                }
                
                %typemap(out) std::vector<int,std::allocator<int > > {
                    int len = ($1).size();
                    $result = PyList_New(len);
                    for (int i = 0; i < len; i++) {
                        PyList_SetItem($result,i,PyInt_FromLong(($1)[i]));
                    }
                }
                
                %typemap(out) std::vector<std::string > {
                    int len = ($1).size();
                    $result = PyList_New(len);
                    for (int i = 0; i < len; i++) {
                        PyList_SetItem($result,i,PyString_FromString(($1)[i].c_str()));
                    }
                }
                
                %typemap(out) std::vector<bool,std::allocator<bool > > {
                    int len = ($1).size();
                    $result = PyList_New(len);
                    for (int i = 0; i < len; i++) {
                       if (($1)[i]) {
                           Py_INCREF(Py_True);
                           PyList_SetItem($result, i, Py_True);
                       } else {
                           Py_INCREF(Py_False);
                           PyList_SetItem($result, i, Py_False);
                       }
                    }
                }
                
                %typemap(out) std::vector<boost::shared_ptr<lsst::pex::policy::Policy > > {
                    int len = ($1).size();
                    $result = PyList_New(len);
                    for (int i = 0; i < len; i++) {
                        boost::shared_ptr<lsst::pex::policy::Policy> * smartresult =
                            new boost::shared_ptr<lsst::pex::policy::Policy>(($1)[i]);
                        PyObject * obj = SWIG_NewPointerObj(SWIG_as_voidptr(smartresult),
                            SWIGTYPE_p_boost__shared_ptrT_lsst__pex__policy__Policy_t,
                            SWIG_POINTER_OWN);
                        PyList_SetItem($result, i, obj);
                    }
                }
                
                %typemap(out) std::vector<boost::shared_ptr<lsst::pex::policy::PolicyFile > > {
                    int len = (*(&$1)).size();
                    $result = PyList_New(len);
                    for (int i = 0; i < len; i++) {
                        boost::shared_ptr<lsst::pex::policy::PolicyFile> * smartresult =
                            new boost::shared_ptr<lsst::pex::policy::PolicyFile>((*(&$1))[i]);
                        PyObject * obj = SWIG_NewPointerObj(SWIG_as_voidptr(smartresult),
                            SWIGTYPE_p_boost__shared_ptrT_lsst__pex__policy__PolicyFile_t,
                            SWIG_POINTER_OWN);
                        PyList_SetItem($result, i, obj);
                    }
                }
                
                %typemap(in,numinputs=0) std::list<std::string > &names (std::list<std::string > temp) {
                    $1 = &temp;
                }
                
                %typemap(argout) std::list<std::string > &names {
                    int len = (*$1).size();
                    $result = PyList_New(len);
                    std::list<std::string >::iterator sp;
                    int i = 0;
                    for (sp = (*$1).begin(); sp != (*$1).end(); sp++, i++) {
                        PyList_SetItem($result,i,PyString_FromString(sp->c_str()));
                    }
                }
                
                // Tell SWIG that boost::filesystem::path is equivalent to a string for typechecking purposes
                %typemap(typecheck) const boost::filesystem::path & = char *;
                
                %typemap(out) const boost::filesystem::path& {
                   $result = PyString_FromString($1->string().c_str());
                } 
                
                // Convert Python strings to boost::filesystem::path objects
                %typemap(in) const boost::filesystem::path & {
                    std::string * temp;
                    int cnvRes = SWIG_AsPtr_std_string($input, &temp);
                    if (!SWIG_IsOK(cnvRes)) {
                        SWIG_exception_fail(SWIG_ArgError(cnvRes), "failed to convert Python input to C++ string");
                    }
                    if (!temp) {
                        SWIG_exception_fail(SWIG_ValueError, "invalid null reference in input");
                    }
                    $1 = new boost::filesystem::path(*temp);
                    delete temp;
                }
                
                // Make sure temporary created above is freed inside wrapper code
                %typemap(freearg) const boost::filesystem::path & {
                    delete $1;
                }
                
                
                %template(NameList) std::list<std::string >;
                
                
                %include "lsst/pex/policy/Policy.h"
                %include "lsst/pex/policy/Dictionary.h"
                %include "lsst/pex/policy/PolicyWriter.h"
                %include "lsst/pex/policy/PolicySource.h"
                %include "lsst/pex/policy/PolicyFile.h"
                %include "lsst/pex/policy/DefaultPolicyFile.h"
                %include "lsst/pex/policy/UrnPolicyFile.h"
                %include "lsst/pex/policy/paf/PAFWriter.h"
                %include "lsst/pex/policy/exceptions.h"
                %include "lsst/pex/policy/parserexceptions.h"
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
229  <a href="#0050b976">0050b976</a> + %declareException(BadNameError, lsst.pex.exceptions.RuntimeError, lsst::pex::policy::BadNameError)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
230  <a href="#0050b976">0050b976</a> + %declareException(DictionaryError, lsst.pex.exceptions.DomainError, lsst::pex::policy::DictionaryError)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
231  <a href="#0050b976">0050b976</a> + %declareException(NameNotFound, lsst.pex.exceptions.NotFoundError, lsst::pex::policy::NameNotFound)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
232  <a href="#0050b976">0050b976</a> + %declareException(TypeError, lsst.pex.exceptions.DomainError, lsst::pex::policy::TypeError)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
233  <a href="#0050b976">0050b976</a> + %declareException(ParserError, lsst.pex.exceptions.RuntimeError, lsst::pex::policy::ParserError)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
234  <a href="#0050b976">0050b976</a> + %declareException(EOFError, ParserError, lsst::pex::policy::EOFError)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
235  <a href="#0050b976">0050b976</a> + %declareException(SyntaxError, ParserError, lsst::pex::policy::SyntaxError)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
236  <a href="#0050b976">0050b976</a> + %declareException(FormatSyntaxError, SyntaxError, lsst::pex::policy::FormatSyntaxError)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
237  <a href="#0050b976">0050b976</a> + %declareException(UnsupportedSyntax, SyntaxError, lsst::pex::policy::UnsupportedSyntax)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
238  <a href="#0050b976">0050b976</a> + %declareException(ValidationError, lsst.pex.exceptions.LogicError, lsst::pex::policy::ValidationError)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
239  <a href="#0050b976">0050b976</a> + </div>
                %template(vector_Policy_Ptr) std::vector<boost::shared_ptr<lsst::pex::policy::Policy> >;
                
                %extend lsst::pex::policy::Policy {
                    void _setBool(const std::string& name, bool value) {
                       self->set(name, value);
                    }
                
                    void _addBool(const std::string& name, bool value) {
                       self->add(name, value);
                    }
                }
                
                %pythoncode %{
                Policy.__str__ = Policy.toString
                
                def _Policy_get(p, name):
                    type = p.getValueType(name);
                    if (type == p.UNDEF):
                        return p.getInt(name) # will raise an exception
                        # raise NameNotFound("Policy parameter name not found: " + name)
                
                    if (type == p.INT):
                        return p.getInt(name)
                    elif (type == p.DOUBLE):
                        return p.getDouble(name)
                    elif (type == p.BOOL):
                        return p.getBool(name)
                    elif (type == p.STRING):
                        return p.getString(name)
                    elif (type == p.POLICY):
                        return p.getPolicy(name)
                    elif (type == p.FILE):
                        return p.getFile(name)
                
                def _Policy_getArray(p, name):
                    type = p.getValueType(name);
                    if (type == p.UNDEF):
                        return p.getIntArray(name) # will raise an exception
                        # raise NameNotFound("Policy parameter name not found: " + name)
                
                    if (type == p.INT):
                        return p.getIntArray(name)
                    elif (type == p.DOUBLE):
                        return p.getDoubleArray(name)
                    elif (type == p.BOOL):
                        return p.getBoolArray(name)
                    elif (type == p.STRING):
                        return p.getStringArray(name)
                    elif (type == p.POLICY):
                        return p.getPolicyArray(name)
                    elif (type == p.FILE):
                        return p.getFileArray(name)
                
                Policy.get = _Policy_get
                Policy.getArray = _Policy_getArray
                
                _Policy_wrap_set = Policy.set
                def _Policy_set(p, name, value):
                    if isinstance(value, bool):
                        p._setBool(name, value)
                    elif (value == None):
                        raise RuntimeError("Attempt to set value of \"" + name + "\" to None.  Values must be non-None.  Use remove() instead.")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
291  <a href="#91663765">91663765</a> - #        raise lsst.pex.exceptions.InvalidParameterException("Value of " + name + " cannot be None.")</div>
              ?                                                     ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
302  <a href="#826f6e19">826f6e19</a> + #        raise lsst.pex.exceptions.InvalidParameterError("Value of " + name + " cannot be None.")</div>
              ?                                                     ^^ ^
                    else:
                        _Policy_wrap_set(p, name, value)
                Policy.set = _Policy_set
                
                _Policy_wrap_add = Policy.add
                def _Policy_add(p, name, value):
                    if isinstance(value, bool):
                        p._addBool(name, value)
                    else:
                        _Policy_wrap_add(p, name, value)
                Policy.add = _Policy_add
                %}
                
                %include "lsst/pex/policy/PolicySource.h"
                %include "lsst/pex/policy/PolicyFile.h"
                %include "lsst/pex/policy/DefaultPolicyFile.h"
                %include "lsst/pex/policy/UrnPolicyFile.h"
                %include "lsst/pex/policy/PolicyString.h"
                %include "lsst/pex/policy/PolicyDestination.h"
                %include "lsst/pex/policy/PolicyStreamDestination.h"
                %include "lsst/pex/policy/PolicyStringDestination.h"
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="91663765"/></a>91663765</h3>

<pre>
commit 916637653dca141b6deda4653980ed228e7c2696
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Dec 2 23:29:08 2009 +0000

    Ticket #1050 - handle values of Nothing (throw a clear exception)
    
    Merged revisions 11673,11688 via svnmerge from
    svn+ssh://bbaker@svn.lsstcorp.org/DMS/pex/policy/tickets/1050
    
    ........
      r11673 | bbaker | 2009-12-02 15:05:35 -0600 (Wed, 02 Dec 2009) | 1 line
    
      ticket #1050 - assertion failure when set a value to None
    ........
      r11688 | bbaker | 2009-12-02 17:12:42 -0600 (Wed, 02 Dec 2009) | 1 line
    
      disallow value of Nothing in Policy
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
<h3><a name="0050b976"/></a>0050b976</h3>

<pre>
commit 0050b9767b605916c0d6fff20a22dd9476cf0c25
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 15:08:59 2014 -0400

    Adapt to changes in Python Swig wrappers (DM-827)
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_28"><a name="include/lsst/pex/policy/Policy.h"/></a>include/lsst/pex/policy/Policy.h</h1>

<h3 id="toc_29">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                #ifndef LSST_PEX_POLICY_POLICY_H
                #define LSST_PEX_POLICY_POLICY_H
                
                #include <string>
                #include <vector>
                #include <list>
                #include <map>
                
                #include <boost/shared_ptr.hpp>
                #include <boost/filesystem/path.hpp>
                #include <boost/filesystem/operations.hpp>
                
                #include "lsst/daf/base/Citizen.h"
                #include "lsst/daf/base/Persistable.h"
                #include "lsst/daf/base/PropertySet.h"
                #include "lsst/pex/policy/exceptions.h"
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                // forward declaration
                class PolicySource;
                class PolicyFile;
                class Dictionary;
                class ValidationError;
                
                #define POL_GETSCALAR(name, type, vtype) \
                    try { \
                        return _data->get<type>(name); \
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#ffbde6ab">ffbde6ab</a> -     } catch (lsst::pex::exceptions::NotFoundException&) {   \</div>
              ?                                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#826f6e19">826f6e19</a> +     } catch (lsst::pex::exceptions::NotFoundError&) {   \</div>
              ?                                              ^^ ^
                        throw LSST_EXCEPT(NameNotFound, name);  \
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
57   <a href="#ffbde6ab">ffbde6ab</a> -     } catch (lsst::daf::base::TypeMismatchException&) { \</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
57   <a href="#826f6e19">826f6e19</a> +     } catch (lsst::pex::exceptions::TypeError&) { \</div>
                        throw LSST_EXCEPT(TypeError, name, std::string(typeName[vtype])); \
                    } catch (boost::bad_any_cast&) { \
                        throw LSST_EXCEPT(TypeError, name, std::string(typeName[vtype])); \
                    }
                
                #define POL_GETLIST(name, type, vtype) \
                    try { \
                        return _data->getArray<type>(name); \
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
66   <a href="#ffbde6ab">ffbde6ab</a> -     } catch (lsst::pex::exceptions::NotFoundException&) {   \</div>
              ?                                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
66   <a href="#826f6e19">826f6e19</a> +     } catch (lsst::pex::exceptions::NotFoundError&) {   \</div>
              ?                                              ^^ ^
                        throw LSST_EXCEPT(NameNotFound, name);  \
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
68   <a href="#ffbde6ab">ffbde6ab</a> -     } catch (lsst::daf::base::TypeMismatchException&) { \</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
68   <a href="#826f6e19">826f6e19</a> +     } catch (lsst::pex::exceptions::TypeError&) { \</div>
                        throw LSST_EXCEPT(TypeError, name, std::string(typeName[vtype])); \
                    } catch (boost::bad_any_cast&) { \
                        throw LSST_EXCEPT(TypeError, name, std::string(typeName[vtype])); \
                    } 
                
                
                /**
                 * @brief  a container for holding hierarchical configuration data in memory.
                 *
                 * A policy is a set of named parameters that can be used to configure
                 * the internal data and behavior of an object within an application.  An
                 * important feature Policy objects is that the parameters can be
                 * loaded in from a file.  Thus, it allows applications fine-grained
                 * control of objects even if much of the configuration parameters they
                 * provide are normally set to defaults and otherwise do not change.
                 *
                 * The Policy interface allows an application to pull out parameter values 
                 * by name.  Typically, the application "knows" the names it needs from a 
                 * Policy to configure itself--that is, these names and the use of their 
                 * values are hard-coded into the application.  The application simply calls 
                 * one of the get methods to retrieve a typed value for the parameter.  
                 * (Nevertheless, if necessary, the parameter names contained in a policy 
                 * can be retrieved via the \c names() member function.)
                 * 
                 * Policy parameters values are restricted to a limited set of types to ensure 
                 * simple, well-defined ASCII text serialization format.  These types are 
                 * In particular, a Policy parameter can be one of:
                 *  - integer (int not long)
                 *  - double
                 *  - string
                 *  - boolean (bool)
                 *  - Policy
                 *  - PolicyFile, a reference to file containing additional Policy data
                 *  - arrays of any of the above
                 *
                 * As implied by the inclusion of Policy as a value type, a Policy can be 
                 * hierarchical (like a PropertySet).  Values deep within the hierarchy 
                 * can be retrieved via a hiearchical name.  Such a name is made up of 
                 * name fields delimited by dots (.) where each name field represents a 
                 * level of the hierarchy.  The first field represents the top level of 
                 * the hierarchy.  If a given name does not resolve to value, a NameNotFound
                 * exception is thrown.  If one expects a different value type for a name 
                 * than what is actually stored, (e.g. one calls \c getInt(name) for a 
                 * parameter that is actually a string), a TypeError exception is thrown.
                 * 
                 * A hierarchical Policy allows an application to configure a whole 
                 * hierarchy of objects, even if the object classes (and their 
                 * associated policy parameters) were developed by different people.  In
                 * particular, if an application that is configuring one of the objects it 
                 * uses, it can either pull out the relevent values directly by their 
                 * hierarchical names, or if that object supports configuration from a 
                 * Policy, it can pull all of the values for the object by retrieving a 
                 * Policy (via \c getPolicy(name) ) and passing it to the object.  
                 * 
                 * It is important to note that parameter names relative the Policy that 
                 * contains them.  For example, suppose you have a parameter accessible via 
                 * the name "foo.bar.zub".  This implies that the name "foo.bar" will 
                 * resolve to a Policy object.  You can retrieve the "zub" parameter from 
                 * that "sub-Policy" object by asking for "zub".  
                 * 
                 * \section secPolicyLoading Loading a Policy File
                 *
                 * One can read Policy data via the constructors that take a file name in 
                 * some form as an input argument; however the prefered manner is via one
                 * of the createPolicy() functions.  The latter is able to intelligently 
                 * differentiate between simple Policy file and a Dictionary file.  In 
                 * either case, the formats supported would be restricted by default to 
                 * those currently built into this package.  Support for other formats 
                 * can be plugged in using the PolicyFile and SupportFormats classes.  
                 *
                 * For more information about about Policy files, file formats, and 
                 * dictionaries, see the \ref pexPolicyMain "package overview" as well as the 
                 * PolicyFile and Dictionary class descriptions.
                 *
                 * \section secPolicyDefaults Default Policy Data
                 *
                 * When an object using a Policy fails to find a parameter it was expecting,
                 * it is a little inelegant to provide a default hard-coded in the object's
                 * implementation, <em>by design</em>.  Instead it is recommended that 
                 * defaults be loaded from another Policy.  The intended way to do this is 
                 * to load defaults via a DefaultPolicyFile (which can locate a policy file
                 * from any EUPS-setup installation directory) and to merge them into to the
                 * primary Policy instance via the mergeDefaults() function.  
                 * 
                 * \section secPolicyVer Version Notes
                 *
                 * With version 3.1, support for the JSON format was dropped.  
                 * 
                 * After version 3.2, Policy's internal implementation was changed to be 
                 * a wrapper around PropertySet.  Prior to this, it used its own internal 
                 * data map.  The API (which had been optimized for the old implementation), 
                 * remained largely unchanged for the purposes of backward compatibility.  
                 * The changes include (1) dropping support for providing default values to 
                 * the get*() functions, (2) returning array values by value rather than 
                 * reference, and (3) added functions for greater consistancy with 
                 * PropertySet.
                 *
                 * After 3.3.3, loading default data (including from Dictionarys) was 
                 * improved.  This included adding mergeDefaults()
                 */
                class Policy : public lsst::daf::base::Citizen, public lsst::daf::base::Persistable {
                public:
                
                    typedef boost::shared_ptr<Policy> Ptr;
                    typedef boost::shared_ptr<const Policy> ConstPtr;
                    typedef boost::shared_ptr<Dictionary> DictPtr;
                    typedef boost::shared_ptr<const Dictionary> ConstDictPtr;
                    typedef boost::shared_ptr<PolicyFile> FilePtr;
                
                    typedef std::vector<bool> BoolArray;
                    typedef std::vector<int> IntArray;
                    typedef std::vector<double> DoubleArray;
                    typedef std::vector<std::string> StringArray;
                    typedef std::vector<Ptr> PolicyPtrArray;
                    typedef std::vector<FilePtr> FilePtrArray;
                    typedef std::vector<ConstPtr> ConstPolicyPtrArray;
                
                    /**
                     * an enumeration for the supported policy types
                     */
                    enum ValueType {
                        UNDETERMINED = -1,
                        UNDEF,
                        BOOL,
                        INT,
                        DOUBLE,
                        STRING,
                        POLICY,
                        FILE
                    };
                
                    /**
                     * c-string forms for the supported value types.  The ValueType 
                     * enum values can be used a indexes into the array to return the 
                     * name of the corresping type.  
                     */
                    static const char * const typeName[];
                
                    /**
                     * Create an empty policy
                     */
                    Policy();
                
                    //@{
                    /**
                     * Create a Policy from a named file or URN of the form
                     * "urn:eupspkg:<package>[:<repos>]:<path>".  For more details on the format
                     * of the URN, see UrnPolicyFile.
                     * @param pathOrUrn can be a local file name, file path, or URN.
                     */
                    explicit Policy(const std::string& pathOrUrn);
                    explicit Policy(const char *pathOrUrn);
                    //@}
                
                    /**
                     * Create a Policy from a PolicySource (usually, a PolicyFile)
                     * @param source
                     */
                    explicit Policy(const PolicySource& source);
                
                    /**
                     * Create a default Policy from a Dictionary.  If the Dictionary references
                     * files containing dictionaries for sub-Policies, an attempt is made to
                     * open them and extract the default data, and if that attempt fails, an
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
233  <a href="#a938e0ae">a938e0ae</a> -      * exception is thrown (probably an IoErrorException or ParseError).</div>
              ?                                                ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
233  <a href="#826f6e19">826f6e19</a> +      * exception is thrown (probably an IoError or ParseError).</div>
                     *
                     * @param validate    if true, a shallow copy of the Dictionary will be
                     *                    held onto by this Policy and used to validate future
                     *                    updates.
                     * @param dict        the Dictionary to load defaults from
                     * @param repository  the directory to look for dictionary files referenced
                     *                    in \c dict.  The default is the current directory.
                     */
                    Policy(bool validate, const Dictionary& dict,
                           const boost::filesystem::path& repository="");
                
                    /**
                     * copy a Policy.  
                     * @param pol   the policy to copy
                     * @param deep  if true, do a deep copy.  Otherwise, Policy data will
                     *                 be shared.
                     */
                    Policy(Policy& pol, bool deep=false);
                
                    /**
                     * deep-copy a Policy.  
                     */
                    Policy(const Policy& pol);
                
                    //@{
                    /**
                     * create a Policy from a file.  The caller is responsible for deleting
                     * the returned value.  This is the preferred way to obtain a Policy file 
                     * if you don't care to know if the input file is an actual policy 
                     * file or a policy dictionary.  If it turns out to be a dictionary 
                     * file, the defined defaults will be loaded into the return policy.
                     * @param input       the input file or stream to load data from.
                     * @param doIncludes  if true, any references found to external Policy 
                     *                    files will be resolved into sub-policy values.  
                     *                    The files will be looked for in a directory 
                     *                    relative the current directory.
                     * @param validate    if true and the input file is a policy dictionary,
                     *                    it will be given to the returned policy and 
                     *                    used to validate future updates to the Policy.
                     */
                    static Policy *createPolicy(PolicySource& input, bool doIncludes=true, 
                                                bool validate=true);
                    static Policy *createPolicy(const std::string& input, bool doIncludes=true,
                                                bool validate=true);
                    //@}
                
                    /**
                     * Create a Policy from a file specified by a URN.  The caller is
                     * responsible for deleting the returned value.  This is the preferred way
                     * to obtain a Policy file if you don't care to know if the input file is an
                     * actual policy file or a policy dictionary.  If it turns out to be a
                     * dictionary file, the defined defaults will be loaded into the return
                     * policy.
                     * @param urn         A URN of the form
                     *                    "urn:eupspkg:\<package\>[:\<repository\>]:\<path\> to
                     *                    load data from, as described in UrnPolicyFile.
                     * @param validate    if true and the input file is a policy dictionary,
                     *                    it will be given to the returned policy and 
                     *                    used to validate future updates to the Policy.
                     */
                    static Policy *createPolicyFromUrn(const std::string& urn,
                                       bool validate=true);
                
                    //@{
                    /**
                     * create a Policy from a file.  The caller is responsible for deleting
                     * the returned value.  This is the preferred way to obtain a Policy file 
                     * if you don't care to know if the input file is an actual policy 
                     * file or a policy dictionary.  If it turns out to be a dictionary 
                     * file, the defined defaults will be loaded into the return policy.  
                     * @param input       the input file or stream to load data from.
                     * @param repos       a directory to look in for the referenced files.  
                     *                    Only when the name of the file to be included is an
                     *                    absolute path will this.  
                     * @param validate    if true and the input file is a policy dictionary,
                     *                    it will be given to the returned policy and 
                     *                    used to validate future updates to the Policy.
                     */
                    static Policy *createPolicy(PolicySource& input,
                                                const boost::filesystem::path& repos, 
                                                bool validate=true);
                    static Policy *createPolicy(PolicySource& input, const std::string& repos, 
                                                bool validate=true);
                    static Policy *createPolicy(PolicySource& input, const char *repos, 
                                                bool validate=true);
                    static Policy *createPolicy(const std::string& input, 
                                                const boost::filesystem::path& repos,
                                                bool validate=true);
                    static Policy *createPolicy(const std::string& input, 
                                                const std::string& repos, bool validate=true);
                    static Policy *createPolicy(const std::string& input, const char *repos, 
                                                bool validate=true);
                    //@}
                
                    /**
                     * Create a PolicyFile or UrnPolicyFile from `pathOrUrn`.
                     * @param pathOrUrn if this looks like a Policy URN, create a UrnPolicyFile;
                     *                  otherwise, create a plain PolicyFile.
                     * @param strict if false, "@" will be accepted as a substitute for
                     *               "urn:eupspkg:"; if true, urn:eupspkg must be present in a
                     *               URN.
                     */
                    static FilePtr createPolicyFile(const std::string& pathOrUrn, bool strict=false);
                
                    /**
                     * A template-ized way to get the ValueType. General case is disallowed, but
                     * specific types are implemented: bool, int, double, string, Policy,
                     * FilePtr (aka shared_ptr<PolicyFile>), Ptr (aka shared_ptr<Policy>),
                     * ConstPtr (aka shared_ptr<const Policy>).
                     */
                    template <typename T> static ValueType getValueType();
                
                    /** 
                     * Given the human-readable name of a type ("bool", "int", "policy", etc),
                     * what is its ValueType (BOOL, STRING, etc.)?  Throws BadNameError if
                     * unknown.
                     */
                    static ValueType getTypeByName(const std::string& name);
                    // throw(BadNameError) // swig doesn't like this
                
                    /**
                     * destroy this policy
                     */
                    virtual ~Policy();
                
                    /**
                     * How many names of parameters does this policy file have?
                     */
                    int nameCount() const {
                        return _data->nameCount();
                    }
                
                    //@{
                    /**
                     * load the names of parameters into a given list.  \c names() returns
                     * all names, \c paramNames() only returns the names that resolve to
                     * non-Policy and non-PolicyFile type parameters, \c policyNames() 
                     * only returns the Policy names, and fileNames() only returns PolicyFile
                     * names.  These versions are provided for backward compatibility but are
                     * deprecated; use the versions that return vector values.  
                     * 
                     * @param names         the list object to be loaded
                     * @param topLevelOnly  if true, only parameter names at the top of the 
                     *                         hierarchy will be returned; no hierarchical 
                     *                         names will be included.
                     * @param append        if false, the contents of the given list will 
                     *                         be erased before loading the names.  
                     * @return int  the number of names added
                     */
                    int names(std::list<std::string>& names, 
                              bool topLevelOnly=false, 
                              bool append=false) const;                      // inlined below
                    int paramNames(std::list<std::string>& names, 
                                   bool topLevelOnly=false, 
                                   bool append=false) const;                 // inlined below
                    int policyNames(std::list<std::string>& names, 
                                    bool topLevelOnly=false, 
                                    bool append=false) const;                // inlined below
                    int fileNames(std::list<std::string>& names, 
                                  bool topLevelOnly=false, 
                                  bool append=false) const;                  // inlined below
                    //@}
                
                    //@{
                    /**
                     * return the names of parameters.  \c names() returns
                     * all names, \c paramNames() only returns the names that resolve to
                     * non-Policy and non-PolicyFile type parameters, \c policyNames() 
                     * only returns the Policy names, and fileNames() only returns PolicyFile
                     * names.  
                     * 
                     * @param topLevelOnly  if true, only parameter names at the top of the 
                     *                         hierarchy will be returned; no hierarchical 
                     *                         names will be included.
                     */
                    StringArray names(bool topLevelOnly=false) const;        // inlined below
                    StringArray paramNames(bool topLevelOnly=false) const;   // inlined below
                    StringArray policyNames(bool topLevelOnly=false) const;  // inlined below
                    StringArray fileNames(bool topLevelOnly=false) const;    // inlined below
                    //@}
                
                    /**
                     * return true if it appears that this Policy actually contains dictionary
                     * definition data.
                     */
                    bool isDictionary() const { return exists("definitions");  }
                
                    /**
                     * Can this policy validate itself -- that is, does it have a dictionary
                     * that it can use to validate itself?  If true, then set() and add()
                     * operations will be checked against it.
                     */
                    bool canValidate() const;
                
                    /**
                     * The dictionary (if any) that this policy uses to validate itself,
                     * including checking set() and add() operations for validity.
                     */
                    const ConstDictPtr getDictionary() const;
                
                    /**
                     * Update this policy's dictionary that it uses to validate itself.  Note
                     * that this will *not* trigger validation -- you will need to call \code
                     * validate() \endcode afterwards.
                     */
                    void setDictionary(const Dictionary& dict);
                
                    /**
                     * Validate this policy, using its stored dictionary.  If \code
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
443  <a href="#a938e0ae">a938e0ae</a> -      * canValidate() \endcode is false, this will throw a LogicErrorException.</div>
              ?                                                                     ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
443  <a href="#826f6e19">826f6e19</a> +      * canValidate() \endcode is false, this will throw a LogicError.</div>
                     *
                     * If validation errors are found and \code err \endcode is null, a
                     * ValidationError will be thrown.
                     *
                     * @param errs if non-null, any validation errors will be stored here
                     * instead of being thrown.
                     */
                    void validate(ValidationError *errs=0) const;
                
                    /**
                     * return the number of values currently associated with a given name
                     * @param name   the (possibly) hierarchical name of the property of 
                     *                  interest.
                     */
                    size_t valueCount(const std::string& name) const;        // inlined below
                
                    /**
                     * return true if multiple values can be retrieved via the given name.
                     * False is returned if the name does not exist.  This is equivalent to
                     * (valueCount(name) > 1).
                     * @param name   the (possibly) hierarchical name of the property of 
                     *                  interest.
                     */
                    bool isArray(const std::string& name) const;             // inlined below
                
                    /**
                     * return true if a value exists in this policy for the given name. 
                     * This is semantically equivalent to (valuecount(name) > 0) (though
                     * its implementation is slightly more efficient).
                     * @param name   the (possibly) hierarchical name of the property of 
                     *                  interest.
                     */
                    bool exists(const std::string& name) const;              // inlined below
                
                    /**
                     * return true if the value pointed to by the given name is a boolean
                     */
                    bool isBool(const std::string& name) const;               // inlined below
                
                    /**
                     * return true if the value pointed to by the given name is an integer
                     */
                    bool isInt(const std::string& name) const;               // inlined below
                
                    /**
                     * return true if the value pointed to by the given name is a double
                     */
                    bool isDouble(const std::string& name) const;            // inlined below
                
                    /**
                     * return true if the value pointed to by the given name is a string
                     */
                    bool isString(const std::string& name) const;            // inlined below
                
                    /**
                     * return true if the value pointed to by the given name is a Policy
                     */
                    bool isPolicy(const std::string& name) const;            // inlined below
                
                    /**
                     * return true if the value pointed to by the given name is a PolicyFile
                     */
                    bool isFile(const std::string& name) const;              // inlined below
                
                    /**
                     * return the type information for the underlying type associated with
                     * a given name.  This is equivalent to typeOf() and is provided for
                     * backward compatibility.
                     */
                    const std::type_info& getTypeInfo(const std::string& name) const; //inlined
                
                    /**
                     * return the type information for the underlying type associated with
                     * a given name.  This is equivalent to getTypeInfo() and is provided 
                     * for consistency with PropertySet.
                     */
                    const std::type_info& typeOf(const std::string& name) const;     // inlined
                
                    /**
                     * return the ValueType enum identifier for the underlying type associated 
                     * with a given name.  If a parameter with that name has not been set, 
                     * Policy::UNDEF is returned.  
                     */
                    ValueType getValueType(const std::string& name) const;
                
                    /**
                     * return a string name for the type associated with the parameter of
                     * a given name.  If a parameter with that name has not been set, the 
                     * returned string will be "undefined".  
                     */
                    const char *getTypeName(const std::string& name) const {
                        try { return typeName[getValueType(name)]; }
                        catch (NameNotFound&) { return typeName[UNDEF]; }
                    }
                
                    /**
                     * Template-ized version of getInt, getPolicy, etc.  General case is
                     * disallowed, but specific types are implemented: bool, int, double,
                     * string, FilePtr (aka shared_ptr<PolicyFile>), ConstPtr (aka
                     * shared_ptr<const Policy>).
                     */
                    template <typename T> T getValue(const std::string& name) const;
                
                    /**
                     * Template-ized version of getIntArray, getPolicyPtrArray, etc.  General
                     * case is disallowed, but specific types are implemented: bool, int,
                     * double, string, FilePtr (aka shared_ptr<PolicyFile>, returns
                     * FilePtrArray), Ptr (aka shared_ptr<Policy>, returns PolicyPtrArray).
                     */
                    template <typename T> std::vector<T> getValueArray(const std::string& name) const;
                
                    //@{
                    /**
                     * return a "sub-Policy" identified by a given name.  
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                             a Policy type.  
                     */
                    ConstPtr getPolicy(const std::string& name) const;       // inlined below
                    Ptr getPolicy(const std::string& name);                  // inlined below
                    //@}
                
                    /**
                     * return a PolicyFile (a reference to a file with "sub-Policy" data) 
                     * identified by a given name.  
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                             a Policy type.  
                     */
                    FilePtr getFile(const std::string& name) const;
                
                    /**
                     * return a boolean value associated with the given name.  If the 
                     * underlying value is an array, only the last value added will be 
                     * returned.  
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                             a boolean type.  
                     */
                    bool getBool(const std::string& name) const { 
                        POL_GETSCALAR(name, bool, BOOL) 
                    }
                
                    /**
                     * return an integer value associated with the given name.  If the 
                     * underlying value is an array, only the last value added will be 
                     * returned.  
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                             an integer type.  
                     */
                    int getInt(const std::string& name) const { 
                        POL_GETSCALAR(name, int, INT) 
                    }
                
                    /**
                     * return a double value associated with the given name.  If the 
                     * underlying value is an array, only the last value added will be 
                     * returned.  
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                             a double type.  
                     */
                    double getDouble(const std::string& name) const { 
                        POL_GETSCALAR(name, double, DOUBLE) 
                    }
                
                    /**
                     * return a string value associated with the given name .  If the 
                     * underlying value is an array, only the last value added will be 
                     * returned.  
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                             an integer type.  
                     */
                    const std::string getString(const std::string& name) const { 
                        POL_GETSCALAR(name, std::string, STRING) 
                    }
                
                    //@{
                    /**
                     * return an array of Policy pointers associated with the given name.  
                     * 
                     * Adding an element to the returned array (using push_back()) is 
                     * equivalent adding a value with add(const string&, const Policy::Ptr&). 
                     * 
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                             a Policy type.  
                     */
                    PolicyPtrArray getPolicyArray(const std::string& name) const;
                    ConstPolicyPtrArray getConstPolicyArray(const std::string& name) const;
                    //@}
                
                    /**
                     * return an array of PolicyFile pointers associated with the given name.  
                     * 
                     * Adding an element to the returned array (using push_back()) is 
                     * equivalent adding a value with 
                     * add(const string&, const Policy::FilePtr&). 
                     * 
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                             a Policy type.  
                     */
                    FilePtrArray getFileArray(const std::string& name) const; 
                
                    //@{
                    /**
                     * return an array of values associated with the given name
                     * @param name     the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @exception NameNotFound  if no value is associated with the given name.
                     * @exception TypeError     if the value associated the given name is not
                     *                          the expected type.
                     */
                    BoolArray getBoolArray(const std::string& name) const;  // inlined
                    IntArray getIntArray(const std::string& name) const;    // inlined
                    DoubleArray getDoubleArray(const std::string& name) const; // inlined
                    StringArray getStringArray(const std::string& name) const;  //inlined
                    //@}
                
                    //@{
                    /**
                     * Set a value with the given name.  
                     *
                     * Any previous value set with the same name will be overwritten.  In 
                     * particular, if the property previously pointed to an array of values,
                     * all those values will be forgotten.
                     *
                     * If this policy has a \code Dictionary \endcode (see \code canValidate()
                     * \endcode), this operation will be checked before it is performed, and if
                     * it would create an invalid state, it will not succeed, and a \code
                     * ValidationError \endcode will be thrown.  With the exception that the
                     * minimum number of values (in the case of an array) will *not* be checked,
                     * in case this will be followed by \code add \endcode operations.
                     *
                     * Note that \code set(const string&, const string&) \endcode and 
                     * \code set(const string&, const char *) \endcode are equivalent.
                     *
                     * @param name       the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @param value      the value--int, double, string or Policy--to 
                     *                    associate with the name.  
                     * @exception TypeError  if this Policy is controlled by a Dictionary but 
                     *                    the value type does not match the definition 
                     *                    associated with the name. 
                     */
                    template <typename T> void setValue(const std::string& name, const T& value);
                    void set(const std::string& name, const Ptr& value);      // inlined below
                    void set(const std::string& name, const FilePtr& value);  // inlined below
                    void set(const std::string& name, bool value);            // inlined below
                    void set(const std::string& name, int value);             // inlined below
                    void set(const std::string& name, double value);          // inlined below
                    void set(const std::string& name, const std::string& value);  // inlined
                    void set(const std::string& name, const char *value);     // inlined below
                    //@}
                
                    //@{
                    /**
                     * Add a value to an array of values with a given name.  
                     *
                     * If a value was previously set using the set() function, that previous
                     * value will be retained as the first value of the array.
                     *
                     * If this policy has a \code Dictionary \endcode (see \code canValidate()
                     * \endcode), this operation will be checked before it is performed, and if
                     * it would create an invalid state, it will not succeed, and a \code
                     * ValidationError \endcode will be thrown.  With the exception that the
                     * minimum number of values (in the case of an array) will *not* be checked,
                     * in case this is part of a sequence of \code add \endcode operations.
                     *
                     * Note that \code add(const string&, const string&) \endcode and 
                     * \code add(const string&, const char *) \endcode are equivalent.
                     * @param name       the name of the parameter.  This can be a hierarchical
                     *                    name with fields delimited with "."
                     * @param value      the value--int, double, string or Policy--to 
                     *                    associate with the name.  
                     * @exception TypeError  if the existing array of values is not of the 
                     *                    requested type, or 
                     *                    if this Policy is controlled by a Dictionary but 
                     *                    the value type does not match the definition 
                     *                    associated with the name. 
                     */
                    // avoid name confusion with appended T
                    template <typename T> void addValue(const std::string& name, const T& value);
                    void add(const std::string& name, const Ptr& value);      // inlined below
                    void add(const std::string& name, const FilePtr& value);  // inlined below
                    void add(const std::string& name, bool value);            // inlined below
                    void add(const std::string& name, int value);             // inlined below
                    void add(const std::string& name, double value);          // inlined below
                    void add(const std::string& name, const std::string& value);    // inlined
                    void add(const std::string& name, const char *value);     // inlined below
                    //@}
                
                    /**
                     * Remove all values with a given name.
                     * @param name The name of the parameter to remove. Can be hierarchical
                     *             name with fields delimited with ".".
                     */
                    void remove(const std::string& name); // inlined below
                
                    /**
                     * Recursively replace all PolicyFile values with the contents of the 
                     * files they refer to.  The type of a parameter containing a PolicyFile
                     * will consequently change to a Policy upon successful completion.  If
                     * the value is an array, all PolicyFiles in the array must load without
                     * error before the PolicyFile values themselves are erased.
                     * @param strict      If true, throw an exception if an error occurs 
                     *                    while reading and/or parsing the file (probably an
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
770  <a href="#a938e0ae">a938e0ae</a> -      *                    IoErrorException or ParseError).  Otherwise, replace</div>
              ?                                  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
770  <a href="#826f6e19">826f6e19</a> +      *                    IoError or ParseError).  Otherwise, replace</div>
                     *                    the file reference with a partial or empty sub-policy
                     *                    (that is, "{}").
                     * @return            the number of files loaded
                     */
                    int loadPolicyFiles(bool strict=true) {
                        return loadPolicyFiles(boost::filesystem::path(), strict);
                    }
                
                    /**
                     * \copydoc loadPolicyFiles()
                     * @param repository  a directory to look in for the referenced files.  
                     *                    Only when the name of the file to be included is an
                     *                    absolute path will this.  If empty or not provided,
                     *                    the directorywill be assumed to be the current one.
                     */
                    virtual int loadPolicyFiles(const boost::filesystem::path& repository,
                                                bool strict=true);
                
                    /**
                     * use the values found in the given policy as default values for parameters
                     * not specified in this policy.  This function will iterate through the
                     * parameter names in the given policy, and if the name is not found in this
                     * policy, the value from the given one will be copied into this one.  No
                     * attempt is made to match the number of values available per name.
                     * @param defaultPol  the policy to pull default values from.  This may 
                     *                    be a Dictionary; if so, the default values will 
                     *                    drawn from the appropriate default keyword.
                     * @param keepForValidation if true, and if defaultPol is a Dictionary, keep
                     *                    a reference to it for validation future updates to
                     *                    this Policy.
                     * @param errs        an exception to load errors into -- only relevant if
                     *                    defaultPol is a Dictionary or if this Policy already
                     *                    has a dictionary to validate against; if a validation
                     *                    error is encountered, it will be added to errs if errs
                     *                    is non-null, and an exception will not be raised;
                     *                    however, if errs is null, an exception will be thrown
                     *                    if a validation error is encountered.
                     * @return int        the number of parameter names copied over
                     */
                    int mergeDefaults(const Policy& defaultPol, bool keepForValidation=true,
                                      ValidationError *errs=0);
                
                    /**
                     * return a string representation of the value given by a name.  The
                     * string "<null>" is printed if the name does not exist.
                     * @param name     the name of the parameter to string-ify
                     * @param indent  a string to prepend each line with.  If the string 
                     *                 includes embedded newline characters, each line 
                     *                 should be preceded by this indent string.
                     */
                    virtual std::string str(const std::string& name, 
                                            const std::string& indent="") const;
                
                    /**
                     * print the contents of this policy to an output stream.  This 
                     * is mainly intended for debugging purposes.  
                     * @param out     the output stream to write contents to
                     * @param label   a labeling string to lead the listing with.
                     * @param indent  a string to prepend each line with.
                     */
                    virtual void print(std::ostream& out, const std::string& label="Policy", 
                                       const std::string& indent="") const;
                
                    /**
                     * convert the entire contents of this policy to a string.  This 
                     * is mainly intended for debugging purposes.  
                     */
                    std::string toString() const;
                
                    /**
                     * return the internal policy data as a PropertySet pointer.  All
                     * sub-policy data will appear as PropertySets.
                     */
                    lsst::daf::base::PropertySet::Ptr asPropertySet();             // inlined below
                
                protected:
                    /**
                     * use a PropertySet as the data for a new Policy object
                     */
                    Policy(const lsst::daf::base::PropertySet::Ptr ps) 
                        : Citizen(typeid(this)), lsst::daf::base::Persistable(), _data(ps) 
                    { }
                
                private:
                    lsst::daf::base::PropertySet::Ptr _data;
                
                    DictPtr _dictionary;
                
                    int _names(std::list<std::string>& names, bool topLevelOnly=false, 
                               bool append=false, int want=3) const;
                    int _names(std::vector<std::string>& names, bool topLevelOnly=false, 
                               bool append=false, int want=3) const;
                
                    /**
                     * If _dictionary is non-null, validate value against it, assuming curCount
                     * current values for name.
                     */
                    template <typename T> 
                    void _validate(const std::string& name, const T& value, int curCount=0);
                
                    std::vector<lsst::daf::base::Persistable::Ptr> 
                        _getPersistList(const std::string& name) const 
                    {
                        POL_GETLIST(name, Persistable::Ptr, FILE)
                    }
                    std::vector<lsst::daf::base::PropertySet::Ptr> 
                        _getPropSetList(const std::string& name) const 
                    {
                        POL_GETLIST(name, lsst::daf::base::PropertySet::Ptr, POLICY)
                    }
                
                    static Policy *_createPolicy(PolicySource& input, bool doIncludes,
                                                 const boost::filesystem::path& repos,
                                                 bool validate);
                    static Policy *_createPolicy(const std::string& input, bool doIncludes,
                                                 const boost::filesystem::path& repos,
                                                 bool validate);
                };
                
                inline std::ostream& operator<<(std::ostream& os, const Policy& p) {
                    p.print(os);
                    return os;
                }
                
                /*  ************** Inline Class functions ********************  */
                
                inline int Policy::names(std::list<std::string>& names, bool topLevelOnly, 
                                         bool append) const
                {
                    return _names(names, topLevelOnly, append, 7);
                }
                inline int Policy::paramNames(std::list<std::string>& names, bool topLevelOnly,
                                              bool append) const
                {
                    return _names(names, topLevelOnly, append, 4);
                }
                inline int Policy::policyNames(std::list<std::string>& names, 
                                               bool topLevelOnly,
                                               bool append) const
                {
                    return _names(names, topLevelOnly, append, 1);
                }
                inline int Policy::fileNames(std::list<std::string>& names, bool topLevelOnly, 
                                             bool append) const
                {
                    return _names(names, topLevelOnly, append, 2);
                }
                
                inline Policy::StringArray Policy::names(bool topLevelOnly) const { 
                    return _data->names(); 
                }
                inline Policy::StringArray Policy::paramNames(bool topLevelOnly) const {
                    StringArray out;
                    _names(out, topLevelOnly, true, 4);
                    return out;
                }
                inline Policy::StringArray Policy::policyNames(bool topLevelOnly) const {
                    return _data->propertySetNames(topLevelOnly);
                }
                inline Policy::StringArray Policy::fileNames(bool topLevelOnly) const {
                    StringArray out;
                    _names(out, topLevelOnly, true, 2);
                    return out;
                }
                
                inline size_t Policy::valueCount(const std::string& name) const { 
                    return _data->valueCount(name); 
                }
                
                inline bool Policy::isArray(const std::string& name) const { 
                    return _data->isArray(name); 
                }
                
                inline bool Policy::exists(const std::string& name) const { 
                    return _data->exists(name); 
                }
                
                inline bool Policy::isBool(const std::string& name) const {
                    try {
                        return (_data->typeOf(name) == typeid(bool));
                    }
                    catch (...) {
                        return false;
                    }
                }
                
                inline bool Policy::isInt(const std::string& name) const {
                    try {
                        return (_data->typeOf(name) == typeid(int));
                    }
                    catch (...) {
                        return false;
                    }
                }
                
                inline bool Policy::isDouble(const std::string& name) const {
                    try {
                        return (_data->typeOf(name) == typeid(double));
                    }
                    catch (...) {
                        return false;
                    }
                }
                
                inline bool Policy::isString(const std::string& name) const {
                    try {
                        return (_data->typeOf(name) == typeid(std::string));
                    }
                    catch (...) {
                        return false;
                    }
                }
                
                inline bool Policy::isPolicy(const std::string& name) const {
                    try {
                        return (_data->typeOf(name) == typeid(lsst::daf::base::PropertySet::Ptr));
                    }
                    catch (...) {
                        return false;
                    }
                }
                
                inline bool Policy::isFile(const std::string& name) const {
                    
                    try {
                        return (getValueType(name) == FILE);
                    }
                    catch (...) {
                        return false;
                    }
                }
                
                inline const std::type_info& Policy::getTypeInfo(const std::string& name) const
                {
                    try {  return _data->typeOf(name); }
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1006 <a href="#ffbde6ab">ffbde6ab</a> -     catch (lsst::pex::exceptions::NotFoundException& e) {</div>
              ?                                            ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1006 <a href="#826f6e19">826f6e19</a> +     catch (lsst::pex::exceptions::NotFoundError& e) {</div>
              ?                                            ^^ ^
                        throw LSST_EXCEPT(NameNotFound, name);
                    }
                }
                
                inline const std::type_info& Policy::typeOf(const std::string& name) const {
                    return getTypeInfo(name); 
                }
                
                inline Policy::ConstPtr Policy::getPolicy(const std::string& name) const {
                    return ConstPtr(new Policy(_data->get<lsst::daf::base::PropertySet::Ptr>(name)));
                }
                inline Policy::Ptr Policy::getPolicy(const std::string& name) {
                    return Ptr(new Policy(_data->get<lsst::daf::base::PropertySet::Ptr>(name)));
                }
                
                inline 
                Policy::StringArray Policy::getStringArray(const std::string& name) const {
                    return _data->getArray<std::string>(name);
                }
                
                inline Policy::BoolArray Policy::getBoolArray(const std::string& name) const {
                    POL_GETLIST(name, bool, BOOL) 
                }
                
                inline Policy::IntArray Policy::getIntArray(const std::string& name) const {
                    POL_GETLIST(name, int, INT) 
                }
                
                inline 
                Policy::DoubleArray Policy::getDoubleArray(const std::string& name) const {
                    POL_GETLIST(name, double, DOUBLE) 
                }
                
                inline void Policy::set(const std::string& name, const Ptr& value) {
                    _validate(name, value);
                    _data->set(name, value->asPropertySet());
                }
                inline void Policy::set(const std::string& name, bool value) { 
                    _validate(name, value);
                    _data->set(name, value); 
                }
                inline void Policy::set(const std::string& name, int value) { 
                    _validate(name, value);
                    _data->set(name, value); 
                }
                inline void Policy::set(const std::string& name, double value) { 
                    _validate(name, value);
                    _data->set(name, value); 
                }
                inline void Policy::set(const std::string& name, const std::string& value) { 
                    _validate(name, value);
                    _data->set(name, value); 
                }
                inline void Policy::set(const std::string& name, const char *value) { 
                    if (value == NULL)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1062 <a href="#a3aa71bf">a3aa71bf</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::InvalidParameterException,</div>
              ?                                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1062 <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::InvalidParameterError,</div>
              ?                                                                   ^^ ^
                                          std::string("Attempted to assign NULL value to ")
                                          + name + ".");
                    _validate(name, std::string(value));
                    _data->set(name, std::string(value)); 
                }
                
                #define POL_ADD(name, value) \
                    try {  _data->add(name, value);  } \
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1071 <a href="#ffbde6ab">ffbde6ab</a> -     catch(lsst::daf::base::TypeMismatchException&) { \</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1071 <a href="#826f6e19">826f6e19</a> +     catch(lsst::pex::exceptions::TypeError&) { \</div>
                        throw LSST_EXCEPT(TypeError, name, getTypeName(name));  \
                    }
                
                inline void Policy::add(const std::string& name, const Ptr& value) {
                    _validate(name, value, valueCount(name));
                    POL_ADD(name, value->asPropertySet())
                }
                inline void Policy::add(const std::string& name, bool value) { 
                    _validate(name, value, valueCount(name));
                    POL_ADD(name, value); 
                }
                inline void Policy::add(const std::string& name, int value) { 
                    _validate(name, value, valueCount(name));
                    POL_ADD(name, value); 
                }
                inline void Policy::add(const std::string& name, double value) { 
                    _validate(name, value, valueCount(name));
                    POL_ADD(name, value); 
                }
                inline void Policy::add(const std::string& name, const std::string& value) { 
                    _validate(name, value, valueCount(name));
                    POL_ADD(name, value); 
                }
                inline void Policy::add(const std::string& name, const char *value) { 
                    std::string v(value);
                    _validate(name, v, valueCount(name));
                    POL_ADD(name, v); 
                }
                
                // TODO: validate if required value?
                inline void Policy::remove(const std::string& name) {
                    _data->remove(name);
                }
                
                inline Policy* Policy::createPolicy(PolicySource& input, bool doIncludes, 
                                                    bool validate) 
                {
                    return _createPolicy(input, doIncludes, boost::filesystem::path(), validate);
                } 
                
                inline Policy* Policy::createPolicy(const std::string& input, bool doIncludes, 
                                                    bool validate) 
                {
                    return _createPolicy(input, doIncludes, boost::filesystem::path(), validate);
                } 
                
                inline Policy* Policy::createPolicy(PolicySource& input, 
                                                    const boost::filesystem::path& repository,
                                                    bool validate) 
                {
                    return _createPolicy(input, true, repository, validate);
                }
                
                inline Policy* Policy::createPolicy(PolicySource& input, 
                                                    const std::string& repository, 
                                                    bool validate) 
                {
                    return _createPolicy(input, true, boost::filesystem::path(repository), validate);
                }
                
                inline Policy* Policy::createPolicy(PolicySource& input, 
                                                    const char *repository, 
                                                    bool validate) 
                {
                    return _createPolicy(input, true, boost::filesystem::path(repository), validate);
                }
                
                inline Policy* Policy::createPolicy(const std::string& input, 
                                                    const boost::filesystem::path& repository,
                                                    bool validate) 
                {
                    return _createPolicy(input, true, repository, validate);
                }
                
                inline Policy* Policy::createPolicy(const std::string& input, 
                                                    const std::string& repository, 
                                                    bool validate) 
                {
                    return _createPolicy(input, true, boost::filesystem::path(repository), validate);
                }
                
                inline Policy* Policy::createPolicy(const std::string& input, 
                                                    const char *repository, 
                                                    bool validate) 
                {
                    return _createPolicy(input, true, boost::filesystem::path(repository), validate);
                }
                
                inline lsst::daf::base::PropertySet::Ptr Policy::asPropertySet() { return _data; }
                
                // general case is disallowed; known types are specialized
                template <typename T> T Policy::getValue(const std::string& name) const {
                    throw LSST_EXCEPT(TypeError, name, "not implemented for this type");
                }
                template <> bool Policy::getValue<bool>(const std::string& name) const;
                template <> int Policy::getValue<int>(const std::string& name) const;
                template <> double Policy::getValue<double>(const std::string& name) const;
                template <> std::string Policy::getValue<std::string>(const std::string& name) const;
                template <> Policy::FilePtr Policy::getValue<Policy::FilePtr>(const std::string& name) const;
                template <> Policy::ConstPtr Policy::getValue<Policy::ConstPtr>(const std::string& name) const;
                
                // general case is disallowed; known types are specialized
                template <typename T> std::vector<T> Policy::getValueArray(const std::string& name) const {
                    throw LSST_EXCEPT(TypeError, name, "not implemented for this type");
                }
                template <> std::vector<bool> Policy::getValueArray<bool>(const std::string& name) const;
                template <> std::vector<int> Policy::getValueArray<int>(const std::string& name) const;
                template <> std::vector<double> Policy::getValueArray<double>(const std::string& name) const;
                template <> std::vector<std::string> Policy::getValueArray<std::string>(const std::string& name) const;
                template <> Policy::FilePtrArray Policy::getValueArray<Policy::FilePtr>(const std::string& name) const;
                template <> Policy::PolicyPtrArray Policy::getValueArray<Policy::Ptr>(const std::string& name) const;
                template <> Policy::ConstPolicyPtrArray Policy::getValueArray<Policy::ConstPtr>(const std::string& name) const;
                
                // general case is disallowed; known types are specialized
                template <typename T> Policy::ValueType Policy::getValueType() {
                    throw LSST_EXCEPT(TypeError, "unknown", "not implemented for this type");
                }
                template <> Policy::ValueType Policy::getValueType<bool>();
                template <> Policy::ValueType Policy::getValueType<int>();
                template <> Policy::ValueType Policy::getValueType<double>();
                template <> Policy::ValueType Policy::getValueType<std::string>();
                template <> Policy::ValueType Policy::getValueType<Policy>();
                template <> Policy::ValueType Policy::getValueType<Policy::FilePtr>();
                template <> Policy::ValueType Policy::getValueType<Policy::Ptr>();
                template <> Policy::ValueType Policy::getValueType<Policy::ConstPtr>();
                
                // general case is disallowed; known types are specialized
                template <typename T> void Policy::setValue(const std::string& name, const T& value) {
                    throw LSST_EXCEPT(TypeError, name, "not implemented for this type");
                }
                template <> void Policy::setValue<bool>(const std::string& name, const bool& value);
                template <> void Policy::setValue<int>(const std::string& name, const int& value);
                template <> void Policy::setValue<double>(const std::string& name, const double& value);
                template <> void Policy::setValue<std::string>(const std::string& name, const std::string& value);
                template <> void Policy::setValue<Policy::Ptr>(const std::string& name, const Policy::Ptr& value);
                template <> void Policy::setValue<Policy::FilePtr>(const std::string& name, const Policy::FilePtr& value);
                
                // general case is disallowed; known types are specialized
                template <typename T> void Policy::addValue(const std::string& name, const T& value) {
                    throw LSST_EXCEPT(TypeError, name, "not implemented for this type");
                }
                template <> void Policy::addValue<bool>(const std::string& name, const bool& value);
                template <> void Policy::addValue<int>(const std::string& name, const int& value);
                template <> void Policy::addValue<double>(const std::string& name, const double& value);
                template <> void Policy::addValue<std::string>(const std::string& name, const std::string& value);
                template <> void Policy::addValue<Policy::Ptr>(const std::string& name, const Policy::Ptr& value);
                template <> void Policy::addValue<Policy::FilePtr>(const std::string& name, const Policy::FilePtr& value);
                
                }}}  // end namespace lsst::pex::policy
                
                #endif // LSST_PEX_POLICY_POLICY_H
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="ffbde6ab"/></a>ffbde6ab</h3>

<pre>
commit ffbde6abe48212de8420148bd05e9ef2b5e96ffe
Author: smm <smm@git.lsstcorp.org>
Date:   Mon Nov 7 21:41:56 2011 +0000

    pex_policy Winter2012b: remove namespace aliases in headers, upgrade to swig 2.x
</pre>
<h3><a name="a3aa71bf"/></a>a3aa71bf</h3>

<pre>
commit a3aa71bf302bca31d448e538a08008863b4bf6f2
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Thu Dec 3 16:15:15 2009 +0000

    standards check (remove tabs)
</pre>
<h3><a name="a938e0ae"/></a>a938e0ae</h3>

<pre>
commit a938e0ae6e04eb065113480c098a5e9f681a0bb9
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Nov 18 20:48:24 2009 +0000

    Merged revisions 10237-10239,10263,10278-10279,10318-10320,10332,10334-10336,10359,10383,10390,10439,10445-10446,10449,10469-10471,10485,10499-10501,10570,10572-10574,10581-10584,10617,10619-10623,10627,10674-10677,10691,10890,10918,10985-10986,11436-11438,11482,11489-11490 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/872
    
    ........
      r10237 | bbaker | 2009-07-24 13:40:06 -0500 (Fri, 24 Jul 2009) | 1 line
    
      add rough childDefinition definition
    ........
      r10238 | bbaker | 2009-07-24 13:40:33 -0500 (Fri, 24 Jul 2009) | 1 line
    
      rough list of validation tests, from examining the spec in Dictionary.h
    ........
      r10239 | bbaker | 2009-07-24 13:41:18 -0500 (Fri, 24 Jul 2009) | 1 line
    
      comment
    ........
      r10263 | bbaker | 2009-07-27 09:44:48 -0500 (Mon, 27 Jul 2009) | 1 line
    
      add details to list of tests
    ........
      r10278 | bbaker | 2009-07-29 15:00:10 -0500 (Wed, 29 Jul 2009) | 1 line
    
      typos
    ........
      r10279 | bbaker | 2009-07-29 15:00:41 -0500 (Wed, 29 Jul 2009) | 1 line
    
      add some missing fields
    ........
      r10318 | bbaker | 2009-07-31 18:16:01 -0500 (Fri, 31 Jul 2009) | 1 line
    
      primitive examples for development
    ........
      r10319 | bbaker | 2009-07-31 18:16:29 -0500 (Fri, 31 Jul 2009) | 1 line
    
      debugging validation
    ........
      r10320 | bbaker | 2009-07-31 18:17:06 -0500 (Fri, 31 Jul 2009) | 1 line
    
      placeholder
    ........
      r10332 | bbaker | 2009-08-04 11:03:53 -0500 (Tue, 04 Aug 2009) | 1 line
    
      correct typos; tweak constants
    ........
      r10334 | bbaker | 2009-08-04 11:40:31 -0500 (Tue, 04 Aug 2009) | 1 line
    
      fix unit test -- mixed types
    ........
      r10335 | bbaker | 2009-08-04 11:54:01 -0500 (Tue, 04 Aug 2009) | 1 line
    
      dictionary unit test stub
    ........
      r10336 | bbaker | 2009-08-04 13:00:11 -0500 (Tue, 04 Aug 2009) | 1 line
    
      move unit test files into tests; add simple validate
    ........
      r10359 | bbaker | 2009-08-05 17:33:18 -0500 (Wed, 05 Aug 2009) | 1 line
    
      rigorize dictionary type handling
    ........
      r10383 | bbaker | 2009-08-07 13:32:20 -0500 (Fri, 07 Aug 2009) | 1 line
    
      cleaning up values validation
    ........
      r10390 | bbaker | 2009-08-07 17:55:15 -0500 (Fri, 07 Aug 2009) | 1 line
    
      templates templates templates
    ........
      r10439 | bbaker | 2009-08-12 17:26:49 -0500 (Wed, 12 Aug 2009) | 1 line
    
      improve error messages, and other testing
    ........
      r10445 | bbaker | 2009-08-13 14:23:31 -0500 (Thu, 13 Aug 2009) | 1 line
    
      getTypeByName -- whew
    ........
      r10446 | bbaker | 2009-08-13 15:16:55 -0500 (Thu, 13 Aug 2009) | 1 line
    
      more dictionary integrity tests
    ........
      r10449 | bbaker | 2009-08-13 16:37:22 -0500 (Thu, 13 Aug 2009) | 1 line
    
      confirm that policy validation is only partial
    ........
      r10469 | bbaker | 2009-08-14 15:56:35 -0500 (Fri, 14 Aug 2009) | 1 line
    
      value validation
    ........
      r10470 | bbaker | 2009-08-14 15:57:51 -0500 (Fri, 14 Aug 2009) | 1 line
    
      remove finished TODO
    ........
      r10471 | bbaker | 2009-08-14 16:15:24 -0500 (Fri, 14 Aug 2009) | 1 line
    
      detect missing required items
    ........
      r10485 | bbaker | 2009-08-17 17:39:50 -0500 (Mon, 17 Aug 2009) | 1 line
    
      nested validation
    ........
      r10499 | bbaker | 2009-08-18 15:34:33 -0500 (Tue, 18 Aug 2009) | 1 line
    
      childDefinition implementation and tests
    ........
      r10500 | bbaker | 2009-08-18 16:19:48 -0500 (Tue, 18 Aug 2009) | 1 line
    
      comments
    ........
      r10501 | bbaker | 2009-08-18 16:22:02 -0500 (Tue, 18 Aug 2009) | 1 line
    
      TODOs
    ........
      r10570 | bbaker | 2009-09-01 18:06:33 -0500 (Tue, 01 Sep 2009) | 1 line
    
      more validation when loading from defaults
    ........
      r10572 | bbaker | 2009-09-01 21:58:01 -0500 (Tue, 01 Sep 2009) | 1 line
    
      quick emacs cmd
    ........
      r10573 | bbaker | 2009-09-01 22:22:45 -0500 (Tue, 01 Sep 2009) | 1 line
    
      obsolete
    ........
      r10574 | bbaker | 2009-09-01 22:23:08 -0500 (Tue, 01 Sep 2009) | 1 line
    
      validate on set/add -- step 1
    ........
      r10581 | bbaker | 2009-09-03 16:17:42 -0500 (Thu, 03 Sep 2009) | 1 line
    
      accessors for policy.dictionary, test policy self-validation
    ........
      r10582 | bbaker | 2009-09-03 16:22:51 -0500 (Thu, 03 Sep 2009) | 1 line
    
      more set/add tests
    ........
      r10583 | bbaker | 2009-09-03 16:23:40 -0500 (Thu, 03 Sep 2009) | 1 line
    
      comment
    ........
      r10584 | bbaker | 2009-09-03 16:25:31 -0500 (Thu, 03 Sep 2009) | 1 line
    
      oops, test failed
    ........
      r10617 | bbaker | 2009-09-11 15:27:09 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fixes related to nested dictionaries and policies
    ........
      r10619 | bbaker | 2009-09-11 16:09:40 -0500 (Fri, 11 Sep 2009) | 1 line
    
      remove debugging printouts, convert to constants instead of literal strings
    ........
      r10620 | bbaker | 2009-09-11 16:16:57 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fix spelling of EventTranmitter
    ........
      r10621 | bbaker | 2009-09-11 16:22:59 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test condensed dictionary syntax, update docs and TODOs
    ........
      r10622 | bbaker | 2009-09-11 16:24:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test without 'target' field in dictionary
    ........
      r10623 | bbaker | 2009-09-11 16:27:34 -0500 (Fri, 11 Sep 2009) | 1 line
    
      resolve TODO comments
    ........
      r10627 | bbaker | 2009-09-11 17:15:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      deep dictionary loading
    ........
      r10674 | bbaker | 2009-09-18 15:02:18 -0500 (Fri, 18 Sep 2009) | 1 line
    
      use boost::make_shared where possible
    ........
      r10675 | bbaker | 2009-09-18 15:07:03 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10676 | bbaker | 2009-09-18 15:07:42 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10677 | bbaker | 2009-09-18 17:39:14 -0500 (Fri, 18 Sep 2009) | 1 line
    
      working on validation script
    ........
      r10691 | bbaker | 2009-09-21 18:18:48 -0500 (Mon, 21 Sep 2009) | 1 line
    
      validation script for dictionary & policy authors
    ........
      r10890 | bbaker | 2009-10-06 12:22:53 -0500 (Tue, 06 Oct 2009) | 1 line
    
      uses of Policy C++ and Python interfaces
    ........
      r10918 | bbaker | 2009-10-07 13:09:45 -0500 (Wed, 07 Oct 2009) | 1 line
    
      hide certain swig warnings
    ........
      r10985 | bbaker | 2009-10-12 15:44:45 -0500 (Mon, 12 Oct 2009) | 1 line
    
      improve formatting
    ........
      r10986 | bbaker | 2009-10-12 15:46:30 -0500 (Mon, 12 Oct 2009) | 1 line
    
      list of policy files
    ........
      r11436 | bbaker | 2009-11-10 14:02:15 -0600 (Tue, 10 Nov 2009) | 1 line
    
      move validate.py test script into tests dir
    ........
      r11437 | bbaker | 2009-11-10 14:02:40 -0600 (Tue, 10 Nov 2009) | 1 line
    
      reference to --help
    ........
      r11438 | bbaker | 2009-11-10 14:03:28 -0600 (Tue, 10 Nov 2009) | 1 line
    
      pex_policy: add options to mergeDefaults to validate and to keep dictionary
    ........
      r11482 | bbaker | 2009-11-17 15:40:53 -0600 (Tue, 17 Nov 2009) | 1 line
    
      more mergeDefaults -- deep Policy merge
    ........
      r11489 | bbaker | 2009-11-18 12:43:19 -0600 (Wed, 18 Nov 2009) | 1 line
    
      improve standards compliance
    ........
      r11490 | bbaker | 2009-11-18 12:50:15 -0600 (Wed, 18 Nov 2009) | 1 line
    
      more standards compliance
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_30"><a name="include/lsst/pex/policy/exceptions.h"/></a>include/lsst/pex/policy/exceptions.h</h1>

<h3 id="toc_31">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file lsst/pex/policy/exceptions.h
                 * @ingroup pex
                 * @brief definition of Policy-specific exceptions classes
                 * @author Ray Plante
                 */
                
                #ifndef LSST_PEX_POLICY_EXCEPTIONS_H
                #define LSST_PEX_POLICY_EXCEPTIONS_H
                
                #include "lsst/pex/exceptions.h"
                
                #define POL_EARGS_TYPED char const* ex_file, int ex_line, char const* ex_func
                #define POL_EARGS_UNTYPED ex_file, ex_line, ex_func
                #define POL_EXCEPT_VIRTFUNCS(etn) \
                char const *etn::getType(void) const throw() { return #etn " *"; } \
                lsst::pex::exceptions::Exception *etn::clone(void) const { \
                    return new etn(*this); \
                }
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                /**
                 * an exception thrown when Policy parameter name has an illegal form.  This
                 * usually means that it contains zero-length fields.  In other words, it 
                 * either starts with a period, ends with a period, or contains two or more
                 * consecutive periods.
                 */
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#ffbde6ab">ffbde6ab</a> - class BadNameError : public lsst::pex::exceptions::RuntimeErrorException {</div>
              ?                                                                ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#826f6e19">826f6e19</a> + class BadNameError : public lsst::pex::exceptions::RuntimeError {</div>
                public:
                    BadNameError(POL_EARGS_TYPED) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
58   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::RuntimeErrorException(</div>
              ?                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
58   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::RuntimeError(</div>
                                POL_EARGS_UNTYPED, "Illegal Policy parameter name") 
                    { }
                    BadNameError(POL_EARGS_TYPED, const std::string& badname) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
62   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::RuntimeErrorException(POL_EARGS_UNTYPED, </div>
              ?                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
62   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::RuntimeError(POL_EARGS_UNTYPED, </div>
                              std::string("Illegal Policy parameter name: ") + badname) 
                    { }
                    virtual char const *getType(void) const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                /**
                 * There is a problem with a dictionary.
                 */
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
72   <a href="#ffbde6ab">ffbde6ab</a> - class DictionaryError : public lsst::pex::exceptions::DomainErrorException {</div>
              ?                                                                  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
72   <a href="#826f6e19">826f6e19</a> + class DictionaryError : public lsst::pex::exceptions::DomainError {</div>
                public:
                    DictionaryError(POL_EARGS_TYPED)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
75   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::DomainErrorException(</div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
75   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::DomainError(</div>
                                POL_EARGS_UNTYPED, "Malformed dictionary")
                    { }
                    DictionaryError(POL_EARGS_TYPED, const std::string& msg)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
79   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::DomainErrorException(POL_EARGS_UNTYPED,</div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
79   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::DomainError(POL_EARGS_UNTYPED,</div>
                            std::string("Malformed dictionary: ") + msg)
                    { }
                    virtual char const *getType(void) const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                /**
                 * an exception indicating that a policy parameter of a given name can
                 * not be found in a Policy object.
                 */
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#ffbde6ab">ffbde6ab</a> - class NameNotFound : public lsst::pex::exceptions::NotFoundException {</div>
              ?                                                             ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#826f6e19">826f6e19</a> + class NameNotFound : public lsst::pex::exceptions::NotFoundError {</div>
              ?                                                             ^^ ^
                public:
                    NameNotFound(POL_EARGS_TYPED) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
93   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::NotFoundException(</div>
              ?                                           ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
93   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::NotFoundError(</div>
              ?                                           ^^ ^
                                POL_EARGS_UNTYPED, "Policy parameter name not found") 
                    { }
                    NameNotFound(POL_EARGS_TYPED, const std::string& parameter) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
97   <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::NotFoundException(POL_EARGS_UNTYPED,</div>
              ?                                           ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
97   <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::NotFoundError(POL_EARGS_UNTYPED,</div>
              ?                                           ^^ ^
                                std::string("Policy parameter name not found: ") + parameter) 
                    { }
                    virtual char const *getType(void) const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                /**
                 * an exception indicating that a policy parameter with a given name has a
                 * type different from the one that was requested.
                 */
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
108  <a href="#ffbde6ab">ffbde6ab</a> - class TypeError : public lsst::pex::exceptions::DomainErrorException {</div>
              ?                                                            ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
108  <a href="#826f6e19">826f6e19</a> + class TypeError : public lsst::pex::exceptions::DomainError {</div>
                public:
                    TypeError(POL_EARGS_TYPED) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::DomainErrorException(</div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::DomainError(</div>
                                POL_EARGS_UNTYPED, "Parameter has wrong type") 
                    { }
                    TypeError(POL_EARGS_TYPED, 
                              const std::string& parameter, const std::string& expected)  
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
116  <a href="#ffbde6ab">ffbde6ab</a> -         : lsst::pex::exceptions::DomainErrorException(POL_EARGS_UNTYPED, </div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
116  <a href="#826f6e19">826f6e19</a> +         : lsst::pex::exceptions::DomainError(POL_EARGS_UNTYPED, </div>
                              std::string("Parameter \"") + parameter + 
                              "\" has wrong type; expecting " + expected + ".")
                    { }
                    virtual char const *getType(void) const throw();
                    virtual lsst::pex::exceptions::Exception *clone() const;
                };
                
                }}}  // end namespace lsst::pex::policy
                
                
                #endif // LSST_PEX_POLICY_EXCEPTIONS_H
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="ffbde6ab"/></a>ffbde6ab</h3>

<pre>
commit ffbde6abe48212de8420148bd05e9ef2b5e96ffe
Author: smm <smm@git.lsstcorp.org>
Date:   Mon Nov 7 21:41:56 2011 +0000

    pex_policy Winter2012b: remove namespace aliases in headers, upgrade to swig 2.x
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_32"><a name="src/PolicyFile.cc"/></a>src/PolicyFile.cc</h1>

<h3 id="toc_33">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file PolicyFile.cc
                 * 
                 * @ingroup pex
                 *
                 * @author Ray Plante
                 * 
                 */
                #include <fstream>
                
                #include <boost/scoped_ptr.hpp>
                #include <boost/filesystem/convenience.hpp>
                
                #include "lsst/pex/policy/PolicyFile.h"
                #include "lsst/pex/policy/PolicyParser.h"
                #include "lsst/pex/policy/exceptions.h"
                #include "lsst/pex/policy/parserexceptions.h"
                #include "lsst/pex/policy/paf/PAFParserFactory.h"
                /*
                 * Workaround for boost::filesystem v2 (not needed in boost >= 1.46)
                 */
                #include "boost/version.hpp"
                #include "boost/filesystem/config.hpp"
                #if BOOST_VERSION <= 104600 || BOOST_FILESYSTEM_VERSION < 3
                namespace boost { namespace filesystem {
                    path absolute(const path& p)
                    {
                        return complete(p);
                    }
                }}
                #endif
                namespace fs = boost::filesystem;
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                //@cond
                
                using std::string;
                using std::ifstream;
                using boost::regex;
                using boost::regex_match;
                using boost::regex_search;
                using boost::scoped_ptr;
                using lsst::pex::policy::paf::PAFParserFactory;
                
                namespace pexExcept = lsst::pex::exceptions;
                
                const string PolicyFile::EXT_PAF(".paf");
                const string PolicyFile::EXT_XML(".xml");
                
                const regex PolicyFile::SPACE_RE("^\\s*$");
                const regex PolicyFile::COMMENT("^\\s*#");
                const regex 
                          PolicyFile::CONTENTID("^\\s*#\\s*<\\?cfg\\s+\\w+(\\s+\\w+)*\\s*\\?>",
                                                regex::icase);
                
                /*
                 * create a Policy file that points a file with given path.
                 * @param filepath   the path to the file
                 */
                PolicyFile::PolicyFile(const SupportedFormats::Ptr& fmts) 
                    : PolicySource(fmts), Persistable(), 
                      _file(PolicyParserFactory::UNRECOGNIZED), _format(), _pfact() 
                { }
                
                PolicyFile::PolicyFile(const string& filepath, 
                                       const SupportedFormats::Ptr& fmts) 
                    : PolicySource(fmts), Persistable(), _file(filepath), _format(), _pfact() 
                { }
                
                PolicyFile::PolicyFile(const char *filepath, 
                                       const SupportedFormats::Ptr& fmts) 
                    : PolicySource(fmts), Persistable(), _file(filepath), _format(), _pfact() 
                { }
                
                PolicyFile::PolicyFile(const fs::path& filepath, 
                                       const SupportedFormats::Ptr& fmts) 
                    : PolicySource(fmts), Persistable(), _file(filepath), _format(), _pfact()
                { }
                
                PolicyFile::PolicyFile(const string& filepath, 
                                       const PolicyParserFactory::Ptr& parserFactory)
                    : PolicySource(), Persistable(), 
                      _file(filepath), _format(), _pfact(parserFactory)
                { 
                    if (! _pfact.get()) _format = _pfact->getFormatName();
                }
                
                PolicyFile::PolicyFile(const fs::path& filepath, 
                                       const PolicyParserFactory::Ptr& parserFactory)
                    : PolicySource(), Persistable(), 
                      _file(filepath), _format(), _pfact(parserFactory) 
                { 
                    if (! _pfact.get()) _format = _pfact->getFormatName();
                }
                
                PolicyFile::PolicyFile(const string& filepath, const fs::path& reposDir,
                                       const SupportedFormats::Ptr& fmts) 
                    : PolicySource(fmts), Persistable(), _file(filepath), _format(), _pfact() 
                { 
                    if (! _file.has_root_path() && ! reposDir.empty()) 
                        _file = reposDir / _file;
                }
                
                PolicyFile::PolicyFile(const fs::path& filepath, const fs::path& reposDir,
                                       const SupportedFormats::Ptr& fmts) 
                    : PolicySource(fmts), Persistable(), _file(filepath), _format(), _pfact()
                { 
                    if (! _file.has_root_path() && ! reposDir.empty()) 
                        _file = reposDir / _file;
                }
                
                PolicyFile::PolicyFile(const string& filepath, const fs::path& reposDir,
                                       const PolicyParserFactory::Ptr& parserFactory)
                    : PolicySource(), Persistable(), 
                      _file(filepath), _format(), _pfact(parserFactory)
                { 
                    if (! _file.has_root_path() && ! reposDir.empty()) 
                        _file = reposDir / _file;
                    if (! _pfact.get()) _format = _pfact->getFormatName();
                }
                
                PolicyFile::PolicyFile(const fs::path& filepath, const fs::path& reposDir,
                                       const PolicyParserFactory::Ptr& parserFactory)
                    : PolicySource(), Persistable(), 
                      _file(filepath), _format(), _pfact(parserFactory) 
                { 
                    if (! _file.has_root_path() && ! reposDir.empty()) 
                        _file = reposDir / _file;
                    if (! _pfact.get()) _format = _pfact->getFormatName();
                }
                
                /*
                 * return the name of the format that the data is stored in.  This may 
                 * cause the first few records of the source to be read.
                 * @exception IOError   if an error occurs while reading the first few
                 *                      characters of the source stream.
                 */
                const string& PolicyFile::getFormatName() {
                    if (_format.size() != 0) return _format;
                    if (_file.empty()) return PolicyParserFactory::UNRECOGNIZED;
                
                    // check the extension first
                    string ext = fs::extension(_file);
                    if (! ext.empty()) {
                        if (ext == EXT_PAF) {
                            if (_formats->supports(PAFParserFactory::FORMAT_NAME)) 
                                return cacheName(PAFParserFactory::FORMAT_NAME);
                        }
                        else if (ext == EXT_XML) {
                            return cacheName("XML");
                        }
                    }
                
                    // try reading the initial characters
                    if (fs::exists(_file)) {
                        ifstream is(_file.string().c_str());
                        if (is.fail()) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
183  <a href="#a938e0ae">a938e0ae</a> -             throw LSST_EXCEPT(pexExcept::IoErrorException,</div>
              ?                                                 ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
183  <a href="#826f6e19">826f6e19</a> +             throw LSST_EXCEPT(pexExcept::IoError,</div>
                                              "failure opening Policy file: " 
                                              + fs::absolute(_file).string());
                
                        // skip over comments
                        string line;
                        getline(is, line);
                        while (is.good() && 
                               (regex_match(line, SPACE_RE) || 
                                (regex_search(line, COMMENT) && !regex_search(line, COMMENT))))
                        { }
                            
                        if (is.fail()) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
196  <a href="#a938e0ae">a938e0ae</a> -             throw LSST_EXCEPT(pexExcept::IoErrorException,</div>
              ?                                                 ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
196  <a href="#826f6e19">826f6e19</a> +             throw LSST_EXCEPT(pexExcept::IoError,</div>
                                              "failure reading Policy file: " 
                                              + fs::absolute(_file).string());
                        if (is.eof() && 
                            (regex_match(line, SPACE_RE) || 
                             (regex_search(line, COMMENT) && !regex_search(line, COMMENT))))
                        {
                            // empty file; let's just assume PAF (but don't cache the name).
                            return PAFParserFactory::FORMAT_NAME;
                        }
                
                        return cacheName(_formats->recognizeType(line));
                    }
                
                    return PolicyParserFactory::UNRECOGNIZED;
                }
                
                /*
                 * load the data from this Policy source into a Policy object
                 * @param policy    the policy object to load the data into
                 * @exception ParserError  if an error occurs while parsing the data
                 * @exception IOError   if an I/O error occurs while reading from the 
                 *                       source stream.
                 */
                void PolicyFile::load(Policy& policy) const {
                
                    PolicyParserFactory::Ptr pfactory = _pfact;
                    if (! pfactory.get()) {
                        const string& fmtname = getFormatName();
                        if (fmtname.empty()) 
                            throw LSST_EXCEPT(ParserError, "Unknown Policy format: " + _file.string());
                
                        pfactory = _formats->getFactory(fmtname);
                    }
                
                    scoped_ptr<PolicyParser> parser(pfactory->createParser(policy));
                
                    ifstream fs(_file.string().c_str());
                    if (fs.fail()) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
235  <a href="#a938e0ae">a938e0ae</a> -         throw LSST_EXCEPT(pexExcept::IoErrorException,</div>
              ?                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
235  <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::IoError,</div>
                                          "failure opening Policy file: " 
                                          + fs::absolute(_file).string());
                
                    parser->parse(fs);
                    fs.close();
                }
                
                //@endcond
                
                }}}   // end lsst::pex::policy
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="a938e0ae"/></a>a938e0ae</h3>

<pre>
commit a938e0ae6e04eb065113480c098a5e9f681a0bb9
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Nov 18 20:48:24 2009 +0000

    Merged revisions 10237-10239,10263,10278-10279,10318-10320,10332,10334-10336,10359,10383,10390,10439,10445-10446,10449,10469-10471,10485,10499-10501,10570,10572-10574,10581-10584,10617,10619-10623,10627,10674-10677,10691,10890,10918,10985-10986,11436-11438,11482,11489-11490 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/872
    
    ........
      r10237 | bbaker | 2009-07-24 13:40:06 -0500 (Fri, 24 Jul 2009) | 1 line
    
      add rough childDefinition definition
    ........
      r10238 | bbaker | 2009-07-24 13:40:33 -0500 (Fri, 24 Jul 2009) | 1 line
    
      rough list of validation tests, from examining the spec in Dictionary.h
    ........
      r10239 | bbaker | 2009-07-24 13:41:18 -0500 (Fri, 24 Jul 2009) | 1 line
    
      comment
    ........
      r10263 | bbaker | 2009-07-27 09:44:48 -0500 (Mon, 27 Jul 2009) | 1 line
    
      add details to list of tests
    ........
      r10278 | bbaker | 2009-07-29 15:00:10 -0500 (Wed, 29 Jul 2009) | 1 line
    
      typos
    ........
      r10279 | bbaker | 2009-07-29 15:00:41 -0500 (Wed, 29 Jul 2009) | 1 line
    
      add some missing fields
    ........
      r10318 | bbaker | 2009-07-31 18:16:01 -0500 (Fri, 31 Jul 2009) | 1 line
    
      primitive examples for development
    ........
      r10319 | bbaker | 2009-07-31 18:16:29 -0500 (Fri, 31 Jul 2009) | 1 line
    
      debugging validation
    ........
      r10320 | bbaker | 2009-07-31 18:17:06 -0500 (Fri, 31 Jul 2009) | 1 line
    
      placeholder
    ........
      r10332 | bbaker | 2009-08-04 11:03:53 -0500 (Tue, 04 Aug 2009) | 1 line
    
      correct typos; tweak constants
    ........
      r10334 | bbaker | 2009-08-04 11:40:31 -0500 (Tue, 04 Aug 2009) | 1 line
    
      fix unit test -- mixed types
    ........
      r10335 | bbaker | 2009-08-04 11:54:01 -0500 (Tue, 04 Aug 2009) | 1 line
    
      dictionary unit test stub
    ........
      r10336 | bbaker | 2009-08-04 13:00:11 -0500 (Tue, 04 Aug 2009) | 1 line
    
      move unit test files into tests; add simple validate
    ........
      r10359 | bbaker | 2009-08-05 17:33:18 -0500 (Wed, 05 Aug 2009) | 1 line
    
      rigorize dictionary type handling
    ........
      r10383 | bbaker | 2009-08-07 13:32:20 -0500 (Fri, 07 Aug 2009) | 1 line
    
      cleaning up values validation
    ........
      r10390 | bbaker | 2009-08-07 17:55:15 -0500 (Fri, 07 Aug 2009) | 1 line
    
      templates templates templates
    ........
      r10439 | bbaker | 2009-08-12 17:26:49 -0500 (Wed, 12 Aug 2009) | 1 line
    
      improve error messages, and other testing
    ........
      r10445 | bbaker | 2009-08-13 14:23:31 -0500 (Thu, 13 Aug 2009) | 1 line
    
      getTypeByName -- whew
    ........
      r10446 | bbaker | 2009-08-13 15:16:55 -0500 (Thu, 13 Aug 2009) | 1 line
    
      more dictionary integrity tests
    ........
      r10449 | bbaker | 2009-08-13 16:37:22 -0500 (Thu, 13 Aug 2009) | 1 line
    
      confirm that policy validation is only partial
    ........
      r10469 | bbaker | 2009-08-14 15:56:35 -0500 (Fri, 14 Aug 2009) | 1 line
    
      value validation
    ........
      r10470 | bbaker | 2009-08-14 15:57:51 -0500 (Fri, 14 Aug 2009) | 1 line
    
      remove finished TODO
    ........
      r10471 | bbaker | 2009-08-14 16:15:24 -0500 (Fri, 14 Aug 2009) | 1 line
    
      detect missing required items
    ........
      r10485 | bbaker | 2009-08-17 17:39:50 -0500 (Mon, 17 Aug 2009) | 1 line
    
      nested validation
    ........
      r10499 | bbaker | 2009-08-18 15:34:33 -0500 (Tue, 18 Aug 2009) | 1 line
    
      childDefinition implementation and tests
    ........
      r10500 | bbaker | 2009-08-18 16:19:48 -0500 (Tue, 18 Aug 2009) | 1 line
    
      comments
    ........
      r10501 | bbaker | 2009-08-18 16:22:02 -0500 (Tue, 18 Aug 2009) | 1 line
    
      TODOs
    ........
      r10570 | bbaker | 2009-09-01 18:06:33 -0500 (Tue, 01 Sep 2009) | 1 line
    
      more validation when loading from defaults
    ........
      r10572 | bbaker | 2009-09-01 21:58:01 -0500 (Tue, 01 Sep 2009) | 1 line
    
      quick emacs cmd
    ........
      r10573 | bbaker | 2009-09-01 22:22:45 -0500 (Tue, 01 Sep 2009) | 1 line
    
      obsolete
    ........
      r10574 | bbaker | 2009-09-01 22:23:08 -0500 (Tue, 01 Sep 2009) | 1 line
    
      validate on set/add -- step 1
    ........
      r10581 | bbaker | 2009-09-03 16:17:42 -0500 (Thu, 03 Sep 2009) | 1 line
    
      accessors for policy.dictionary, test policy self-validation
    ........
      r10582 | bbaker | 2009-09-03 16:22:51 -0500 (Thu, 03 Sep 2009) | 1 line
    
      more set/add tests
    ........
      r10583 | bbaker | 2009-09-03 16:23:40 -0500 (Thu, 03 Sep 2009) | 1 line
    
      comment
    ........
      r10584 | bbaker | 2009-09-03 16:25:31 -0500 (Thu, 03 Sep 2009) | 1 line
    
      oops, test failed
    ........
      r10617 | bbaker | 2009-09-11 15:27:09 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fixes related to nested dictionaries and policies
    ........
      r10619 | bbaker | 2009-09-11 16:09:40 -0500 (Fri, 11 Sep 2009) | 1 line
    
      remove debugging printouts, convert to constants instead of literal strings
    ........
      r10620 | bbaker | 2009-09-11 16:16:57 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fix spelling of EventTranmitter
    ........
      r10621 | bbaker | 2009-09-11 16:22:59 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test condensed dictionary syntax, update docs and TODOs
    ........
      r10622 | bbaker | 2009-09-11 16:24:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test without 'target' field in dictionary
    ........
      r10623 | bbaker | 2009-09-11 16:27:34 -0500 (Fri, 11 Sep 2009) | 1 line
    
      resolve TODO comments
    ........
      r10627 | bbaker | 2009-09-11 17:15:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      deep dictionary loading
    ........
      r10674 | bbaker | 2009-09-18 15:02:18 -0500 (Fri, 18 Sep 2009) | 1 line
    
      use boost::make_shared where possible
    ........
      r10675 | bbaker | 2009-09-18 15:07:03 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10676 | bbaker | 2009-09-18 15:07:42 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10677 | bbaker | 2009-09-18 17:39:14 -0500 (Fri, 18 Sep 2009) | 1 line
    
      working on validation script
    ........
      r10691 | bbaker | 2009-09-21 18:18:48 -0500 (Mon, 21 Sep 2009) | 1 line
    
      validation script for dictionary & policy authors
    ........
      r10890 | bbaker | 2009-10-06 12:22:53 -0500 (Tue, 06 Oct 2009) | 1 line
    
      uses of Policy C++ and Python interfaces
    ........
      r10918 | bbaker | 2009-10-07 13:09:45 -0500 (Wed, 07 Oct 2009) | 1 line
    
      hide certain swig warnings
    ........
      r10985 | bbaker | 2009-10-12 15:44:45 -0500 (Mon, 12 Oct 2009) | 1 line
    
      improve formatting
    ........
      r10986 | bbaker | 2009-10-12 15:46:30 -0500 (Mon, 12 Oct 2009) | 1 line
    
      list of policy files
    ........
      r11436 | bbaker | 2009-11-10 14:02:15 -0600 (Tue, 10 Nov 2009) | 1 line
    
      move validate.py test script into tests dir
    ........
      r11437 | bbaker | 2009-11-10 14:02:40 -0600 (Tue, 10 Nov 2009) | 1 line
    
      reference to --help
    ........
      r11438 | bbaker | 2009-11-10 14:03:28 -0600 (Tue, 10 Nov 2009) | 1 line
    
      pex_policy: add options to mergeDefaults to validate and to keep dictionary
    ........
      r11482 | bbaker | 2009-11-17 15:40:53 -0600 (Tue, 17 Nov 2009) | 1 line
    
      more mergeDefaults -- deep Policy merge
    ........
      r11489 | bbaker | 2009-11-18 12:43:19 -0600 (Wed, 18 Nov 2009) | 1 line
    
      improve standards compliance
    ........
      r11490 | bbaker | 2009-11-18 12:50:15 -0600 (Wed, 18 Nov 2009) | 1 line
    
      more standards compliance
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_34"><a name="src/Dictionary.cc"/></a>src/Dictionary.cc</h1>

<h3 id="toc_35">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /*
                 * Dictionary
                 */
                #include "lsst/pex/policy/Dictionary.h"
                #include "lsst/pex/policy/PolicyFile.h"
                // #include "lsst/pex/utils/Trace.h"
                
                #include <boost/scoped_ptr.hpp>
                #include <boost/make_shared.hpp>
                #include <boost/lexical_cast.hpp>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
33   <a href="#ee5514fa">ee5514fa</a> + #include <boost/regex.hpp></div>
                
                #include <stdexcept>
                #include <memory>
                #include <string>
                #include <set>
                
                namespace pexExcept = lsst::pex::exceptions;
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
40   <a href="#ffbde6ab">ffbde6ab</a> - namespace fs = boost::filesystem;</div>
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                //@cond
                
                using namespace std;
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
49   <a href="#a938e0ae">a938e0ae</a> - using namespace boost;</div>
                
                const string ValidationError::EMPTY;
                
                ValidationError::MsgLookup ValidationError::_errmsgs;
                
                POL_EXCEPT_VIRTFUNCS(lsst::pex::policy::ValidationError)
                
                void ValidationError::_loadMessages() {
                    _errmsgs[OK] = EMPTY;
                    _errmsgs[WRONG_TYPE] = "value has the incorrect type";
                    _errmsgs[MISSING_REQUIRED] = "no value available for required parameter";
                    _errmsgs[NOT_AN_ARRAY] = "value is not an array as required";
                    _errmsgs[ARRAY_TOO_SHORT] = "insufficient number of array values";
                    _errmsgs[TOO_FEW_VALUES] = "not enough values for parameter";
                    _errmsgs[TOO_MANY_VALUES] = "too many values provided for parameter";
                    _errmsgs[WRONG_OCCURRENCE_COUNT]="incorrect number of values for parameter";
                    _errmsgs[VALUE_DISALLOWED] = "value is not among defined set";
                    _errmsgs[VALUE_OUT_OF_RANGE] = "value is out of range";
                    _errmsgs[BAD_VALUE] = "illegal value";
                    _errmsgs[UNKNOWN_NAME] = "parameter name is unknown";
                    _errmsgs[BAD_DEFINITION] = "malformed definition";
                    _errmsgs[NOT_LOADED] = "file not loaded"
                        " -- call Policy.loadPolicyFiles() before validating";
                    _errmsgs[UNKNOWN_ERROR] = "unknown error";
                }
                
                vector<string> ValidationError::getParamNames() const {
                    vector<string> result;
                    ParamLookup::const_iterator i;
                    for (i = _errors.begin(); i != _errors.end(); ++i)
                        result.push_back(i->first);
                    return result;
                }
                
                string ValidationError::describe(string prefix) const {
                    ostringstream os;
                    list<string> names;
                    paramNames(names);
                    for (list<string>::const_iterator i = names.begin(); i != names.end(); ++i)
                        os << prefix << *i << ": " 
                           << getErrorMessageFor((ErrorType)getErrors(*i)) << endl;
                    return os.str();
                }
                
                char const* ValidationError::what(void) const throw() {
                    // static to avoid memory issue -- but a concurrency problem?
                    // copied from pex/exceptions/src/Exception.cc
                    static string buffer;
                    ostringstream os;
                    int n = getParamCount();
                    os << "Validation error";
                    if (n == 1) os << " (1 error)";
                    else if (n > 1) os << " (" << getParamCount() << " errors)";
                    if (getParamCount() == 0)
                        os << ": no errors" << "\n";
                    else {
                        os << ": \n" << describe("  * ");
                    }
                    buffer = os.str();
                    return buffer.c_str();
                }
                
                ValidationError::~ValidationError() throw() { }
                
                ///////////////////////////////////////////////////////////
                //  Definition
                ///////////////////////////////////////////////////////////
                
                Definition::~Definition() { }
                
                Policy::ValueType Definition::_determineType() const {
                    if (_policy->isString(Dictionary::KW_TYPE)) {
                        const string& type = _policy->getString(Dictionary::KW_TYPE);
                        Policy::ValueType result;
                        try {
                            result = Policy::getTypeByName(type);
                        } catch(BadNameError&) {
                            throw LSST_EXCEPT
                                (DictionaryError, string("Unknown type: \"") + type + "\".");
                        }
                        if (result == Policy::FILE)
                            throw LSST_EXCEPT(DictionaryError, string("Illegal type: \"") + type
                                              + "\"; use \"" + Policy::typeName[Policy::POLICY]
                                              + "\" instead.");
                        else return result;
                    }
                    else if (_policy->exists(Dictionary::KW_TYPE)) {
                        throw LSST_EXCEPT
                            (DictionaryError, string("Expected string for \"type\"; found ") 
                             + _policy->getTypeName(Dictionary::KW_TYPE) + " instead.");
                    }
                
                    else return Policy::UNDEF;
                }
                    
                /**
                 * Return the semantic definition for the parameter, empty string if none is
                 * specified, or throw a TypeError if it is the wrong type.
                 */
                const string Definition::getDescription() const {
                    if (_policy->exists(Dictionary::KW_DESCRIPTION)) 
                        return _policy->getString(Dictionary::KW_DESCRIPTION);
                    else return "";
                }
                
                /**
                 * return the maximum number of occurrences allowed for this parameter, 
                 * or -1 if there is no limit.
                 */
                const int Definition::getMaxOccurs() const {
                    if (_policy->exists(Dictionary::KW_MAX_OCCUR))
                    return _policy->getInt(Dictionary::KW_MAX_OCCUR);
                    else return -1;
                }
                
                /**
                 * return the minimum number of occurrences allowed for this parameter.
                 * Zero is returned if a minimum is not specified.
                 */
                const int Definition::getMinOccurs() const {
                    if (_policy->exists(Dictionary::KW_MIN_OCCUR))
                    return _policy->getInt(Dictionary::KW_MIN_OCCUR);
                    else return 0;
                }
                
                
                /*
                 * the default value into the given policy
                 * @param policy   the policy object update
                 * @param withName the name to look for the value under.  This must be 
                 *                    a non-hierarchical name.
                 * @exception ValidationError if the value does not conform to this definition.
                 */
                void Definition::setDefaultIn(Policy& policy, const string& withName,
                                              ValidationError* errs) const 
                {
                    if (! _policy->exists("default")) return;
                /*
                    Policy::ValueType type = getType();
                    if (type == Policy::UNDEF) 
                        type = _policy->getValueType("default");
                */
                    Policy::ValueType type = _policy->getValueType("default");
                
                    if (type == Policy::BOOL) 
                        setDefaultIn<bool>(policy, withName, errs);
                    else if (type == Policy::INT)
                        setDefaultIn<int>(policy, withName, errs);
                    else if (type == Policy::DOUBLE)
                        setDefaultIn<double>(policy, withName, errs);
                    else if (type == Policy::STRING)
                        setDefaultIn<string>(policy, withName, errs);
                    else if (type == Policy::POLICY)
                        setDefaultIn<Policy::Ptr>(policy, withName, errs);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
204  <a href="#a938e0ae">a938e0ae</a> -     else throw LSST_EXCEPT(pexExcept::LogicErrorException,</div>
              ?                                                 ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
203  <a href="#826f6e19">826f6e19</a> +     else throw LSST_EXCEPT(pexExcept::LogicError,</div>
                                           string("Programmer Error: Unknown type for \"")
                                           + getPrefix() + withName + "\": "
                                           + Policy::typeName[getType()]);
                }
                
                /*
                 * confirm that a Policy parameter conforms to this definition
                 * @param policy   the policy object to inspect
                 * @param name     the name to look for the value under.  If not given
                 *                  the name set in this definition will be used.
                 * @exception ValidationError   if the value does not conform.  The message
                 *                 should explain why.
                 */
                void Definition::validate(const Policy& policy, const string& name,
                                          ValidationError *errs) const 
                { 
                    ValidationError ve(LSST_EXCEPT_HERE);
                    ValidationError *use = &ve;
                    if (errs != 0) use = errs;
                
                    if (! policy.exists(name)) {
                    if (getMinOccurs() > 0)
                        use->addError(getPrefix() + name, ValidationError::MISSING_REQUIRED);
                        return;
                    }
                
                    // What type is actually present in the policy?
                    Policy::ValueType type = policy.getValueType(name);
                
                    switch (type) {
                    case Policy::BOOL: 
                        validateBasic<bool>(name, policy, use);
                        break;
                
                    case Policy::INT:
                        validateBasic<int>(name, policy, use);
                        break;
                
                    case Policy::DOUBLE:
                        validateBasic<double>(name, policy, use);
                        break;
                
                    case Policy::STRING:
                        validateBasic<string>(name, policy, use);
                        break;
                
                    case Policy::POLICY:
                        validateBasic<Policy::ConstPtr>(name, policy, use);
                        validateRecurse(name, policy.getConstPolicyArray(name), use);
                        break;
                
                    case Policy::FILE:
                        use->addError(getPrefix() + name, ValidationError::NOT_LOADED);
                        break;
                
                    default:
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
261  <a href="#a938e0ae">a938e0ae</a> -         throw LSST_EXCEPT(pexExcept::LogicErrorException,</div>
              ?                                                ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
260  <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::LogicError,</div>
                                          string("Unknown type for \"") + getPrefix() + name 
                                          + "\": \"" + policy.getTypeName(name) + "\"");
                    }
                
                    if (errs == 0 && ve.getParamCount() > 0) throw ve;
                }
                
                /**
                 * Validate the number of values for a field. Used internally by the
                 * validate() functions. 
                 * @param name   the name of the parameter being checked
                 * @param count  the number of values this name actually has
                 * @param errs   report validation errors here
                 */
                void Definition::validateCount(const string& name, int count,
                                               ValidationError *errs) const {
                    int max = getMaxOccurs(); // -1 means no limit / undefined
                    if (max >= 0 && count > max) 
                        errs->addError(getPrefix() + name, ValidationError::TOO_MANY_VALUES);
                    if (count < getMinOccurs()) {
                        if (count == 0) 
                            errs->addError(getPrefix() + name, ValidationError::MISSING_REQUIRED);
                        else if (count == 1) 
                            errs->addError(getPrefix() + name, ValidationError::NOT_AN_ARRAY);
                        else 
                            errs->addError(getPrefix() + name, ValidationError::ARRAY_TOO_SHORT);
                    }
                }
                
                /**
                 * Stubs for validation template functions.  Always return true, which always
                 * failes validation tests.  In other words, any values of min or max for these
                 * types will cause a failure.
                 */
                bool operator<(const Policy& a, const Policy& b) { return true; }
                bool operator<(const Policy::ConstPtr& a, const Policy::ConstPtr& b) { return true; }
                bool operator<(const Policy::FilePtr& a, const Policy::FilePtr& b) { return true; }
                
                void Definition::validateRecurse(const string& name,
                                                 Policy::ConstPolicyPtrArray value,
                                                 ValidationError *errs) const
                {
                    for (Policy::ConstPolicyPtrArray::const_iterator i = value.begin();
                         i != value.end(); ++i) {
                        Policy::ConstPtr p = *i;
                        validateRecurse(name, *p, errs);
                    }
                }
                
                /* Validate a sub-policy using a sub-dictionary. */
                void Definition::validateRecurse(const string& name, const Policy& value,
                                                 ValidationError *errs) const
                {
                    if (!getType() == Policy::POLICY) // should have checked this at a higher level
                        throw LSST_EXCEPT
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
317  <a href="#a938e0ae">a938e0ae</a> -             (pexExcept::LogicErrorException, string("Wrong type: expected ") </div>
              ?                                   ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
316  <a href="#826f6e19">826f6e19</a> +             (pexExcept::LogicError, string("Wrong type: expected ") </div>
                             + Policy::typeName[Policy::POLICY] + " for " + getPrefix() + name 
                             + " but found " + getTypeName() + ". // recurse if we have a sub-definition");
                    // recurse if we have a sub-definition
                    else if (_policy->exists(Dictionary::KW_DICT)) {
                        if (!_policy->isPolicy(Dictionary::KW_DICT))
                            throw LSST_EXCEPT
                                (DictionaryError, string("Wrong type for ") + getPrefix() + name 
                                 + " \"" + Dictionary::KW_DICT + "\": expected Policy, but found " 
                                 + _policy->getTypeName(Dictionary::KW_DICT) + ".");
                        else {
                            Dictionary subdict(*(_policy->getPolicy(Dictionary::KW_DICT)));
                            subdict.setPrefix(_prefix + name + ".");
                            subdict.validate(value, errs);
                        }
                    }
                    // is there an unresolved link here?
                    else if (_policy->exists(Dictionary::KW_DICT_FILE)) {
                        throw LSST_EXCEPT
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
336  <a href="#a938e0ae">a938e0ae</a> -             (pexExcept::LogicErrorException, _prefix + name</div>
              ?                                   ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
335  <a href="#826f6e19">826f6e19</a> +             (pexExcept::LogicError, _prefix + name</div>
                             + "." + Dictionary::KW_DICT_FILE + " needs to be loaded with "
                             "Dictionary.loadPolicyFiles() before validating.");
                    }
                    // there's a policy type defined here, but no sub-definition (that is, no
                    // constraints -- it could be any policy), so anything is okay.
                    else { }
                }
                
                // TODO: integrate all checks into check() rather than having them in validate()
                template <class T>
                void Definition::validateBasic(const string& name, const T& value,
                                               int curcount, ValidationError *errs) const
                {
                    ValidationError ve(LSST_EXCEPT_HERE);
                    ValidationError *use = &ve;
                    if (errs != 0) use = errs;
                
                    // check if we're going to get too many
                    if (curcount >= 0) {
                        int maxOccurs = getMaxOccurs();
                        if (maxOccurs >= 0 && curcount + 1 > maxOccurs) 
                            use->addError(getPrefix() + name, ValidationError::TOO_MANY_VALUES);
                    }
                
                    if (getType() != Policy::UNDEF && getType() != Policy::getValueType<T>()) {
                        use->addError(getPrefix() + name, ValidationError::WRONG_TYPE);
                    }
                    else if (_policy->isPolicy(Dictionary::KW_ALLOWED)) {
                        Policy::PolicyPtrArray allowed
                            = _policy->getPolicyArray(Dictionary::KW_ALLOWED);
                
                        T min, max;
                        bool minFound = false, maxFound = false;
                        set<T> allvals;
                        // iterate over the keys inside the "allowed" sub-policy
                        for (Policy::PolicyPtrArray::const_iterator it = allowed.begin();
                             it != allowed.end(); ++it)
                        {
                            Policy::Ptr a = *it;
                            if (a->exists(Dictionary::KW_MIN)) {
                                if (minFound) {
                                    // Would like to catch this in Dictionary::check(), but that
                                    // would require some fancy type-based logic.
                                    throw LSST_EXCEPT
                                        (DictionaryError, 
                                         string("Min value for ") + getPrefix() + name
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
383  <a href="#a938e0ae">a938e0ae</a> -                          + " (" + lexical_cast<string>(min) </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
382  <a href="#ee5514fa">ee5514fa</a> +                          + " (" + boost::lexical_cast<string>(min) </div>
              ?                                   +++++++
                                         + ") already specified; additional value not allowed.");
                                }
                                try {
                                    min = a->getValue<T>(Dictionary::KW_MIN);
                                    minFound = true; // after min assign, in case of exceptions
                                } catch(TypeError& e) {
                                    throw LSST_EXCEPT
                                        (DictionaryError, 
                                         string("Wrong type for ") + getPrefix() + name 
                                         + " min value: expected " + getTypeName() + ", found " 
                                         + a->getTypeName(Dictionary::KW_MIN) + ".");
                                } catch(...) {
                                    throw;
                                }
                            }
                            if (a->exists(Dictionary::KW_MAX)) {
                                if (maxFound)
                                    throw LSST_EXCEPT
                                        (DictionaryError,
                                         string("Max value for ") + getPrefix() + name
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
404  <a href="#a938e0ae">a938e0ae</a> -                          + " (" + lexical_cast<string>(max) </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
403  <a href="#ee5514fa">ee5514fa</a> +                          + " (" + boost::lexical_cast<string>(max) </div>
              ?                                   +++++++
                                         + ") already specified; additional value not allowed.");
                                try {
                                    max = a->getValue<T>(Dictionary::KW_MAX);
                                    maxFound = true; // after max assign, in case of exceptions
                                } catch(TypeError& e) {
                                    throw LSST_EXCEPT
                                        (DictionaryError, 
                                         string("Wrong type for ") + getPrefix() + name 
                                         + " max value: expected " + getTypeName() + ", found " 
                                         + a->getTypeName(Dictionary::KW_MAX) + ".");
                                }
                            }
                            if (a->exists(Dictionary::KW_VALUE)) {
                                const T& value = a->getValue<T>(Dictionary::KW_VALUE);
                                
                                allvals.insert(value);
                                // allvals.insert(a->getValue<T>(Dictionary::KW_VALUE));
                                vector<T> values = a->getValueArray<T>(Dictionary::KW_VALUE);
                                for (typename vector<T>::const_iterator vi = values.begin();
                                     vi != values.end(); ++vi)
                                    allvals.insert(*vi);
                            }
                        }
                
                        if ((minFound && value < min) || (maxFound && max < value))
                            use->addError(getPrefix() + name, ValidationError::VALUE_OUT_OF_RANGE);
                
                        if (allvals.size() > 0 && allvals.count(value) == 0)
                            use->addError(getPrefix() + name, ValidationError::VALUE_DISALLOWED);
                    }
                    if (errs == 0 && ve.getParamCount() > 0) throw ve;
                }
                
                // instantiate to keep gcc 4.4 happy when compiling with opt=2
                // (why? -- see LSST Trac ticket #1253)
                template void Definition::validateBasic<Policy::Ptr>
                (std::string const &, Policy::Ptr const &, int, ValidationError*) const;
                
                /*
                 * confirm that a Policy parameter name-value combination is consistent 
                 * with this dictionary.  This does not check occurrence compliance
                 * @param name     the name of the parameter being checked
                 * @param value    the value of the parameter to check.
                 * @exception ValidationError   if the value does not conform.  The message
                 *                 should explain why.
                 */
                void Definition::validate(const string& name, bool value, int curcount,
                                          ValidationError *errs) const 
                { 
                    validateBasic<bool>(name, value, curcount, errs);
                }
                
                void Definition::validate(const string& name, int value, int curcount,
                                          ValidationError *errs) const 
                { 
                    validateBasic<int>(name, value, curcount, errs);
                }
                
                void Definition::validate(const string& name, double value, int curcount,
                                          ValidationError *errs) const 
                { 
                    validateBasic<double>(name, value, curcount, errs);
                }
                
                void Definition::validate(const string& name, string value, int curcount,
                                          ValidationError *errs) const 
                { 
                    validateBasic<string>(name, value, curcount, errs);
                }
                
                void Definition::validate(const string& name, const Policy& value, 
                                          int curcount, ValidationError *errs) const 
                { 
                    validateBasic<Policy>(name, value, curcount, errs);
                    validateRecurse(name, value, errs);
                }
                
                /*
                 * confirm that a Policy parameter name-array value combination is 
                 * consistent with this dictionary.  Unlike the scalar version, 
                 * this does check occurrence compliance.  
                 * @param name     the name of the parameter being checked
                 * @param value    the value of the parameter to check.
                 * @exception ValidationError   if the value does not conform.  The message
                 *                 should explain why.
                 */
                void Definition::validate(const string& name, const Policy::BoolArray& value, 
                                          ValidationError *errs) const 
                { 
                    validateBasic<bool>(name, value, errs);
                }
                
                void Definition::validate(const string& name, const Policy::IntArray& value, 
                                          ValidationError *errs) const 
                { 
                    validateBasic<int>(name, value, errs);
                }
                
                void Definition::validate(const string& name, const Policy::DoubleArray& value,
                                          ValidationError *errs) const 
                { 
                    validateBasic<double>(name, value, errs);
                }
                void Definition::validate(const string& name, const Policy::StringArray& value, 
                                          ValidationError *errs) const 
                { 
                    validateBasic<string>(name, value, errs);
                }
                
                void Definition::validate(const string& name, const Policy::ConstPolicyPtrArray& value, 
                                          ValidationError *errs) const 
                { 
                    validateBasic<Policy::ConstPtr>(name, value, errs);
                    validateRecurse(name, value, errs);
                }
                
                void Definition::check() const {
                    static set<string> okayKeywords;
                    if (okayKeywords.size() == 0) {
                        okayKeywords.insert(Dictionary::KW_TYPE);
                        okayKeywords.insert(Dictionary::KW_DICT);
                        okayKeywords.insert(Dictionary::KW_DICT_FILE);
                        okayKeywords.insert(Policy::typeName[Policy::FILE]);
                        okayKeywords.insert(Dictionary::KW_MIN_OCCUR);
                        okayKeywords.insert(Dictionary::KW_MAX_OCCUR);
                        okayKeywords.insert(Dictionary::KW_MIN);
                        okayKeywords.insert(Dictionary::KW_MAX);
                        okayKeywords.insert(Dictionary::KW_ALLOWED);
                        okayKeywords.insert(Dictionary::KW_DESCRIPTION);
                        okayKeywords.insert(Dictionary::KW_DEFAULT);
                    }
                    Policy::StringArray terms = _policy->names(true);
                    for (Policy::StringArray::const_iterator i = terms.begin();
                         i != terms.end(); ++i) 
                    {
                        if (okayKeywords.count(*i) == 1) continue;
                        else throw LSST_EXCEPT
                            (DictionaryError, string("Unknown Dictionary property found at ")
                             + _prefix + _name + ": " + *i);
                    }
                }
                
                ///////////////////////////////////////////////////////////
                //  Dictionary
                ///////////////////////////////////////////////////////////
                
                const char* Dictionary::KW_DICT = "dictionary";
                const char* Dictionary::KW_DICT_FILE = "dictionaryFile";
                const char* Dictionary::KW_TYPE = "type";
                const char* Dictionary::KW_DESCRIPTION = "description";
                const char* Dictionary::KW_DEFAULT = "default";
                const char* Dictionary::KW_DEFINITIONS = "definitions";
                const char* Dictionary::KW_CHILD_DEF = "childDefinition";
                const char* Dictionary::KW_ALLOWED = "allowed";
                const char* Dictionary::KW_MIN_OCCUR = "minOccurs";
                const char* Dictionary::KW_MAX_OCCUR = "maxOccurs";
                const char* Dictionary::KW_MIN = "min";
                const char* Dictionary::KW_MAX = "max";
                const char* Dictionary::KW_VALUE = "value";
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
565  <a href="#fe942aa6">fe942aa6</a> - const regex Dictionary::FIELDSEP_RE("\\.");</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
564  <a href="#ee5514fa">ee5514fa</a> + const boost::regex Dictionary::FIELDSEP_RE("\\.");</div>
              ?       +++++++
                
                /*
                 * load a dictionary from a file
                 */
                Dictionary::Dictionary(const char *filePath) : Policy(filePath) { 
                    if (!exists(KW_DEFINITIONS))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
572  <a href="#a938e0ae">a938e0ae</a> -         throw LSST_EXCEPT(pexExcept::RuntimeErrorException, string(filePath) </div>
              ?                                                  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
571  <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::RuntimeError, string(filePath) </div>
                                          + ": does not contain a Dictionary");
                    check();
                }
                Dictionary::Dictionary(const string& filePath) : Policy(filePath) { 
                    if (!exists(KW_DEFINITIONS))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
578  <a href="#a938e0ae">a938e0ae</a> -         throw LSST_EXCEPT(pexExcept::RuntimeErrorException, string(filePath) </div>
              ?                                                  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
577  <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::RuntimeError, string(filePath) </div>
                                          + ": does not contain a Dictionary");
                    check();
                }
                Dictionary::Dictionary(const PolicyFile& filePath) : Policy(filePath) { 
                    if (!exists(KW_DEFINITIONS))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
584  <a href="#a938e0ae">a938e0ae</a> -         throw LSST_EXCEPT(pexExcept::RuntimeErrorException, filePath.getPath() </div>
              ?                                                  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
583  <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::RuntimeError, filePath.getPath() </div>
                                          + ": does not contain a Dictionary");
                    check();
                }
                
                /*
                 * return a definition for the named parameter.  The caller is responsible
                 * for deleting the returned object.  This is slightly more efficient than
                 * getDef().
                 * @param name    the hierarchical name for the parameter
                 */
                Definition* Dictionary::makeDef(const string& name) const {
                    Policy *p = const_cast<Dictionary*>(this);
                    Policy::Ptr sp; // sub-policy
                
                    // split the name
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
600  <a href="#a938e0ae">a938e0ae</a> -     sregex_token_iterator it = make_regex_token_iterator(name, FIELDSEP_RE, -1);</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
599  <a href="#ee5514fa">ee5514fa</a> +     boost::sregex_token_iterator it = boost::make_regex_token_iterator(name, FIELDSEP_RE, -1);</div>
              ?     +++++++                           +++++++
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
601  <a href="#fe942aa6">fe942aa6</a> -     sregex_token_iterator end;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
600  <a href="#ee5514fa">ee5514fa</a> +     boost::sregex_token_iterator end;</div>
              ?     +++++++
                    string find;
                    bool isWildcard = false; // was the immediate parent a wildcard childDefinition?
                    while (it != end) {
                        find = *it;
                        if (! p->isPolicy(KW_DEFINITIONS))
                            throw LSST_EXCEPT(DictionaryError, "Definition for " + find 
                                              + " not found.");
                        sp = p->getPolicy(KW_DEFINITIONS);
                        if (sp->isPolicy(find)) {
                            sp = sp->getPolicy(find);
                            isWildcard = false; // update each time, to get only immediate parent
                        }
                        else if (sp->isPolicy(Dictionary::KW_CHILD_DEF)) {
                            if (sp->valueCount(Dictionary::KW_CHILD_DEF) > 1)
                                throw LSST_EXCEPT
                                    (DictionaryError, string("Multiple ") + KW_CHILD_DEF
                                     + "s found " + "that match " + getPrefix() + name + ".");
                            sp = sp->getPolicy(Dictionary::KW_CHILD_DEF);
                            isWildcard = true;
                        }
                        else throw LSST_EXCEPT(NameNotFound, find);
                        p = sp.get();
                        if (++it != end) {
                            if (! sp->isPolicy(Dictionary::KW_DICT))
                                throw LSST_EXCEPT(DictionaryError, 
                                                  find + "." + KW_DICT + " not found.");
                            sp = sp->getPolicy(Dictionary::KW_DICT);
                            p = sp.get();
                        }
                    }
                    Definition* result = new Definition(name, sp);
                    result->setWildcard(isWildcard);
                    result->setPrefix(getPrefix());
                    return result;
                }
                
                /**
                 * Return a branch of this dictionary, if this dictionary describes a
                 * complex policy structure -- that is, if it describes a policy with
                 * sub-policies.
                 */
                Policy::DictPtr Dictionary::getSubDictionary(const string& name) const {
                    string subname = string(KW_DEFINITIONS) + "." + name + ".dictionary";
                    if (!exists(subname)) throw LSST_EXCEPT
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
646  <a href="#a938e0ae">a938e0ae</a> -         (pexExcept::LogicErrorException,</div>
              ?                               ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
645  <a href="#826f6e19">826f6e19</a> +         (pexExcept::LogicError,</div>
                         string("sub-policy \"") + subname + "\" not found.");
                    if (!isPolicy(subname)) throw LSST_EXCEPT
                        (DictionaryError, subname + " is a " + getTypeName(subname) 
                         + " instead of a " + Policy::typeName[Policy::POLICY] + ".");
                    ConstPtr subpol = getPolicy(subname);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
652  <a href="#a938e0ae">a938e0ae</a> -     Policy::DictPtr result = make_shared<Dictionary>(*subpol);</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
651  <a href="#ee5514fa">ee5514fa</a> +     Policy::DictPtr result = boost::make_shared<Dictionary>(*subpol);</div>
              ?                              +++++++
                    result->setPrefix(_prefix + name + ".");
                    return result;
                }
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
657  <a href="#a938e0ae">a938e0ae</a> - int Dictionary::loadPolicyFiles(const fs::path& repository, bool strict) {</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
656  <a href="#ee5514fa">ee5514fa</a> + int Dictionary::loadPolicyFiles(const boost::filesystem::path& repository, bool strict) {</div>
              ?                                       +++++++ +++ +++++
                    int maxLevel = 16;
                    int result = 0;
                    // loop until we reach the leaves
                    for (int level = 0; level < maxLevel; ++level) {
                        // find the "dictionaryFile" parameters
                        list<string> params;
                        paramNames(params, false);
                        list<string> toRemove;
                        for (list<string>::const_iterator ni=params.begin(); ni != params.end(); ++ni) {
                        // loop over the keys that end with ".dictionaryFile"
                            static string endswith = string(".") + KW_DICT_FILE;
                            size_t p = ni->rfind(endswith);
                            if (p == ni->length()-endswith.length()) {
                                string parent = ni->substr(0, p);
                                Policy::Ptr defin = getPolicy(parent);
                                
                                // these will get dereferenced with the call to super method
                                if (isFile(*ni)) 
                                    defin->set(Dictionary::KW_DICT, getFile(*ni));
                                else
                                    defin->set(Dictionary::KW_DICT,
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
679  <a href="#a938e0ae">a938e0ae</a> -                                make_shared<PolicyFile>(getString(*ni)));</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
678  <a href="#ee5514fa">ee5514fa</a> +                                boost::make_shared<PolicyFile>(getString(*ni)));</div>
              ?                                +++++++
                                
                                toRemove.push_back(*ni);
                            }
                        }
                        
                        // if no new loads, then we've loaded everything
                        int newLoads = Policy::loadPolicyFiles(repository, strict);
                        
                        // remove obsolete dictionaryFile references, to prevent re-loading
                        for (list<string>::iterator i = toRemove.begin(); i != toRemove.end(); ++i)
                            remove(*i);
                
                        if (newLoads == 0) {
                        check(); // validate self after everything is loaded
                        return result;
                    }
                        else result += newLoads;
                    }
                    throw LSST_EXCEPT
                        (DictionaryError, string("Exceeded recursion limit (") 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
700  <a href="#a938e0ae">a938e0ae</a> -          + lexical_cast<string>(maxLevel) </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
699  <a href="#ee5514fa">ee5514fa</a> +          + boost::lexical_cast<string>(maxLevel) </div>
              ?            +++++++
                         + ") loading policy files; does this dictionary contain a circular"
                         " definition?");
                }
                
                /**
                 * Check this Dictionary's internal integrity.  Load up all definitions and
                 * sanity-check them.
                 */
                void Dictionary::check() const {
                    PolicyPtrArray defs = getValueArray<Policy::Ptr>(KW_DEFINITIONS);
                    if (defs.size() == 0)
                        throw LSST_EXCEPT(DictionaryError, 
                                          string("no \"") + KW_DEFINITIONS + "\" section found");
                    if (defs.size() > 1)
                        throw LSST_EXCEPT
                            (DictionaryError, string("expected a single \"") + KW_DEFINITIONS 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
717  <a href="#a938e0ae">a938e0ae</a> -              + "\" section; found " + lexical_cast<string>(defs.size()));</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
716  <a href="#ee5514fa">ee5514fa</a> +              + "\" section; found " + boost::lexical_cast<string>(defs.size()));</div>
              ?                                       +++++++
                
                    Policy::StringArray names = defs[0]->names(false);
                    for (Policy::StringArray::const_iterator i = names.begin();
                         i != names.end(); ++i)
                    {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
723  <a href="#a938e0ae">a938e0ae</a> -         scoped_ptr<Definition> def(makeDef(*i));</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
722  <a href="#ee5514fa">ee5514fa</a> +         boost::scoped_ptr<Definition> def(makeDef(*i));</div>
              ?         +++++++
                        def->check();
                
                        if (hasSubDictionary(*i)) {
                        // if the subdict is a policy file, skip it -- it will have to be
                        // checked later, when it is loaded
                        ConstPtr subPol = defs[0]->getPolicy(*i);
                        if (subPol->getValueType(KW_DICT) != Policy::FILE)
                        getSubDictionary(*i)->check();
                        // TODO: test that loading a subdict from a reference gets re-checked
                    }
                    }
                }
                
                /*
                 * validate a Policy against this Dictionary
                 */
                void Dictionary::validate(const Policy& pol, ValidationError *errs) const { 
                    ValidationError ve(LSST_EXCEPT_HERE);
                    ValidationError *use = &ve;
                    if (errs != 0) use = errs;
                    Policy::StringArray params = pol.names(true);
                
                    // validate each item in policy
                    for (Policy::StringArray::const_iterator i = params.begin();
                         i != params.end(); ++i) 
                    {
                        try {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
751  <a href="#a938e0ae">a938e0ae</a> -             scoped_ptr<Definition> def(makeDef(*i));</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
750  <a href="#ee5514fa">ee5514fa</a> +             boost::scoped_ptr<Definition> def(makeDef(*i));</div>
              ?             +++++++
                            def->validate(pol, *i, use);
                        }
                        catch (NameNotFound& e) {
                            use->addError(getPrefix() + *i, ValidationError::UNKNOWN_NAME);
                        }
                    }
                
                    // check definitions of missing elements for required elements
                    Policy::ConstPtr defs = getDefinitions();
                    Policy::StringArray dn = defs->names(false);
                    for (Policy::StringArray::const_iterator i = dn.begin(); i != dn.end(); ++i) {
                        const string& name = *i;
                        if (!pol.exists(name)) { // item in dictionary, but not in policy
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
765  <a href="#a938e0ae">a938e0ae</a> -             scoped_ptr<Definition> def(makeDef(name));</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
764  <a href="#ee5514fa">ee5514fa</a> +             boost::scoped_ptr<Definition> def(makeDef(name));</div>
              ?             +++++++
                            if (name != Dictionary::KW_CHILD_DEF && def->getMinOccurs() > 0)
                                use->addError(getPrefix() + name,
                                              ValidationError::MISSING_REQUIRED);
                        }
                    }
                
                    if (errs == 0 && ve.getParamCount() > 0) throw ve;
                }
                
                //@endcond
                
                } // namespace policy
                } // namespace pex
                } // namespace lsst
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="ffbde6ab"/></a>ffbde6ab</h3>

<pre>
commit ffbde6abe48212de8420148bd05e9ef2b5e96ffe
Author: smm <smm@git.lsstcorp.org>
Date:   Mon Nov 7 21:41:56 2011 +0000

    pex_policy Winter2012b: remove namespace aliases in headers, upgrade to swig 2.x
</pre>
<h3><a name="fe942aa6"/></a>fe942aa6</h3>

<pre>
commit fe942aa6404f6d03beb305112d8d76a33e49acbc
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Mar 27 07:09:12 2008 +0000

    Initial move of mwi/policy to pex/policy.
</pre>
<h3><a name="a938e0ae"/></a>a938e0ae</h3>

<pre>
commit a938e0ae6e04eb065113480c098a5e9f681a0bb9
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Nov 18 20:48:24 2009 +0000

    Merged revisions 10237-10239,10263,10278-10279,10318-10320,10332,10334-10336,10359,10383,10390,10439,10445-10446,10449,10469-10471,10485,10499-10501,10570,10572-10574,10581-10584,10617,10619-10623,10627,10674-10677,10691,10890,10918,10985-10986,11436-11438,11482,11489-11490 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/872
    
    ........
      r10237 | bbaker | 2009-07-24 13:40:06 -0500 (Fri, 24 Jul 2009) | 1 line
    
      add rough childDefinition definition
    ........
      r10238 | bbaker | 2009-07-24 13:40:33 -0500 (Fri, 24 Jul 2009) | 1 line
    
      rough list of validation tests, from examining the spec in Dictionary.h
    ........
      r10239 | bbaker | 2009-07-24 13:41:18 -0500 (Fri, 24 Jul 2009) | 1 line
    
      comment
    ........
      r10263 | bbaker | 2009-07-27 09:44:48 -0500 (Mon, 27 Jul 2009) | 1 line
    
      add details to list of tests
    ........
      r10278 | bbaker | 2009-07-29 15:00:10 -0500 (Wed, 29 Jul 2009) | 1 line
    
      typos
    ........
      r10279 | bbaker | 2009-07-29 15:00:41 -0500 (Wed, 29 Jul 2009) | 1 line
    
      add some missing fields
    ........
      r10318 | bbaker | 2009-07-31 18:16:01 -0500 (Fri, 31 Jul 2009) | 1 line
    
      primitive examples for development
    ........
      r10319 | bbaker | 2009-07-31 18:16:29 -0500 (Fri, 31 Jul 2009) | 1 line
    
      debugging validation
    ........
      r10320 | bbaker | 2009-07-31 18:17:06 -0500 (Fri, 31 Jul 2009) | 1 line
    
      placeholder
    ........
      r10332 | bbaker | 2009-08-04 11:03:53 -0500 (Tue, 04 Aug 2009) | 1 line
    
      correct typos; tweak constants
    ........
      r10334 | bbaker | 2009-08-04 11:40:31 -0500 (Tue, 04 Aug 2009) | 1 line
    
      fix unit test -- mixed types
    ........
      r10335 | bbaker | 2009-08-04 11:54:01 -0500 (Tue, 04 Aug 2009) | 1 line
    
      dictionary unit test stub
    ........
      r10336 | bbaker | 2009-08-04 13:00:11 -0500 (Tue, 04 Aug 2009) | 1 line
    
      move unit test files into tests; add simple validate
    ........
      r10359 | bbaker | 2009-08-05 17:33:18 -0500 (Wed, 05 Aug 2009) | 1 line
    
      rigorize dictionary type handling
    ........
      r10383 | bbaker | 2009-08-07 13:32:20 -0500 (Fri, 07 Aug 2009) | 1 line
    
      cleaning up values validation
    ........
      r10390 | bbaker | 2009-08-07 17:55:15 -0500 (Fri, 07 Aug 2009) | 1 line
    
      templates templates templates
    ........
      r10439 | bbaker | 2009-08-12 17:26:49 -0500 (Wed, 12 Aug 2009) | 1 line
    
      improve error messages, and other testing
    ........
      r10445 | bbaker | 2009-08-13 14:23:31 -0500 (Thu, 13 Aug 2009) | 1 line
    
      getTypeByName -- whew
    ........
      r10446 | bbaker | 2009-08-13 15:16:55 -0500 (Thu, 13 Aug 2009) | 1 line
    
      more dictionary integrity tests
    ........
      r10449 | bbaker | 2009-08-13 16:37:22 -0500 (Thu, 13 Aug 2009) | 1 line
    
      confirm that policy validation is only partial
    ........
      r10469 | bbaker | 2009-08-14 15:56:35 -0500 (Fri, 14 Aug 2009) | 1 line
    
      value validation
    ........
      r10470 | bbaker | 2009-08-14 15:57:51 -0500 (Fri, 14 Aug 2009) | 1 line
    
      remove finished TODO
    ........
      r10471 | bbaker | 2009-08-14 16:15:24 -0500 (Fri, 14 Aug 2009) | 1 line
    
      detect missing required items
    ........
      r10485 | bbaker | 2009-08-17 17:39:50 -0500 (Mon, 17 Aug 2009) | 1 line
    
      nested validation
    ........
      r10499 | bbaker | 2009-08-18 15:34:33 -0500 (Tue, 18 Aug 2009) | 1 line
    
      childDefinition implementation and tests
    ........
      r10500 | bbaker | 2009-08-18 16:19:48 -0500 (Tue, 18 Aug 2009) | 1 line
    
      comments
    ........
      r10501 | bbaker | 2009-08-18 16:22:02 -0500 (Tue, 18 Aug 2009) | 1 line
    
      TODOs
    ........
      r10570 | bbaker | 2009-09-01 18:06:33 -0500 (Tue, 01 Sep 2009) | 1 line
    
      more validation when loading from defaults
    ........
      r10572 | bbaker | 2009-09-01 21:58:01 -0500 (Tue, 01 Sep 2009) | 1 line
    
      quick emacs cmd
    ........
      r10573 | bbaker | 2009-09-01 22:22:45 -0500 (Tue, 01 Sep 2009) | 1 line
    
      obsolete
    ........
      r10574 | bbaker | 2009-09-01 22:23:08 -0500 (Tue, 01 Sep 2009) | 1 line
    
      validate on set/add -- step 1
    ........
      r10581 | bbaker | 2009-09-03 16:17:42 -0500 (Thu, 03 Sep 2009) | 1 line
    
      accessors for policy.dictionary, test policy self-validation
    ........
      r10582 | bbaker | 2009-09-03 16:22:51 -0500 (Thu, 03 Sep 2009) | 1 line
    
      more set/add tests
    ........
      r10583 | bbaker | 2009-09-03 16:23:40 -0500 (Thu, 03 Sep 2009) | 1 line
    
      comment
    ........
      r10584 | bbaker | 2009-09-03 16:25:31 -0500 (Thu, 03 Sep 2009) | 1 line
    
      oops, test failed
    ........
      r10617 | bbaker | 2009-09-11 15:27:09 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fixes related to nested dictionaries and policies
    ........
      r10619 | bbaker | 2009-09-11 16:09:40 -0500 (Fri, 11 Sep 2009) | 1 line
    
      remove debugging printouts, convert to constants instead of literal strings
    ........
      r10620 | bbaker | 2009-09-11 16:16:57 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fix spelling of EventTranmitter
    ........
      r10621 | bbaker | 2009-09-11 16:22:59 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test condensed dictionary syntax, update docs and TODOs
    ........
      r10622 | bbaker | 2009-09-11 16:24:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test without 'target' field in dictionary
    ........
      r10623 | bbaker | 2009-09-11 16:27:34 -0500 (Fri, 11 Sep 2009) | 1 line
    
      resolve TODO comments
    ........
      r10627 | bbaker | 2009-09-11 17:15:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      deep dictionary loading
    ........
      r10674 | bbaker | 2009-09-18 15:02:18 -0500 (Fri, 18 Sep 2009) | 1 line
    
      use boost::make_shared where possible
    ........
      r10675 | bbaker | 2009-09-18 15:07:03 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10676 | bbaker | 2009-09-18 15:07:42 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10677 | bbaker | 2009-09-18 17:39:14 -0500 (Fri, 18 Sep 2009) | 1 line
    
      working on validation script
    ........
      r10691 | bbaker | 2009-09-21 18:18:48 -0500 (Mon, 21 Sep 2009) | 1 line
    
      validation script for dictionary & policy authors
    ........
      r10890 | bbaker | 2009-10-06 12:22:53 -0500 (Tue, 06 Oct 2009) | 1 line
    
      uses of Policy C++ and Python interfaces
    ........
      r10918 | bbaker | 2009-10-07 13:09:45 -0500 (Wed, 07 Oct 2009) | 1 line
    
      hide certain swig warnings
    ........
      r10985 | bbaker | 2009-10-12 15:44:45 -0500 (Mon, 12 Oct 2009) | 1 line
    
      improve formatting
    ........
      r10986 | bbaker | 2009-10-12 15:46:30 -0500 (Mon, 12 Oct 2009) | 1 line
    
      list of policy files
    ........
      r11436 | bbaker | 2009-11-10 14:02:15 -0600 (Tue, 10 Nov 2009) | 1 line
    
      move validate.py test script into tests dir
    ........
      r11437 | bbaker | 2009-11-10 14:02:40 -0600 (Tue, 10 Nov 2009) | 1 line
    
      reference to --help
    ........
      r11438 | bbaker | 2009-11-10 14:03:28 -0600 (Tue, 10 Nov 2009) | 1 line
    
      pex_policy: add options to mergeDefaults to validate and to keep dictionary
    ........
      r11482 | bbaker | 2009-11-17 15:40:53 -0600 (Tue, 17 Nov 2009) | 1 line
    
      more mergeDefaults -- deep Policy merge
    ........
      r11489 | bbaker | 2009-11-18 12:43:19 -0600 (Wed, 18 Nov 2009) | 1 line
    
      improve standards compliance
    ........
      r11490 | bbaker | 2009-11-18 12:50:15 -0600 (Wed, 18 Nov 2009) | 1 line
    
      more standards compliance
    ........
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="ee5514fa"/></a>ee5514fa</h3>

<pre>
commit ee5514fa5d7a617852989cad29f00ff7f7f9f0dc
Author: Russell Owen <rowen@uw.edu>
Date:   Mon Mar 23 20:28:18 2015 -0700

    Eliminate "using namespace boost" from Dictionary.cc
    
    Dictionary.cc has "using namespace std" and "using namespace boost"
    and there were conflicts with C++11 and boost 1.57,
    so eliminate "using namespace boost".
    
    Fix namespace
    
    Remove leading :: from boost
</pre>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_36"><a name="tests/testBigBool.py"/></a>tests/testBigBool.py</h1>

<h3 id="toc_37">Diff:</h3>

<pre>
                #!/usr/bin/env python
                
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                """
                Comprehensive tests reading and retrieving data of all types
                """
                import pdb                              # we may want to say pdb.set_trace()
                import os
                import sys
                import unittest
                import time
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
34   <a href="#a03a626c">a03a626c</a> + import lsst.utils</div>
                from lsst.pex.policy import Policy
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
36   <a href="#2b0dcf74">2b0dcf74</a> - proddir = os.environ["PEX_POLICY_DIR"]</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
37   <a href="#a03a626c">a03a626c</a> + proddir = lsst.utils.getPackageDir('pex_policy')</div>
                
                class BigBoolTestCase(unittest.TestCase):
                
                    def setUp(self):
                        self.policy = Policy()
                
                    def tearDown(self):
                        del self.policy
                        
                    def testBigBoolArray(self):
                        biglen = 1000
                        self.policy.isBool("true")
                        for i in xrange(biglen):
                            self.policy.add("true", True)
                
                        v = self.policy.getArray("true")
                        self.assertEquals(len(v), biglen,"wrong big number of values in array")
                        for i in xrange(biglen):
                            self.assert_(v[i], "big array with bad value")
                
                        del v
                        self.assert_(True, "Blew up True")
                
                        fd = open("/dev/null", "w")
                        print >> fd, "look: %s" % True
                        fd.close()
                
                        
                
                __all__ = "BigBoolTestCase".split()        
                
                if __name__ == "__main__":
                    unittest.main()
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="2b0dcf74"/></a>2b0dcf74</h3>

<pre>
commit 2b0dcf74481ab92282073580edaa45795d11f955
Author: rplante <rplante@git.lsstcorp.org>
Date:   Mon Jan 10 19:47:51 2011 +0000

    #1544: bug fix getArray() for bools segfaults; added test that confirms/verifies
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="a03a626c"/></a>a03a626c</h3>

<pre>
commit a03a626ca159348edad2d2d5b0809dfd7d8d1a36
Author: Joshua Hoblitt <josh@hoblitt.com>
Date:   Fri May 22 15:11:15 2015 -0700

    replace eups.productDir() calls with lsst.utils.getPackageDir()
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_38"><a name="include/lsst/pex/policy/DefaultPolicyFile.h"/></a>include/lsst/pex/policy/DefaultPolicyFile.h</h1>

<h3 id="toc_39">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * @file DefaultPolicyFile.h
                 * 
                 * @ingroup pex
                 *
                 * @brief the definition of the DefaultPolicyFile class
                 * 
                 * @author Ray Plante
                 * 
                 */
                
                #ifndef LSST_PEX_POLICY_DEFAULTPOLICYFILE_H
                #define LSST_PEX_POLICY_DEFAULTPOLICYFILE_H
                
                #include "lsst/pex/policy/PolicyFile.h"
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                /**
                 * @brief a representation of a default Policy file that is stored as a 
                 * file in the installation directory of an LSST product.  
                 *
                 * An instance is constructed from a product name, a relative path 
                 * to a subdirectory representing a policy repository within the installed 
                 * package, and a relative file path.  To construct the full path to the 
                 * file, the constructor looks for an environment variable of the form, 
                 * PRODUCTNAME_DIR (where PRODUCTNAME is the given package name converted 
                 * to all upper case) which names the directory where the product is 
                 * installed.  The full path, then, is the product installation directory
                 * concatonated with the repository directory, followed by the file path.
                 *
                 * The policy file can reference other files; these will be automatically 
                 * opened and loaded when load() is called.  The paths stored in the policy 
                 * files must be relative to the repository subdirectory within the product
                 * installation directory.  
                 *
                 * This class is the recommended PolicySource type to return in the 
                 * PolicyConfigured interface's getDefaultPolicySource().  
                 *
                 * This class can be subclassed to provide a different implementation of 
                 * determining the installation directory by overriding getInstallPath().
                 */
                class DefaultPolicyFile : public PolicyFile {
                public:
                
                    /**
                     * define a default policy file
                     * @param productName    the name of the product that the default 
                     *                         policy is installed as part of
                     * @param filepath       the relative pathname to the policy file.  
                     * @param repos          the subdirectory with the product's install
                     *                         directory where policy files are stored.
                     *                         If an empty string (default), the filepath
                     *                         argument is relative to the installation
                     *                         directory.
                     * @param strict         if true (default), load() will throw an exception
                     *                         if it encounters recoverable parsing errors in
                     *                         the underlying file (or any of the files it
                     *                         references).  Otherwise, the loaded Policy will
                     *                         be incomplete.  This is identical to the strict
                     *                         argument to Policy's loadPolicyFiles().  
                     */
                    DefaultPolicyFile(const char* const productName, 
                                      const std::string& filepath,
                                      const std::string& repos="",
                                      bool strict=true);
                
                    /**
                     * return the file path to the installation directory of a given
                     * named product.  This implementation uses the implementation 
                     * provided by DefaultPolicyFile::installPathFor().
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
98   <a href="#dcd1814e">dcd1814e</a> -      * @exception lsst::pex::exception::NotFoundException  if the </div>
              ?                                                  ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
98   <a href="#826f6e19">826f6e19</a> +      * @exception lsst::pex::exception::NotFoundError  if the </div>
              ?                                                  ^^ ^
                     *    environement variable is not defined.
                     */
                    virtual boost::filesystem::path getInstallPath(const char* const productName);
                
                    /**
                     * return the full file path to the repository directory where this
                     * file will found.  
                     */
                    const boost::filesystem::path& getRepositoryPath() const { return _repos; }
                
                    /**
                     * return the file path to the installation directory of a given
                     * named product.  In this implementation, the installation directory 
                     * will be taken from the value of an environment variable 
                     * PRODUCTNAME_DIR where PRODUCTNAME is the given name of the product 
                     * with all letters converted to upper case.  
                     */
                    static boost::filesystem::path installPathFor(const char* const productName);
                        
                
                    /**
                     * load the data from this Policy source into a Policy object.  This
                     * implementation will automatically de-reference any file include
                     * directives in the policy file.  
                     * @param policy    the policy object to load the data into
                     * @exception ParserException  if an error occurs while parsing the data
                     * @exception IOError   if an I/O error occurs while reading from the 
                     *                       source stream.
                     */
                    virtual void load(Policy& policy) const;
                
                private:
                    boost::filesystem::path _repos;
                    bool _strict;
                };
                
                }}}  // end namespace lsst::pex::policy
                
                
                
                #endif
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="dcd1814e"/></a>dcd1814e</h3>

<pre>
commit dcd1814ef4726014e169971f2141ca2b35de70dc
Author: rplante <rplante@git.lsstcorp.org>
Date:   Fri Feb 27 23:24:12 2009 +0000

    Primarily updated for use of PropertySet
    Cleaned up use of "using"
    bug fix: add workaround to swig bug to support bool types
    improve exception handling
    improve test scripts (explicitly test all types)
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_40"><a name="ups/pex_policy.table"/></a>ups/pex_policy.table</h1>

<h3 id="toc_41">Diff:</h3>

<pre>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1    <a href="#c4ee389d">c4ee389d</a> - setupRequired(daf_base >= 4.7.3.0)</div>
              ?                       -----------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1    <a href="#8a9a641c">8a9a641c</a> + setupRequired(daf_base)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
2    <a href="#a03a626c">a03a626c</a> + setupRequired(utils)</div>
                
                envPrepend(LD_LIBRARY_PATH, ${PRODUCT_DIR}/lib)
                envPrepend(DYLD_LIBRARY_PATH, ${PRODUCT_DIR}/lib)
                
                envPrepend(PYTHONPATH, ${PRODUCT_DIR}/python)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
7    <a href="#17f8b31d">17f8b31d</a> - envAppend(PATH, ${PRODUCT_DIR}/bin)</div>
              ?    ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
8    <a href="#3309cbc1">3309cbc1</a> + envPrepend(PATH, ${PRODUCT_DIR}/bin)</div>
              ?    ^^^
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="17f8b31d"/></a>17f8b31d</h3>

<pre>
commit 17f8b31d9e6c65fac6c36b4ea0ab2902f3f651d8
Author: rplante <rplante@git.lsstcorp.org>
Date:   Fri Apr 9 20:01:18 2010 +0000

    add bin to PATH; make validate.py executable; added PolicyString.h to policy.h
</pre>
<h3><a name="c4ee389d"/></a>c4ee389d</h3>

<pre>
commit c4ee389da652d88404e110c661f6a75e82ff361c
Author: Serge Monkewitz <smm@ipac.caltech.edu>
Date:   Tue Dec 13 07:39:37 2011 -0600

    Adjust table file
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="8a9a641c"/></a>8a9a641c</h3>

<pre>
commit 8a9a641c69af9b4f2326188341aa46fd0e3e181f
Author: Mario Juric <mjuric@lsst.org>
Date:   Wed Mar 5 16:29:33 2014 -0600

    removed explicit versions from the table file.
</pre>
<h3><a name="3309cbc1"/></a>3309cbc1</h3>

<pre>
commit 3309cbc1b33c08717aeb9b29a8d5f468b5125827
Author: Robyn Allsman <robyn@LSST.org>
Date:   Fri Nov 14 21:15:27 2014 -0600

    Replace envAppend with envPrepend in ups table files.
</pre>
<h3><a name="a03a626c"/></a>a03a626c</h3>

<pre>
commit a03a626ca159348edad2d2d5b0809dfd7d8d1a36
Author: Joshua Hoblitt <josh@hoblitt.com>
Date:   Fri May 22 15:11:15 2015 -0700

    replace eups.productDir() calls with lsst.utils.getPackageDir()
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_42"><a name="tests/Dictionary_1.py"/></a>tests/Dictionary_1.py</h1>

<h3 id="toc_43">Diff:</h3>

<pre>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1    <a href="#0050b976">0050b976</a> + #!/usr/bin/env python</div>
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                import os
                import unittest
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
25   <a href="#95441d27">95441d27</a> - import eups</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
26   <a href="#a03a626c">a03a626c</a> + import lsst.utils</div>
                #import inspect
                
                import lsst.utils.tests as tests
                
                from lsst.pex.policy import Policy, Dictionary, PolicyFile, DefaultPolicyFile
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
31   <a href="#a938e0ae">a938e0ae</a> - from lsst.pex.policy import ValidationError #, DictionaryError</div>
              ?                                            --
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
32   <a href="#0050b976">0050b976</a> + from lsst.pex.policy import ValidationError, DictionaryError</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
32   <a href="#a938e0ae">a938e0ae</a> - from lsst.pex.exceptions import LsstCppException</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
33   <a href="#0050b976">0050b976</a> + import lsst.pex.exceptions</div>
                
                #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                
                class DictionaryTestCase(unittest.TestCase):
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
38   <a href="#0050b976">0050b976</a> + </div>
                    def assertRaiseLCE(self, excClass, excMsg, callableObj, failMsg, *args, **kwargs):
                        """
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
39   <a href="#a938e0ae">a938e0ae</a> -         Expect callableObj(args, kwargs) to raise an LsstCppException that wraps</div>
              ?                                                      ^^^^^^^^          ^ ------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
41   <a href="#0050b976">0050b976</a> +         Expect callableObj(args, kwargs) to raise an exception of type excClass,</div>
              ?                                                      ^         +++ ^^^^^^^^^  ++
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
42   <a href="#0050b976">0050b976</a> +         and carres a message that contains excMsg.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
40   <a href="#a938e0ae">a938e0ae</a> -         the class specified by excClass, and carrying a message that contains</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
41   <a href="#a938e0ae">a938e0ae</a> -         excMsg.</div>
                
                        excClass: the subclass of LsstCppException we expect to see
                        excMsg: a substring of the message it should carry
                        callableObj: the thing that, when called, should raise an exception
                        failMsg: the assertion message if this fails
                        args, kwargs (optional): arguments to pass to callableObj
                        """
                        try:
                            callableObj(*args, **kwargs)
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
52   <a href="#0050b976">0050b976</a> +         except excClass as e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
51   <a href="#a938e0ae">a938e0ae</a> -         except LsstCppException, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
52   <a href="#a938e0ae">a938e0ae</a> -             self.assert_(isinstance(e, LsstCppException))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
53   <a href="#a938e0ae">a938e0ae</a> -             lce = "lsst.pex.exceptions.exceptionsLib.LsstCppException"</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
54   <a href="#a938e0ae">a938e0ae</a> -             self.assert_(str(e.__class__).find(lce) > 0,</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#a938e0ae">a938e0ae</a> -                          failMsg + ": expected an " + lce + ", found a " </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
56   <a href="#a938e0ae">a938e0ae</a> -                          + str(e.__class__))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
57   <a href="#a938e0ae">a938e0ae</a> -             self.assert_(len(e.args) == 1)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
58   <a href="#a938e0ae">a938e0ae</a> -             nested = e.args[0] # the real exception that was thrown</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
59   <a href="#a938e0ae">a938e0ae</a> - #            print "%%% wrapped exception is ", nested</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
60   <a href="#a938e0ae">a938e0ae</a> - #            print "  % class is ", nested.__class__</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
61   <a href="#a938e0ae">a938e0ae</a> -             self.assert_(str(nested.__class__).find(excClass) > 0,</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
62   <a href="#a938e0ae">a938e0ae</a> -                          failMsg + ": expected a " + excClass + "; found a " </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
63   <a href="#a938e0ae">a938e0ae</a> -                          + str(nested.__class__))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
64   <a href="#a938e0ae">a938e0ae</a> -             self.assert_(str(e).find(excMsg) > 0, </div>
              ?                                                  -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
53   <a href="#0050b976">0050b976</a> +             self.assert_(str(e).find(excMsg) > 0,</div>
                                         failMsg + ": expected to see the message \"" + excMsg 
                                         + "\"; actual message was \"" + str(e) + "\".")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
67   <a href="#a938e0ae">a938e0ae</a> - #            print " -%%% e = ", e</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
68   <a href="#a938e0ae">a938e0ae</a> - #            print "    % members of e: ", dir(e)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
69   <a href="#a938e0ae">a938e0ae</a> - #            print "    % members of len(e.args): ", len(e.args)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
70   <a href="#a938e0ae">a938e0ae</a> - #            print "    % members of e.args.args[0]: ", inspect.getmembers(e.args[0])</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
71   <a href="#a938e0ae">a938e0ae</a> - #            print "    % inspect(e): ", inspect.getmembers(e)</div>
                        else:
                            self.fail(failMsg + ": did not raise " + excClass)
                
                    def assertValidationError(self, errorCode, callableObj, field, value):
                        try:
                            callableObj(field, value)
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
62   <a href="#0050b976">0050b976</a> +         except ValidationError as e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
78   <a href="#0c37b98e">0c37b98e</a> -         except LsstCppException, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
79   <a href="#0c37b98e">0c37b98e</a> -             ve = e.args[0]</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
80   <a href="#0c37b98e">0c37b98e</a> -             self.assert_(ve.getErrors(field) == errorCode)</div>
              ?                        ^ -                  ^^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
63   <a href="#0050b976">0050b976</a> +             self.assertEqual(e.getErrors(field), errorCode)</div>
              ?                        ^^^^^                   ^
                
                    testDictDir = None
                    def getTestDictionary(self, filename=None):
                        if not self.testDictDir:
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
85   <a href="#0c37b98e">0c37b98e</a> -             self.testDictDir = os.path.join(eups.productDir("pex_policy"),</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
86   <a href="#0c37b98e">0c37b98e</a> -                                                   "tests", "dictionary")</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
68   <a href="#a03a626c">a03a626c</a> +             pexPolicyDir = lsst.utils.getPackageDir('pex_policy')</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
69   <a href="#a03a626c">a03a626c</a> +             self.testDictDir = os.path.join(pexPolicyDir, "tests", "dictionary")</div>
                        return os.path.join(self.testDictDir, filename) if filename else self.testDictDir
                
                    def testDictionaryLoad(self):
                        d = Dictionary()
                        df = PolicyFile(self.getTestDictionary("simple_dictionary.paf"))
                        self.assert_(not d.isDictionary(), "false positive dictionary")
                        df.load(d)
                        self.assert_(d.isDictionary(), "failed to recognize a dictionary")
                
                    def testBadDictionary(self):
                        d = Dictionary(self.getTestDictionary("dictionary_bad_policyfile.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
98   <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError", "Illegal type: \"PolicyFile\"",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
81   <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "Illegal type: \"PolicyFile\"",</div>
                                            d.makeDef("file_type").getType,
                                            "Dictionary specified PolicyFile type")
                
                        d = Dictionary(self.getTestDictionary("dictionary_bad_unknown_type.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
103  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError", "Unknown type: \"NotAType\"",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
86   <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "Unknown type: \"NotAType\"",</div>
                                            d.makeDef("something").getType,
                                            "Dictionary specifies unknown types")
                
                        d = Dictionary(self.getTestDictionary("dictionary_bad_type_type.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
108  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError", "Expected string",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
91   <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "Expected string",</div>
                                            d.makeDef("something").getType,
                                            "Expected string \"type\" type")
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
112  <a href="#1a677e93">1a677e93</a> -         self.assertRaiseLCE("DictionaryError", "property found at bad: min_occurs",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
95   <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "property found at bad: min_occurs",</div>
                                            Dictionary,
                                            "Dictionary has mispelled keyword \"min_occurs\".",
                                            self.getTestDictionary("dictionary_bad_keyword.paf"))
                
                        dbmd = self.getTestDictionary("dictionary_bad_multiple_definitions.paf")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
118  <a href="#1a677e93">1a677e93</a> -         self.assertRaiseLCE("DictionaryError", "expected a single",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
101  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "expected a single",</div>
                                            Dictionary,
                                            "Dictionary has two 'definitions' sections",
                                            dbmd)
                
                        p = Policy(self.getTestDictionary("values_policy_good_1.paf"))
                        d = Dictionary(self.getTestDictionary("dictionary_bad_multiple_min.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
125  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError", "Min value for int_ra", d.validate,</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
108  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "Min value for int_ra", d.validate,</div>
                                            "Two mins specified.", p)
                        d = Dictionary(self.getTestDictionary("dictionary_bad_multiple_max.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
128  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError", "Max value for int_ra", d.validate,</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "Max value for int_ra", d.validate,</div>
                                            "Two maxes specified.", p)
                        d = Dictionary(self.getTestDictionary("dictionary_bad_min_wrong_type.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
131  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError,</div>
                                            "Wrong type for int_range_count_type min",
                                            d.validate, "Wrong min type.", p)
                        d = Dictionary(self.getTestDictionary("dictionary_bad_max_wrong_type.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
135  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
118  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError,</div>
                                            "Wrong type for int_range_count_type max",
                                            d.validate, "Wrong max type.", p)
                
                        # conflict between minOccurs and maxOccurs
                        d = Dictionary(self.getTestDictionary("conflict_occurs_dictionary.paf"))
                        p = Policy(self.getTestDictionary("conflict_occurs_policy_1.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testBadDictionary")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
143  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
126  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("1to0") == ValidationError.TOO_MANY_VALUES)
                        self.assert_(ve.getErrors("2to1") == ValidationError.NOT_AN_ARRAY)
                        self.assert_(ve.getParamCount() == 2)
                        p = Policy(self.getTestDictionary("conflict_occurs_policy_2.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testBadDictionary")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
149  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
132  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("1to0") == ValidationError.MISSING_REQUIRED)
                        self.assert_(ve.getErrors("2to1") == ValidationError.TOO_MANY_VALUES)
                        self.assert_(ve.getParamCount() == 2)
                
                    def testSimpleValidate(self):
                        d = Dictionary(self.getTestDictionary("simple_dictionary.paf"))
                        p = Policy(self.getTestDictionary("simple_policy.paf"))
                        ve = ValidationError("Dictionary_1.py", 0, "testSimpleValidate")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
158  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
141  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("name") == 0, "no errors in name")
                        self.assert_(ve.getErrors("height") == 0, "no errors in height")
                        self.assert_(ve.getErrors() == 0, "no errors overall")
                
                    def testTypeValidation(self):
                        d = Dictionary(self.getTestDictionary("types_dictionary.paf"))
                        self.assert_(d.makeDef("undef_type") .getType() == Policy.UNDEF,
                                     "UNDEF definition type")
                        self.assert_(d.makeDef("bool_type")  .getType() == Policy.BOOL,
                                     "BOOL definition type")
                        self.assert_(d.makeDef("int_type")   .getType() == Policy.INT,
                                     "INT definition type")
                        self.assert_(d.makeDef("double_type").getType() == Policy.DOUBLE,
                                     "DOUBLE definition type")
                        self.assert_(d.makeDef("string_type").getType() == Policy.STRING,
                                     "STRING definition type")
                        self.assert_(d.makeDef("policy_type").getType() == Policy.POLICY,
                                     "POLICY definition type")
                        self.assert_(d.makeDef("file_type").getType() == Policy.POLICY,
                                     "POLICY definition type (substituted for PolicyFile)")
                
                        p = Policy(self.getTestDictionary("types_policy_good.paf"))
                
                        ve = ValidationError("Dictionary_1.py", 0, "testTypeValidation")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
183  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
166  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("file_type") == ValidationError.NOT_LOADED,
                                     "require loadPolicyFiles before validating")
                        self.assert_(ve.getErrors("undef_file") == ValidationError.NOT_LOADED,
                                     "require loadPolicyFiles before validating")
                        self.assert_(ve.getErrors() == ValidationError.NOT_LOADED, "no other errors")
                        self.assert_(ve.getParamCount() == 2, "no other errors")
                
                        p.loadPolicyFiles(self.getTestDictionary(), True)
                        ve = ValidationError("Dictionary_1.py", 0, "testTypeValidation")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
193  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
176  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                
                        self.assert_(ve.getErrors("undef_type")  == 0, "no errors with undef")
                        self.assert_(ve.getErrors("int_type")    == 0, "no errors with int")
                        self.assert_(ve.getErrors("double_type") == 0, "no errors with double")
                        self.assert_(ve.getErrors("bool_type")   == 0, "no errors with bool")
                        self.assert_(ve.getErrors("string_type") == 0, "no errors with string")
                        self.assert_(ve.getErrors("policy_type") == 0, "no errors with policy")
                        self.assert_(ve.getErrors("file_type")   == 0, "no errors with file")
                        self.assert_(ve.getErrors() == 0, "no errors overall")
                
                    def testWrongType(self):
                        d = Dictionary(self.getTestDictionary("types_dictionary.paf"))
                
                        p = Policy(self.getTestDictionary("types_policy_bad_bool.paf"))
                        ve = ValidationError("Dictionary_1.py", 0, "testWrongType")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
209  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
192  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors() == ValidationError.WRONG_TYPE, "wrong type")
                        self.assert_(ve.getParamCount() == 5, "number of errors")
                        self.assert_(ve.getErrors("bool_type") == 0, "correct type")
                        
                        p = Policy(self.getTestDictionary("types_policy_bad_int.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testWrongType")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
216  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
199  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors() == ValidationError.WRONG_TYPE, "wrong type")
                        self.assert_(ve.getParamCount() == 5, "number of errors")
                        self.assert_(ve.getErrors("int_type") == 0, "correct type")
                        self.assert_(ve.getErrors("double_type") == ValidationError.WRONG_TYPE,
                                     "int can't pass as double")
                        
                        p = Policy(self.getTestDictionary("types_policy_bad_double.paf"))
                        ve = ValidationError("Dictionary_1.py", 2, "testWrongType")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
225  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
208  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors() == ValidationError.WRONG_TYPE, "wrong type")
                        self.assert_(ve.getParamCount() == 5, "number of errors")
                        self.assert_(ve.getErrors("double_type") == 0, "correct type")
                
                        p = Policy(self.getTestDictionary("types_policy_bad_string.paf"))
                        ve = ValidationError("Dictionary_1.py", 3, "testWrongType")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
232  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
215  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors() == ValidationError.WRONG_TYPE, "wrong type")
                        self.assert_(ve.getParamCount() == 5, "number of errors")
                        self.assert_(ve.getErrors("string_type") == 0, "correct type")
                
                        p = Policy(self.getTestDictionary("types_policy_bad_policy.paf"))
                        ve = ValidationError("Dictionary_1.py", 4, "testWrongType")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
239  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
222  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors() == ValidationError.WRONG_TYPE, "wrong type")
                        self.assert_(ve.getParamCount() == 4, "number of errors")
                        self.assert_(ve.getErrors("policy_type") == 0, "correct type")
                        self.assert_(ve.getErrors("file_type") == 0, "correct type")
                
                        p = Policy(self.getTestDictionary("types_policy_bad_file.paf"))
                        ve = ValidationError("Dictionary_1.py", 5, "testWrongType")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
247  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
230  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors() == ValidationError.NOT_LOADED, "not loaded")
                        self.assert_(ve.getParamCount() == 6, "number of errors")
                        self.assert_(ve.getErrors("bool_type") == ValidationError.NOT_LOADED,
                                     "not loaded")
                        self.assert_(ve.getErrors("file_type") == ValidationError.NOT_LOADED,
                                     "not loaded")
                        self.assert_(ve.getErrors("policy_type") == ValidationError.NOT_LOADED,
                                     "not loaded")
                        p.loadPolicyFiles(self.getTestDictionary(), True)
                        ve = ValidationError("Dictionary_1.py", 6, "testWrongType")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
258  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
241  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors() == ValidationError.WRONG_TYPE, "wrong type")
                        self.assert_(ve.getErrors("file_type") == 0, "correct type")
                        self.assert_(ve.getErrors("policy_type") == 0, "correct type")
                        self.assert_(ve.getParamCount() == 4, "wrong type")
                
                    def testValues(self):
                        d = Dictionary(self.getTestDictionary("values_dictionary.paf"))
                        d.check()
                        p = Policy(self.getTestDictionary("values_policy_good_1.paf"))
                        ve = ValidationError("Dictionary_1.py", 0, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
269  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
252  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getParamCount() == 0)
                
                        # policy: disallow allowed, min, max
                        p = Policy(self.getTestDictionary("values_policy_bad_policy_set.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
275  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
258  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("policy_set_type") 
                                     == ValidationError.VALUE_DISALLOWED)
                        p = Policy(self.getTestDictionary("values_policy_bad_policy_max.paf"))
                        ve = ValidationError("Dictionary_1.py", 2, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
280  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
263  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("policy_max_type") 
                                     == ValidationError.VALUE_OUT_OF_RANGE)
                        p = Policy(self.getTestDictionary("values_policy_bad_policy_min.paf"))
                        ve = ValidationError("Dictionary_1.py", 3, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
285  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
268  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("policy_min_type") 
                                     == ValidationError.VALUE_OUT_OF_RANGE)
                
                        # minOccurs/maxOccurs
                        p = Policy(self.getTestDictionary("values_policy_bad_occurs.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
292  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
275  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getParamCount() == 6)
                        self.assert_(ve.getErrors("bool_set_count_type")
                                    == ValidationError.TOO_MANY_VALUES)
                        self.assert_(ve.getErrors("int_range_count_type")
                                    == ValidationError.MISSING_REQUIRED)
                        self.assert_(ve.getErrors("double_range_count_type")
                                    == ValidationError.TOO_MANY_VALUES)
                        self.assert_(ve.getErrors("string_count_type")
                                    == ValidationError.ARRAY_TOO_SHORT)
                        self.assert_(ve.getErrors("disallowed")
                                    == ValidationError.TOO_MANY_VALUES)
                        self.assert_(ve.getErrors("policy_count_type")
                                    == ValidationError.TOO_MANY_VALUES)
                
                        # min
                        p = Policy(self.getTestDictionary("values_policy_bad_min.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
310  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
293  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getParamCount() == 4)
                        self.assert_(ve.getErrors() == ValidationError.VALUE_OUT_OF_RANGE)
                        self.assert_(ve.getErrors("string_count_type") == ValidationError.OK)
                        self.assert_(ve.getErrors("policy_count_type") == ValidationError.OK)
                        # max
                        p = Policy(self.getTestDictionary("values_policy_bad_max.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
318  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
301  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getParamCount() == 4)
                        self.assert_(ve.getErrors() == ValidationError.VALUE_OUT_OF_RANGE)
                        self.assert_(ve.getErrors("string_count_type") == ValidationError.OK)
                        self.assert_(ve.getErrors("policy_count_type") == ValidationError.OK)
                
                        # allowed
                        p = Policy(self.getTestDictionary("values_policy_bad_allowed.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
327  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
310  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getParamCount() == 4)
                        self.assert_(ve.getErrors() == ValidationError.VALUE_DISALLOWED)
                        self.assert_(ve.getErrors("int_range_count_type") == ValidationError.OK)
                        self.assert_(ve.getErrors("string_count_type") == ValidationError.OK)
                        self.assert_(ve.getErrors("policy_count_type") == ValidationError.OK)
                
                        # allowed & min/max
                        p = Policy(self.getTestDictionary("values_policy_bad_allowedminmax.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
337  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
320  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getParamCount() == 2)
                        self.assert_(ve.getErrors("int_range_set_type") 
                                     == ValidationError.VALUE_DISALLOWED 
                                     + ValidationError.VALUE_OUT_OF_RANGE)
                        self.assert_(ve.getErrors("double_range_count_type") 
                                     == ValidationError.TOO_MANY_VALUES 
                                     + ValidationError.VALUE_OUT_OF_RANGE)
                        ve = ValidationError("Dictionary_1.py", 1, "testValues")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
346  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
329  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                
                    def testNested(self):
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
349  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
332  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError,</div>
                                            "policy_bad_subdef.dictionary is a string",
                                            Dictionary, "Malformed subdictionary",
                                            self.getTestDictionary("nested_dictionary_bad_1.paf"))
                
                        p = Policy(self.getTestDictionary("nested_policy_good.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
355  <a href="#1a677e93">1a677e93</a> -         self.assertRaiseLCE("DictionaryError", "Unknown Dictionary property",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
338  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "Unknown Dictionary property",</div>
                                            Dictionary, "Malformed subdictionary",
                                            self.getTestDictionary("nested_dictionary_bad_2.paf"))
                
                        d = Dictionary(self.getTestDictionary("nested_dictionary_good.paf"))
                        d.check()
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
361  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("LogicErrorException", "dictionaryFile needs to be loaded",</div>
              ?                             ^          ----------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
344  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(lsst.pex.exceptions.LogicError, "dictionaryFile needs to be loaded",</div>
              ?                             ^^^^^^^^^^^^^^^^^^^^
                                            d.validate, "dictionaryFile not loaded", p)
                        self.assert_(not d.hasSubDictionary("policy_1"))
                        self.assert_(d.hasSubDictionary("policy_2"))
                        self.assert_(not d.hasSubDictionary("policy_load"))
                        n = d.loadPolicyFiles(self.getTestDictionary(), True)
                        self.assert_(d.hasSubDictionary("policy_load"))
                        self.assert_(n == 1) # number of files loaded
                        d.validate(p)
                
                        ve = ValidationError("Dictionary_1.py", 1, "testNested")
                        p = Policy(self.getTestDictionary("nested_policy_bad.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
373  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
356  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("policy_1") == ValidationError.WRONG_TYPE)
                        self.assert_(ve.getErrors("policy_2.foo")
                                     == ValidationError.VALUE_DISALLOWED)
                        self.assert_(ve.getErrors("policy_2.bar")
                                     == ValidationError.MISSING_REQUIRED)
                        self.assert_(ve.getErrors("policy_3.baz.qux")
                                     == ValidationError.WRONG_TYPE)
                        self.assert_(ve.getErrors("policy_3.baz.paisley")
                                     == ValidationError.MISSING_REQUIRED)
                        self.assert_(ve.getErrors("policy_3.baz.paisley")
                                     == ValidationError.MISSING_REQUIRED)
                        self.assert_(ve.getErrors("policy_load.height")
                                     == ValidationError.MISSING_REQUIRED)
                        self.assert_(ve.getParamCount() == 6)
                
                        # multiple nesting
                        p = Policy(self.getTestDictionary("nested_policy_1.paf"))
                        n = p.loadPolicyFiles(self.getTestDictionary())
                        self.assert_(n == 3)
                        self.assert_(p.getString("1.2b.foo") == "bar")
                
                        d = Dictionary(self.getTestDictionary("nested_dictionary_1.paf"))
                        n = d.loadPolicyFiles(self.getTestDictionary())
                        self.assert_(n == 3)
                        p = Policy(True, d) # load from defaults
                        self.assert_(p.getString("1.2a.foo") == "bar")
                        self.assert_(p.getString("1.2b.foo") == "bar")
                
                        # error in child
                        d = Dictionary(self.getTestDictionary("nested_dictionary_bad_child.paf"))
                        d.loadPolicyFiles(self.getTestDictionary())
                        # this should really be caught during loadPolicyFiles(), above
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
406  <a href="#1a677e93">1a677e93</a> -         self.assertRaiseLCE("DictionaryError", "Unknown type: \"NotAType\"",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
389  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "Unknown type: \"NotAType\"",</div>
                                            d.makeDef("sub.something").getType,
                                            "Loaded sub-dictionary specified a bogus type")
                
                    def testChildDef(self):
                        # simple
                        d = Dictionary(self.getTestDictionary("childdef_simple_dictionary.paf"))
                        p = Policy(self.getTestDictionary("childdef_simple_policy_good.paf"))
                        d.validate(p)
                        p = Policy(self.getTestDictionary("childdef_simple_policy_bad.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testChildDef")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
417  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
400  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("baz") == ValidationError.WRONG_TYPE)
                
                        # multiple childDefs (DictionaryError)
                        d = Dictionary(self.getTestDictionary("childdef_dictionary_bad_multiple.paf"))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
422  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError", "Multiple childDef",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
405  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "Multiple childDef",</div>
                                            d.validate, "Dictionary specifies unknown types", p)
                
                        # complex
                        d = Dictionary(self.getTestDictionary("childdef_complex_dictionary.paf"))
                        p = Policy(self.getTestDictionary("childdef_complex_policy_good_1.paf"))
                        d.validate(p)
                        p = Policy(self.getTestDictionary("childdef_complex_policy_good_2.paf"))
                        d.validate(p)
                        p = Policy(self.getTestDictionary("childdef_complex_policy_bad_1.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testChildDef")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
433  <a href="#a938e0ae">a938e0ae</a> -         d.validate(p, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
416  <a href="#0050b976">0050b976</a> +         d.validate(p, ve.cpp)</div>
              ?                         ++++
                        self.assert_(ve.getErrors("joe") == ValidationError.NOT_AN_ARRAY)
                        self.assert_(ve.getErrors("deb") == ValidationError.NOT_AN_ARRAY)
                        self.assert_(ve.getErrors("bob") == ValidationError.NOT_AN_ARRAY)
                        self.assert_(ve.getErrors("bob.bar") == ValidationError.NOT_AN_ARRAY)
                        self.assert_(ve.getErrors("nested.helen.qux") 
                                     == ValidationError.MISSING_REQUIRED)
                        self.assert_(ve.getErrors("nested.marvin.rafael") 
                                     == ValidationError.TOO_MANY_VALUES)
                        self.assert_(ve.getErrors("disallowed.foo") 
                                     == ValidationError.TOO_MANY_VALUES)
                        self.assert_(ve.getParamCount() == 7)
                        
                    def testDefaults(self):
                        p = Policy.createPolicy(self.getTestDictionary("defaults_dictionary_good.paf"),
                                                "", True)
                        self.assert_(p.valueCount("bool_set_count") == 1)
                        self.assert_(p.getBool("bool_set_count") == True)
                        self.assert_(p.valueCount("int_range_count") == 3)
                        self.assert_(p.getDouble("deep.sub_double") == 1.)
                        self.assert_(p.get("indirect4.string_type") == "foo")
                
                        try:
                            p = Policy.createPolicy(self.getTestDictionary("defaults_dictionary_bad_1.paf"),
                                                    "", True)
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
441  <a href="#0050b976">0050b976</a> +         except ValidationError as ve:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
458  <a href="#a938e0ae">a938e0ae</a> -         except LsstCppException, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
459  <a href="#a938e0ae">a938e0ae</a> -             ve = e.args[0] # the real exception that was thrown</div>
                            self.assert_(ve.getErrors("double")
                                         == ValidationError.WRONG_TYPE)
                            self.assert_(ve.getErrors("int_range_count")
                                         == ValidationError.NOT_AN_ARRAY)
                            self.assert_(ve.getErrors("bool_set_count")
                                         == ValidationError.TOO_MANY_VALUES)
                            self.assert_(ve.getErrors("deep.sub_double")
                                         == ValidationError.WRONG_TYPE)
                            self.assert_(ve.getParamCount() == 4)
                
                    # test setting and adding when created with a dictionary
                    def testSetAdd(self):
                        p = Policy.createPolicy(self.getTestDictionary("defaults_dictionary_good.paf"),
                                                "", True)
                        self.assert_(p.canValidate())
                        self.assertValidationError(
                            ValidationError.TOO_MANY_VALUES, 
                            p.add, "bool_set_count", True)
                        self.assert_(p.valueCount("bool_set_count") == 1)
                        self.assertValidationError(
                            ValidationError.VALUE_DISALLOWED, 
                            p.set, "bool_set_count", False)
                        self.assert_(p.getBool("bool_set_count") == True)
                        p.set("int_range_count", -7)
                        self.assertValidationError(
                            ValidationError.VALUE_OUT_OF_RANGE, 
                            p.add, "int_range_count", 10)
                        # add & set don't check against minOccurs, but validate() does
                        try:
                            p.validate()
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
490  <a href="#a938e0ae">a938e0ae</a> -         except LsstCppException, e:</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
472  <a href="#0050b976">0050b976</a> +         except ValidationError as ve:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
491  <a href="#a938e0ae">a938e0ae</a> -             self.assert_(e.args[0].getErrors("int_range_count")</div>
              ?                           --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
473  <a href="#0050b976">0050b976</a> +             self.assert_(ve.getErrors("int_range_count")</div>
              ?                          +
                                         == ValidationError.NOT_AN_ARRAY)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
493  <a href="#a938e0ae">a938e0ae</a> -             self.assert_(e.args[0].getErrors("required")</div>
              ?                           --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
475  <a href="#0050b976">0050b976</a> +             self.assert_(ve.getErrors("required")</div>
              ?                          +
                                         == ValidationError.MISSING_REQUIRED)
                        p.add("int_range_count", -8)
                        p.set("required", "foo")
                        p.validate()
                
                    def testSelfValidation(self):
                        # assign a dictionary after creation
                        p = Policy(self.getTestDictionary("types_policy_good.paf"))
                        p.loadPolicyFiles(self.getTestDictionary(), True)
                        typesDict = Dictionary(self.getTestDictionary("types_dictionary.paf"))
                        valuesDict = Dictionary(self.getTestDictionary("values_dictionary.paf"))
                        self.assert_(not p.canValidate())
                        p.setDictionary(typesDict)
                        self.assert_(p.canValidate())
                        p.validate()
                        p.set("bool_type", True)
                        self.assertValidationError(
                            ValidationError.WRONG_TYPE, p.set, "bool_type", "foo")
                
                        # create with dictionary
                        p = Policy.createPolicy(self.getTestDictionary("types_dictionary.paf"), "", True)
                        self.assert_(p.canValidate())
                        p.set("bool_type", True)
                        self.assertValidationError(
                            ValidationError.WRONG_TYPE, p.set, "bool_type", "foo")
                
                        # assign a dictionary after invalid modifications
                        p = Policy()
                        p.set("bool_type", "foo")
                        p.setDictionary(typesDict)
                        ve = ValidationError("Dictionary_1.py", 1, "testSelfValidation")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
525  <a href="#a938e0ae">a938e0ae</a> -         p.validate(ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
507  <a href="#0050b976">0050b976</a> +         p.validate(ve.cpp)</div>
              ?                      ++++
                        self.assert_(ve.getErrors("bool_type") == ValidationError.WRONG_TYPE)
                        try:
                            p.validate()
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
511  <a href="#0050b976">0050b976</a> +         except ValidationError as ve:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
529  <a href="#a938e0ae">a938e0ae</a> -         except LsstCppException, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
530  <a href="#a938e0ae">a938e0ae</a> -             ve = e.args[0]</div>
                            self.assert_(ve.getErrors("bool_type") == ValidationError.WRONG_TYPE)
                            self.assert_(ve.getParamCount() == 1)
                        p.set("bool_type", True)
                        p.set("int_type", 1)
                        p.validate()
                
                        # switch dictionaries
                        oldD = p.getDictionary()
                        p.setDictionary(valuesDict)
                        try:
                            p.validate()
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
542  <a href="#a938e0ae">a938e0ae</a> -         except LsstCppException, e:</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
523  <a href="#0050b976">0050b976</a> +         except ValidationError as ve:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
543  <a href="#a938e0ae">a938e0ae</a> -             self.assert_(e.args[0].getErrors("bool_type")</div>
              ?                           --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
524  <a href="#0050b976">0050b976</a> +             self.assert_(ve.getErrors("bool_type")</div>
              ?                          +
                                         == ValidationError.UNKNOWN_NAME)
                        p.set("string_range_type", "moo")
                        try:
                            p.set("string_range_type", "victor")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
548  <a href="#a938e0ae">a938e0ae</a> -         except LsstCppException, e:</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
529  <a href="#0050b976">0050b976</a> +         except ValidationError as ve:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
549  <a href="#a938e0ae">a938e0ae</a> -             self.assert_(e.args[0].getErrors("string_range_type")</div>
              ?                           --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
530  <a href="#0050b976">0050b976</a> +             self.assert_(ve.getErrors("string_range_type")</div>
              ?                          +
                                         == ValidationError.VALUE_OUT_OF_RANGE)
                        p.setDictionary(oldD)
                        p.remove("string_range_type")
                        p.validate()
                
                    def testMergeDefaults(self):
                        # from a non-trivial dictionary
                        p = Policy(self.getTestDictionary("defaults_policy_partial.paf"))
                        p.set("required", "foo")
                        d = Dictionary(self.getTestDictionary("defaults_dictionary_good.paf"))
                        d.loadPolicyFiles(self.getTestDictionary(), True)
                        self.assert_(p.nameCount() == 2)
                        p.mergeDefaults(d)
                        self.assert_(p.valueCount("int_range_count") == 3)
                        self.assert_(p.nameCount() == 7)
                
                        # from a policy that's really a dictionary
                        p = Policy()
                        pd = Policy(self.getTestDictionary("defaults_dictionary_indirect.paf"))
                        p.mergeDefaults(pd)
                        self.assert_(p.getString("string_type") == "foo")
                        self.assert_(p.getDictionary().isDictionary())
                        
                        # from a policy that's really a non-trivial dictionary
                        p = Policy(self.getTestDictionary("defaults_policy_partial.paf"))
                        p.set("required", "foo")
                        pd = Policy(self.getTestDictionary("defaults_dictionary_policy.paf"))
                        pd.loadPolicyFiles(self.getTestDictionary(), True)
                        self.assert_(p.nameCount() == 2)
                        p.mergeDefaults(pd)
                        self.assert_(p.valueCount("int_range_count") == 3)
                        self.assert_(p.nameCount() == 5)
                
                        # ensure post-load validation
                        p.set("int_range_count", -5)
                        self.assertValidationError(ValidationError.UNKNOWN_NAME,
                                                   p.add, "unknown", 0)
                
                        # test throwing validation
                        p = Policy(self.getTestDictionary("defaults_policy_partial.paf"))
                        try:
                            p.mergeDefaults(pd)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
592  <a href="#a938e0ae">a938e0ae</a> -         except LsstCppException, e:</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
573  <a href="#0050b976">0050b976</a> +         except ValidationError as ve:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
593  <a href="#a938e0ae">a938e0ae</a> -             self.assert_(e.args[0].getErrors("required")</div>
              ?                           --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
574  <a href="#0050b976">0050b976</a> +             self.assert_(ve.getErrors("required")</div>
              ?                          +
                                         == ValidationError.MISSING_REQUIRED)
                
                        # non-throwing validation
                        p = Policy(self.getTestDictionary("defaults_policy_partial.paf"))
                        ve = ValidationError("Dictionary_1.py", 1, "testMergeDefaults")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
599  <a href="#a938e0ae">a938e0ae</a> -         p.mergeDefaults(pd, False, ve)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
580  <a href="#0050b976">0050b976</a> +         p.mergeDefaults(pd, False, ve.cpp)</div>
              ?                                      ++++
                        self.assert_(ve.getErrors("required") == ValidationError.MISSING_REQUIRED)
                        self.assert_(ve.getParamCount() == 1)
                
                        # non-retention
                        p = Policy(self.getTestDictionary("defaults_policy_partial.paf"))
                        p.set("required", "foo")
                        p.mergeDefaults(pd, False)
                        # make sure validate() fails gracefully when no dictionary present
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
608  <a href="#a938e0ae">a938e0ae</a> -         self.assertRaiseLCE("DictionaryError", "No dictionary",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
589  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError, "No dictionary",</div>
                                            p.validate, "No dictionary assigned")
                        p.add("unknown", 0) # would be rejected if dictionary was kept
                
                        # deep merge from a Policy that's not a Dictionary
                        p = Policy(self.getTestDictionary("defaults_policy_partial.paf"))
                        p.mergeDefaults(Policy(self.getTestDictionary("defaults_policy_most.paf")))
                        self.assert_(p.nameCount() == 3)
                        self.assert_(p.getBool("bool_set_count") == True)
                        self.assert_(p.getString("indirect.string_type") == "bar")
                
                        # propagation of a Dictionary from one Policy to another via mergeDefaults
                        d = Dictionary(self.getTestDictionary("defaults_dictionary_complete.paf"))
                        d.loadPolicyFiles(self.getTestDictionary())
                        pEmpty = Policy()
                        pEmpty.mergeDefaults(d)
                        self.assert_(pEmpty.canValidate())
                        pPartial = Policy(self.getTestDictionary("defaults_policy_partial.paf"))
                        pPartial.mergeDefaults(pEmpty)
                        self.assert_(pPartial.canValidate(), "Dictionary handed off via mergeDefaults.")
                
                    # test the sample code at http://dev.lsstcorp.org/trac/wiki/PolicyHowto
                    def testSampleCode(self):
                        policyFile = DefaultPolicyFile("pex_policy", "defaults_dictionary_complete.paf",
                                                       "tests/dictionary")
                        defaults = Policy.createPolicy(policyFile, policyFile.getRepositoryPath(), True)
                        policy = Policy()
                        policy.mergeDefaults(defaults)
                        self.assert_(policy.canValidate())
                
                        policy = Policy()
                        policy.mergeDefaults(defaults, False)
                        self.assert_(not policy.canValidate())
                
                        # even if not keeping it around for future validation, validate the merge now
                        policy = Policy()
                        policy.set("bad", "worse")
                        self.assertValidationError(ValidationError.UNKNOWN_NAME,
                                                   policy.mergeDefaults, defaults, False)
                        self.assert_(not policy.canValidate())
                
                    # test operations on an empty sub-dictionary (ticket 1210)
                    def testEmptySubdict(self):
                        d = Dictionary(self.getTestDictionary("empty_subdictionary.paf"))
                        p = Policy()
                        p.set("empty_required", Policy(self.getTestDictionary("simple_policy.paf")))
                        p.mergeDefaults(d)
                        self.assert_(p.get("empty_sub_with_default.foo") == "bar")
                        p.setDictionary(d)
                        # this works because there is a definition for "empty_sub_with_default.foo"
                        p.set("empty_sub_with_default.foo", "baz")
                
                        p2 = Policy()
                        p2.set("foo", "baz")
                        p.set("empty_sub_no_default", p2)
                        # this fails because Policy tries to makeDef("empty_sub_no_default.foo")
                        # which fails because there's only a definition for "empty_sub_no_default",
                        # but it doesn't contain any sub-definitions
                        # p.set("empty_sub_no_default.foo", "baz")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
667  <a href="#1a677e93">1a677e93</a> -         self.assertRaiseLCE("DictionaryError",</div>
              ?                             -               -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
648  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(DictionaryError,</div>
                                            "empty_sub_no_default.dictionary not found",
                                            p.set, "Empty policy definition -- if this fails, "
                                            "it means a known bug has been fixed.  That's good.",
                                            "empty_sub_no_default.foo", "baz")
                
                def suite():
                    """a suite containing all the test cases in this module"""
                    tests.init()
                
                    suites = []
                    suites += unittest.makeSuite(DictionaryTestCase)
                    suites += unittest.makeSuite(tests.MemoryTestCase)
                
                    return unittest.TestSuite(suites)
                
                def run(exit=False):
                    """Run the tests"""
                    tests.run(suite(), exit)
                
                if __name__ == "__main__":
                    run(True)
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="95441d27"/></a>95441d27</h3>

<pre>
commit 95441d27b737da27a6d2540aa026c3763e1633e1
Author: rhl <rhl@git.lsstcorp.org>
Date:   Fri Dec 4 21:20:36 2009 +0000

    Make it possible to run Dictionary tests from any directory
</pre>
<h3><a name="1a677e93"/></a>1a677e93</h3>

<pre>
commit 1a677e939829c1365ee0bb5e29d501e9eb1f2f65
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Thu Apr 1 20:54:06 2010 +0000

    Partially front-load dictionary validation; improve handling of empty sub-dictionary definitions
</pre>
<h3><a name="a938e0ae"/></a>a938e0ae</h3>

<pre>
commit a938e0ae6e04eb065113480c098a5e9f681a0bb9
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Wed Nov 18 20:48:24 2009 +0000

    Merged revisions 10237-10239,10263,10278-10279,10318-10320,10332,10334-10336,10359,10383,10390,10439,10445-10446,10449,10469-10471,10485,10499-10501,10570,10572-10574,10581-10584,10617,10619-10623,10627,10674-10677,10691,10890,10918,10985-10986,11436-11438,11482,11489-11490 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/pex/policy/tickets/872
    
    ........
      r10237 | bbaker | 2009-07-24 13:40:06 -0500 (Fri, 24 Jul 2009) | 1 line
    
      add rough childDefinition definition
    ........
      r10238 | bbaker | 2009-07-24 13:40:33 -0500 (Fri, 24 Jul 2009) | 1 line
    
      rough list of validation tests, from examining the spec in Dictionary.h
    ........
      r10239 | bbaker | 2009-07-24 13:41:18 -0500 (Fri, 24 Jul 2009) | 1 line
    
      comment
    ........
      r10263 | bbaker | 2009-07-27 09:44:48 -0500 (Mon, 27 Jul 2009) | 1 line
    
      add details to list of tests
    ........
      r10278 | bbaker | 2009-07-29 15:00:10 -0500 (Wed, 29 Jul 2009) | 1 line
    
      typos
    ........
      r10279 | bbaker | 2009-07-29 15:00:41 -0500 (Wed, 29 Jul 2009) | 1 line
    
      add some missing fields
    ........
      r10318 | bbaker | 2009-07-31 18:16:01 -0500 (Fri, 31 Jul 2009) | 1 line
    
      primitive examples for development
    ........
      r10319 | bbaker | 2009-07-31 18:16:29 -0500 (Fri, 31 Jul 2009) | 1 line
    
      debugging validation
    ........
      r10320 | bbaker | 2009-07-31 18:17:06 -0500 (Fri, 31 Jul 2009) | 1 line
    
      placeholder
    ........
      r10332 | bbaker | 2009-08-04 11:03:53 -0500 (Tue, 04 Aug 2009) | 1 line
    
      correct typos; tweak constants
    ........
      r10334 | bbaker | 2009-08-04 11:40:31 -0500 (Tue, 04 Aug 2009) | 1 line
    
      fix unit test -- mixed types
    ........
      r10335 | bbaker | 2009-08-04 11:54:01 -0500 (Tue, 04 Aug 2009) | 1 line
    
      dictionary unit test stub
    ........
      r10336 | bbaker | 2009-08-04 13:00:11 -0500 (Tue, 04 Aug 2009) | 1 line
    
      move unit test files into tests; add simple validate
    ........
      r10359 | bbaker | 2009-08-05 17:33:18 -0500 (Wed, 05 Aug 2009) | 1 line
    
      rigorize dictionary type handling
    ........
      r10383 | bbaker | 2009-08-07 13:32:20 -0500 (Fri, 07 Aug 2009) | 1 line
    
      cleaning up values validation
    ........
      r10390 | bbaker | 2009-08-07 17:55:15 -0500 (Fri, 07 Aug 2009) | 1 line
    
      templates templates templates
    ........
      r10439 | bbaker | 2009-08-12 17:26:49 -0500 (Wed, 12 Aug 2009) | 1 line
    
      improve error messages, and other testing
    ........
      r10445 | bbaker | 2009-08-13 14:23:31 -0500 (Thu, 13 Aug 2009) | 1 line
    
      getTypeByName -- whew
    ........
      r10446 | bbaker | 2009-08-13 15:16:55 -0500 (Thu, 13 Aug 2009) | 1 line
    
      more dictionary integrity tests
    ........
      r10449 | bbaker | 2009-08-13 16:37:22 -0500 (Thu, 13 Aug 2009) | 1 line
    
      confirm that policy validation is only partial
    ........
      r10469 | bbaker | 2009-08-14 15:56:35 -0500 (Fri, 14 Aug 2009) | 1 line
    
      value validation
    ........
      r10470 | bbaker | 2009-08-14 15:57:51 -0500 (Fri, 14 Aug 2009) | 1 line
    
      remove finished TODO
    ........
      r10471 | bbaker | 2009-08-14 16:15:24 -0500 (Fri, 14 Aug 2009) | 1 line
    
      detect missing required items
    ........
      r10485 | bbaker | 2009-08-17 17:39:50 -0500 (Mon, 17 Aug 2009) | 1 line
    
      nested validation
    ........
      r10499 | bbaker | 2009-08-18 15:34:33 -0500 (Tue, 18 Aug 2009) | 1 line
    
      childDefinition implementation and tests
    ........
      r10500 | bbaker | 2009-08-18 16:19:48 -0500 (Tue, 18 Aug 2009) | 1 line
    
      comments
    ........
      r10501 | bbaker | 2009-08-18 16:22:02 -0500 (Tue, 18 Aug 2009) | 1 line
    
      TODOs
    ........
      r10570 | bbaker | 2009-09-01 18:06:33 -0500 (Tue, 01 Sep 2009) | 1 line
    
      more validation when loading from defaults
    ........
      r10572 | bbaker | 2009-09-01 21:58:01 -0500 (Tue, 01 Sep 2009) | 1 line
    
      quick emacs cmd
    ........
      r10573 | bbaker | 2009-09-01 22:22:45 -0500 (Tue, 01 Sep 2009) | 1 line
    
      obsolete
    ........
      r10574 | bbaker | 2009-09-01 22:23:08 -0500 (Tue, 01 Sep 2009) | 1 line
    
      validate on set/add -- step 1
    ........
      r10581 | bbaker | 2009-09-03 16:17:42 -0500 (Thu, 03 Sep 2009) | 1 line
    
      accessors for policy.dictionary, test policy self-validation
    ........
      r10582 | bbaker | 2009-09-03 16:22:51 -0500 (Thu, 03 Sep 2009) | 1 line
    
      more set/add tests
    ........
      r10583 | bbaker | 2009-09-03 16:23:40 -0500 (Thu, 03 Sep 2009) | 1 line
    
      comment
    ........
      r10584 | bbaker | 2009-09-03 16:25:31 -0500 (Thu, 03 Sep 2009) | 1 line
    
      oops, test failed
    ........
      r10617 | bbaker | 2009-09-11 15:27:09 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fixes related to nested dictionaries and policies
    ........
      r10619 | bbaker | 2009-09-11 16:09:40 -0500 (Fri, 11 Sep 2009) | 1 line
    
      remove debugging printouts, convert to constants instead of literal strings
    ........
      r10620 | bbaker | 2009-09-11 16:16:57 -0500 (Fri, 11 Sep 2009) | 1 line
    
      fix spelling of EventTranmitter
    ........
      r10621 | bbaker | 2009-09-11 16:22:59 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test condensed dictionary syntax, update docs and TODOs
    ........
      r10622 | bbaker | 2009-09-11 16:24:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      test without 'target' field in dictionary
    ........
      r10623 | bbaker | 2009-09-11 16:27:34 -0500 (Fri, 11 Sep 2009) | 1 line
    
      resolve TODO comments
    ........
      r10627 | bbaker | 2009-09-11 17:15:23 -0500 (Fri, 11 Sep 2009) | 1 line
    
      deep dictionary loading
    ........
      r10674 | bbaker | 2009-09-18 15:02:18 -0500 (Fri, 18 Sep 2009) | 1 line
    
      use boost::make_shared where possible
    ........
      r10675 | bbaker | 2009-09-18 15:07:03 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10676 | bbaker | 2009-09-18 15:07:42 -0500 (Fri, 18 Sep 2009) | 1 line
    
      fix perms
    ........
      r10677 | bbaker | 2009-09-18 17:39:14 -0500 (Fri, 18 Sep 2009) | 1 line
    
      working on validation script
    ........
      r10691 | bbaker | 2009-09-21 18:18:48 -0500 (Mon, 21 Sep 2009) | 1 line
    
      validation script for dictionary & policy authors
    ........
      r10890 | bbaker | 2009-10-06 12:22:53 -0500 (Tue, 06 Oct 2009) | 1 line
    
      uses of Policy C++ and Python interfaces
    ........
      r10918 | bbaker | 2009-10-07 13:09:45 -0500 (Wed, 07 Oct 2009) | 1 line
    
      hide certain swig warnings
    ........
      r10985 | bbaker | 2009-10-12 15:44:45 -0500 (Mon, 12 Oct 2009) | 1 line
    
      improve formatting
    ........
      r10986 | bbaker | 2009-10-12 15:46:30 -0500 (Mon, 12 Oct 2009) | 1 line
    
      list of policy files
    ........
      r11436 | bbaker | 2009-11-10 14:02:15 -0600 (Tue, 10 Nov 2009) | 1 line
    
      move validate.py test script into tests dir
    ........
      r11437 | bbaker | 2009-11-10 14:02:40 -0600 (Tue, 10 Nov 2009) | 1 line
    
      reference to --help
    ........
      r11438 | bbaker | 2009-11-10 14:03:28 -0600 (Tue, 10 Nov 2009) | 1 line
    
      pex_policy: add options to mergeDefaults to validate and to keep dictionary
    ........
      r11482 | bbaker | 2009-11-17 15:40:53 -0600 (Tue, 17 Nov 2009) | 1 line
    
      more mergeDefaults -- deep Policy merge
    ........
      r11489 | bbaker | 2009-11-18 12:43:19 -0600 (Wed, 18 Nov 2009) | 1 line
    
      improve standards compliance
    ........
      r11490 | bbaker | 2009-11-18 12:50:15 -0600 (Wed, 18 Nov 2009) | 1 line
    
      more standards compliance
    ........
</pre>
<h3><a name="0c37b98e"/></a>0c37b98e</h3>

<pre>
commit 0c37b98ef1527d31148e9a0290bd63d9000bf736
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Tue Dec 8 00:21:55 2009 +0000

    Improve usability of Policy.mergeDefaults()
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="a03a626c"/></a>a03a626c</h3>

<pre>
commit a03a626ca159348edad2d2d5b0809dfd7d8d1a36
Author: Joshua Hoblitt <josh@hoblitt.com>
Date:   Fri May 22 15:11:15 2015 -0700

    replace eups.productDir() calls with lsst.utils.getPackageDir()
</pre>
<h3><a name="0050b976"/></a>0050b976</h3>

<pre>
commit 0050b9767b605916c0d6fff20a22dd9476cf0c25
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 15:08:59 2014 -0400

    Adapt to changes in Python Swig wrappers (DM-827)
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_44"><a name="tests/UrnPolicyFile_1.py"/></a>tests/UrnPolicyFile_1.py</h1>

<h3 id="toc_45">Diff:</h3>

<pre>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1    <a href="#0050b976">0050b976</a> + #!/usr/bin/env python</div>
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                import os
                import unittest
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
25   <a href="#83d0e80a">83d0e80a</a> - import eups</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
26   <a href="#a03a626c">a03a626c</a> + import lsst.utils</div>
                #import inspect
                
                import lsst.utils.tests as tests
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
30   <a href="#83d0e80a">83d0e80a</a> - from lsst.pex.policy import Policy, UrnPolicyFile</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
31   <a href="#0050b976">0050b976</a> + from lsst.pex.policy import Policy, UrnPolicyFile, BadNameError</div>
              ?                                                  ++++++++++++++
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
31   <a href="#83d0e80a">83d0e80a</a> - from lsst.pex.exceptions import LsstCppException</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
32   <a href="#0050b976">0050b976</a> + import lsst.pex.exceptions</div>
                
                #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                
                # TODO: test cross-package loading more thoroughly -- mix up the packages and
                # repositories in a deeply nested and linked policy file.
                
                class UrnPolicyFileTestCase(unittest.TestCase):
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
40   <a href="#0050b976">0050b976</a> + </div>
                    def assertRaiseLCE(self, excClass, excMsg, callableObj, failMsg, *args, **kwargs):
                        """
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
41   <a href="#83d0e80a">83d0e80a</a> -         Expect callableObj(args, kwargs) to raise an LsstCppException that wraps</div>
              ?                                                      ^^^^^^^^          ^ ------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
43   <a href="#0050b976">0050b976</a> +         Expect callableObj(args, kwargs) to raise an exception of type excClass,</div>
              ?                                                      ^         +++ ^^^^^^^^^  ++
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
44   <a href="#0050b976">0050b976</a> +         and carres a message that contains excMsg.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
42   <a href="#83d0e80a">83d0e80a</a> -         the class specified by excClass, and carrying a message that contains</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
43   <a href="#83d0e80a">83d0e80a</a> -         excMsg.</div>
                
                        excClass: the subclass of LsstCppException we expect to see
                        excMsg: a substring of the message it should carry
                        callableObj: the thing that, when called, should raise an exception
                        failMsg: the assertion message if this fails
                        args, kwargs (optional): arguments to pass to callableObj
                        """
                        try:
                            callableObj(*args, **kwargs)
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
54   <a href="#0050b976">0050b976</a> +         except excClass as e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
53   <a href="#83d0e80a">83d0e80a</a> -         except LsstCppException, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
54   <a href="#83d0e80a">83d0e80a</a> -             self.assert_(isinstance(e, LsstCppException))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#83d0e80a">83d0e80a</a> -             lce = "lsst.pex.exceptions.exceptionsLib.LsstCppException"</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
56   <a href="#83d0e80a">83d0e80a</a> -             self.assert_(str(e.__class__).find(lce) > 0,</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
57   <a href="#83d0e80a">83d0e80a</a> -                          failMsg + ": expected an " + lce + ", found a " </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
58   <a href="#83d0e80a">83d0e80a</a> -                          + str(e.__class__))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
59   <a href="#83d0e80a">83d0e80a</a> -             self.assert_(len(e.args) == 1)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
60   <a href="#83d0e80a">83d0e80a</a> -             nested = e.args[0] # the real exception that was thrown</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
61   <a href="#83d0e80a">83d0e80a</a> -             self.assert_(str(nested.__class__).find(excClass) > 0,</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
62   <a href="#83d0e80a">83d0e80a</a> -                          failMsg + ": expected a " + excClass + "; found a " </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
63   <a href="#83d0e80a">83d0e80a</a> -                          + str(nested.__class__))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
64   <a href="#83d0e80a">83d0e80a</a> -             self.assert_(str(e).find(excMsg) > 0, </div>
              ?                                                  -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
55   <a href="#0050b976">0050b976</a> +             self.assert_(str(e).find(excMsg) > 0,</div>
                                         failMsg + ": expected to see the message \"" + excMsg 
                                         + "\"; actual message was \"" + str(e) + "\".")
                        else:
                            self.fail(failMsg + ": did not raise " + excClass)
                
                    examplesDir = None
                    def getExamples(self, filename=None):
                        if not self.examplesDir:
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
64   <a href="#a03a626c">a03a626c</a> +             # XXX is this really the best way to find the src_dir?</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
65   <a href="#a03a626c">a03a626c</a> +             pexPolicyDir = lsst.utils.getPackageDir('pex_policy')</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
73   <a href="#83d0e80a">83d0e80a</a> -             self.examplesDir = os.path.join(eups.productDir("pex_policy"),</div>
              ?                                             -----------------   ^^       -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
66   <a href="#a03a626c">a03a626c</a> +             self.examplesDir = os.path.join(pexPolicyDir, "examples")</div>
              ?                                                ^     ++++++++++++++
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
74   <a href="#83d0e80a">83d0e80a</a> -                                             "examples")</div>
                        if filename:
                            return os.path.join(self.examplesDir, filename)
                        else:
                            return self.examplesDir
                
                    def testReference(self):
                        addr = "pex_policy:examples:EventTransmitter_policy.paf"
                        p = Policy()
                
                        p.set("transmitter.logVerbosity", "not")
                        UrnPolicyFile(addr).load(p)
                        self.assert_(p.get("transmitter.logVerbosity") == "debug")
                
                        p.set("transmitter.logVerbosity", "not")
                        UrnPolicyFile("urn:eupspkg:" + addr).load(p)
                        self.assert_(p.get("transmitter.logVerbosity") == "debug")
                
                        p.set("transmitter.logVerbosity", "not")
                        UrnPolicyFile("@@" + addr).load(p)
                        self.assert_(p.get("transmitter.logVerbosity") == "debug")
                
                    def testIndirect(self):
                        urn = "@urn:eupspkg:pex_policy:tests/urn:indirect_parent_good.paf"
                        p = Policy(urn)
                        self.assert_(p.get("urn_full.name") == "Simple Policy")
                        self.assert_(p.get("urn_brief.name") == "Simple Policy")
                        self.assert_(p.get("urn_mixed_case.name") == "Simple Policy")
                        self.assert_(p.get("local.foo") == "bar")
                
                        p = Policy()
                        UrnPolicyFile("pex_policy:tests/urn:level_1.paf").load(p)
                        self.assert_(p.get("foo.bar.baz.qux.quux") == "schmazzle")
                
                    def testLoading(self):
                        p = Policy("urn:eupspkg:pex_policy:tests/urn:level_1.paf")
                        self.assert_(p.get("foo.bar.baz.qux.quux") == "schmazzle")
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
112  <a href="#8de42367">8de42367</a> -         self.assertRaiseLCE("BadNameError", "Wrong number of terms",</div>
              ?                             -            -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
104  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(BadNameError, "Wrong number of terms",</div>
                                            Policy, "URN too short",
                                            "urn:eupspkg:foo.paf")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#8de42367">8de42367</a> -         self.assertRaiseLCE("IoErrorException", "failure opening Policy file",</div>
              ?                             ^^^^^^^^^        ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
107  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(lsst.pex.exceptions.IoError, "failure opening Policy file",</div>
              ?                             ^^^^^^^^^^        ^^^^^^^^^
                                            Policy, "URN abbrev '@' not allowed in constructor",
                                            "@pex_policy:tests/urn:level_1.paf")
                
                        urn = "urn:eupspkg:pex_policy:tests/dictionary:defaults_dictionary_good.paf"
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
120  <a href="#8de42367">8de42367</a> -         self.assertRaiseLCE("IoErrorException", "/./defaults_dictionary_indirect",</div>
              ?                             ^^^^^^^^^        ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
112  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(lsst.pex.exceptions.IoError, "/./defaults_dictionary_indirect",</div>
              ?                             ^^^^^^^^^^        ^^^^^^^^^
                                            Policy.createPolicyFromUrn, 
                                            "doesn't support loading undecorated DictionaryFile",
                                            urn)
                        urn = "urn:eupspkg:pex_policy:tests/dictionary:defaults_dictionary_partial.paf"
                        p = Policy.createPolicyFromUrn(urn)
                        # make sure all reference types worked
                        # self.assert_(p.get("indirect.string_type") == "foo")
                        # self.assert_(p.get("indirect2.string_type") == "foo")
                        self.assert_(p.get("indirect3.string_type") == "foo")
                        self.assert_(p.get("indirect4.string_type") == "foo")
                
                    def testTypos(self):
                        base = "pex_policy:tests/urn:indirect_parent_typo_"
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
134  <a href="#83d0e80a">83d0e80a</a> -         self.assertRaiseLCE("IoErrorException", "failure opening Policy file",</div>
              ?                             ^^^^^^^^^        ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
126  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(lsst.pex.exceptions.IoError, "failure opening Policy file",</div>
              ?                             ^^^^^^^^^^        ^^^^^^^^^
                                            UrnPolicyFile(base + "1.paf").load, "Typo in URN",
                                            Policy())
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
137  <a href="#83d0e80a">83d0e80a</a> -         self.assertRaiseLCE("IoErrorException", "failure opening Policy file",</div>
              ?                             ^^^^^^^^^        ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
129  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(lsst.pex.exceptions.IoError, "failure opening Policy file",</div>
              ?                             ^^^^^^^^^^        ^^^^^^^^^
                                            UrnPolicyFile(base + "2.paf").load, "Typo in URN",
                                            Policy())
                
                    def testRepos(self):
                        # when the repository is mis-specified, local files cannot be loaded
                        upf = UrnPolicyFile("pex_policy:tests:urn/indirect_parent_good.paf")
                        # we expect it to look in <package>/tests/simple.paf
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
145  <a href="#83d0e80a">83d0e80a</a> -         expectedFile = os.environ["PEX_POLICY_DIR"] + "/tests/simple.paf"</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
146  <a href="#83d0e80a">83d0e80a</a> -         self.assertRaiseLCE("IoErrorException",</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
137  <a href="#a03a626c">a03a626c</a> +         pexPolicyDir = lsst.utils.getPackageDir('pex_policy')</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
138  <a href="#a03a626c">a03a626c</a> +         expectedFile = pexPolicyDir + "/tests/simple.paf"</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
139  <a href="#0050b976">0050b976</a> +         self.assertRaiseLCE(lsst.pex.exceptions.IoError,</div>
                                            "failure opening Policy file: " + expectedFile,
                                            upf.load, "Wrong repository dir.", Policy())
                
                        # a PAF file designed to have "tests" as it repository
                        p = Policy()
                        UrnPolicyFile("pex_policy:tests:urn/local_tests_repos.paf").load(p)
                        self.assert_(p.get("local.polish") == "fancy")
                
                def suite():
                    """a suite containing all the test cases in this module"""
                    tests.init()
                
                    suites = []
                    suites += unittest.makeSuite(UrnPolicyFileTestCase)
                    suites += unittest.makeSuite(tests.MemoryTestCase)
                
                    return unittest.TestSuite(suites)
                
                def run(exit=False):
                    """Run the tests"""
                    tests.run(suite(), exit)
                
                if __name__ == "__main__":
                    run(True)
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="83d0e80a"/></a>83d0e80a</h3>

<pre>
commit 83d0e80a8b0ad82af500fad7d8c32002c1e11938
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Fri Apr 16 19:13:27 2010 +0000

    Ticket #1035: support for URN references to policies
</pre>
<h3><a name="8de42367"/></a>8de42367</h3>

<pre>
commit 8de42367a950d87b1459e733a748d0d3e0076769
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Mon Apr 19 22:33:09 2010 +0000

    Further work from #1035: Support direct loading via URN, for example in Policy constructor
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="a03a626c"/></a>a03a626c</h3>

<pre>
commit a03a626ca159348edad2d2d5b0809dfd7d8d1a36
Author: Joshua Hoblitt <josh@hoblitt.com>
Date:   Fri May 22 15:11:15 2015 -0700

    replace eups.productDir() calls with lsst.utils.getPackageDir()
</pre>
<h3><a name="0050b976"/></a>0050b976</h3>

<pre>
commit 0050b9767b605916c0d6fff20a22dd9476cf0c25
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 15:08:59 2014 -0400

    Adapt to changes in Python Swig wrappers (DM-827)
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_46"><a name="src/DefaultPolicyFile.cc"/></a>src/DefaultPolicyFile.cc</h1>

<h3 id="toc_47">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * \file DefaultPolicyFile.cc
                 */
                #include "lsst/pex/policy/DefaultPolicyFile.h"
                #include "lsst/pex/exceptions.h"
                
                #include <algorithm>
                #include <cctype>
                #include <functional>
                
                namespace fs = boost::filesystem;
                namespace pexExcept = lsst::pex::exceptions;
                
                namespace lsst {
                namespace pex {
                namespace policy {
                
                DefaultPolicyFile::DefaultPolicyFile(const char* const productName, 
                                                     const std::string& filepath,
                                                     const std::string& repos,
                                                     bool strict)
                    : PolicyFile(), _repos(), _strict(strict)
                { 
                    _repos = getInstallPath(productName);
                    if (repos.length() > 0) _repos /= repos;
                    _file = _repos / filepath;
                }
                
                fs::path DefaultPolicyFile::getInstallPath(const char* const productName) {
                    return DefaultPolicyFile::installPathFor(productName);
                }
                
                /*
                 * return the file path to the installation directory of a given
                 * named product.  The installation directory will be taken from 
                 * the value of an environment variable PRODUCTNAME_DIR where 
                 * PRODUCTNAME is the given name of the product with all letters 
                 * converted to upper case.  
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
61   <a href="#dcd1814e">dcd1814e</a> -  * @exception lsst::pex::exception::NotFoundException  if the </div>
              ?                                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
61   <a href="#826f6e19">826f6e19</a> +  * @exception lsst::pex::exception::NotFoundError  if the </div>
              ?                                              ^^ ^
                 *    environement variable is not defined.
                 */
                fs::path DefaultPolicyFile::installPathFor(const char* const productName) {
                    std::string productName_DIR(productName);
                
                    // transform to upper case
                    std::transform(productName_DIR.begin(), productName_DIR.end(),
                                   productName_DIR.begin(), 
                                   std::ptr_fun<int, int>( std::toupper ));
                
                    // append _DIR
                    productName_DIR += "_DIR";
                
                    // get installation directory from environment
                    const char *ipath = getenv(productName_DIR.c_str());
                    if (ipath == 0) 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
78   <a href="#83d0e80a">83d0e80a</a> -         throw LSST_EXCEPT(pexExcept::NotFoundException, </div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
78   <a href="#826f6e19">826f6e19</a> +         throw LSST_EXCEPT(pexExcept::NotFoundError, </div>
              ?                                               ^^ ^
                              productName_DIR + ": environment variable not set");
                
                    return fs::path(ipath);
                }
                
                /*
                 * load the data from this Policy source into a Policy object.  This
                 * implementation will automatically de-reference any file include
                 * directives in the policy file.  
                 * @param policy    the policy object to load the data into
                 * @exception ParserException  if an error occurs while parsing the data
                 * @exception IOError   if an I/O error occurs while reading from the 
                 *                       source stream.
                 */
                void DefaultPolicyFile::load(Policy& policy) const {
                    PolicyFile::load(policy);
                    policy.loadPolicyFiles(_repos, _strict);
                }
                
                }}}  // end namespace lsst::pex::policy
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/pex_policy/</h2>
<h3><a name="83d0e80a"/></a>83d0e80a</h3>

<pre>
commit 83d0e80a8b0ad82af500fad7d8c32002c1e11938
Author: bbaker <bbaker@git.lsstcorp.org>
Date:   Fri Apr 16 19:13:27 2010 +0000

    Ticket #1035: support for URN references to policies
</pre>
<h3><a name="dcd1814e"/></a>dcd1814e</h3>

<pre>
commit dcd1814ef4726014e169971f2141ca2b35de70dc
Author: rplante <rplante@git.lsstcorp.org>
Date:   Fri Feb 27 23:24:12 2009 +0000

    Primarily updated for use of PropertySet
    Cleaned up use of "using"
    bug fix: add workaround to swig bug to support bool types
    improve exception handling
    improve test scripts (explicitly test all types)
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/pex_policy/</h2>
<h3><a name="826f6e19"/></a>826f6e19</h3>

<pre>
commit 826f6e198b79ca884a487e94f205093488bf362f
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 18 15:07:49 2014 -0700

    Rename exceptions
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<script type="text/javascript">
self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{};var Prism=function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):"Array"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case"Array":return e.map(function(e){return t.util.clone(e)})}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var i=r[e];if(2==arguments.length){a=arguments[1];for(var l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);return i}var s={};for(var o in i)if(i.hasOwnProperty(o)){if(o==n)for(var l in a)a.hasOwnProperty(l)&&(s[l]=a[l]);s[o]=i[o]}return t.languages.DFS(t.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=s)}),r[e]=s},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),"Object"===t.util.type(e[r])?t.languages.DFS(e[r],n):"Array"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'),i=0;a=r[i++];)t.highlightElement(a,e===!0,n)},highlightElement:function(a,r,i){for(var l,s,o=a;o&&!e.test(o.className);)o=o.parentNode;if(o&&(l=(o.className.match(e)||[,""])[1],s=t.languages[l]),s){a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=a.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var u=a.textContent;if(u){u=u.replace(/^(?:\r?\n|\r)/,"");var g={element:a,language:l,grammar:s,code:u};if(t.hooks.run("before-highlight",g),r&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){g.highlightedCode=n.stringify(JSON.parse(e.data),l),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(g.element),t.hooks.run("after-highlight",g)},c.postMessage(JSON.stringify({language:g.language,code:g.code}))}else g.highlightedCode=t.highlight(g.code,g.grammar,g.language),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(a),t.hooks.run("after-highlight",g)}}},highlight:function(e,a,r){var i=t.tokenize(e,a);return n.stringify(t.util.encode(i),r)},tokenize:function(e,n){var a=t.Token,r=[e],i=n.rest;if(i){for(var l in i)n[l]=i[l];delete n.rest}e:for(var l in n)if(n.hasOwnProperty(l)&&n[l]){var s=n[l];s="Array"===t.util.type(s)?s:[s];for(var o=0;o<s.length;++o){var u=s[o],g=u.inside,c=!!u.lookbehind,f=0,h=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){u.lastIndex=0;var m=u.exec(d);if(m){c&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),N=[p,1];b&&N.push(b);var O=new a(l,g?t.tokenize(m,g):m,h);N.push(O),w&&N.push(w),Array.prototype.splice.apply(r,N)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,i=0;r=a[i++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if("string"==typeof e)return e;if("Array"===t.util.type(e))return e.map(function(t){return n.stringify(t,a,e)}).join("");var i={type:e.type,content:n.stringify(e.content,a,r),tag:"span",classes:["token",e.type],attributes:{},language:a,parent:r};if("comment"==i.type&&(i.attributes.spellcheck="true"),e.alias){var l="Array"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(i.classes,l)}t.hooks.run("wrap",i);var s="";for(var o in i.attributes)s+=o+'="'+(i.attributes[o]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'" '+s+">"+i.content+"</"+i.tag+">"},!self.document)return self.addEventListener?(self.addEventListener("message",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code;self.postMessage(JSON.stringify(t.util.encode(t.tokenize(r,t.languages[a])))),self.close()},!1),self.Prism):self.Prism;var a=document.getElementsByTagName("script");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)),self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism);
</script>
</body>

</html>
