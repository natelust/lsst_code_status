<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>daf_base</title>
<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>
</head>
<body>
<h1 id="toc_0">Comparison of the daf_base repository</h1>

<div style="background-color:Aquamarine; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Summary of Repositories</h1>
<p>
Comparison run at 11:36AM on June 09, 2015<br>
There are <b>450</b> differences between the two repositories<br><br>
Repository <b>/Users/nate/repos_hsc/daf_base/</b> <br> Revision <b>1df8a21aa50e46005ad8f936631577ebc6e8ec04</b><br> Branch <b>master</b><br>Last commit was on <b>2015-04-24 16:19:32 -0400</b><br><br>
Repository <b>/Users/nate/repos_lsst/daf_base/</b> <br> Revision <b>5e95c60244e6705eaa297d128463087f62d3bf0c</b><br> Branch <b>master</b><br>Last commit was on <b>2015-06-01 17:36:14 -0700</b><br><br>
</p>
</div>

<hr>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Files only in /Users/nate/repos_hsc/daf_base/</h1>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Files only in /Users/nate/repos_lsst/daf_base/</h1>
</div>

<h1 id="toc_1">List of the files in common<a name="homelist"></a></h1>

<p>Files without links do not differ</p>

<ul>
<li><code>doc/doxygen.conf.in</code></li>
<li><a href="#tests/dateTime.py"><code>tests/dateTime.py</code></a></li>
<li><a href="#tests/PropertyList.py"><code>tests/PropertyList.py</code></a></li>
<li><code>doc/SConscript</code></li>
<li><code>include/lsst/daf/base/Citizen.h</code></li>
<li><a href="#src/PropertySet.cc"><code>src/PropertySet.cc</code></a></li>
<li><code>include/lsst/daf/base.h</code></li>
<li><code>SConstruct</code></li>
<li><code>python/lsst/daf/base/__init__.py</code></li>
<li><a href="#tests/PropertyList.cc"><code>tests/PropertyList.cc</code></a></li>
<li><code>examples/SConscript</code></li>
<li><code>tests/SConscript</code></li>
<li><code>python/lsst/daf/base/SConscript</code></li>
<li><code>python/lsst/daf/base/citizen.py</code></li>
<li><a href="#ups/daf_base.cfg"><code>ups/daf_base.cfg</code></a></li>
<li><code>.gitignore</code></li>
<li><a href="#ups/daf_base.table"><code>ups/daf_base.table</code></a></li>
<li><code>include/lsst/daf/base/PropertyList.h</code></li>
<li><a href="#src/DateTime.cc"><code>src/DateTime.cc</code></a></li>
<li><a href="#tests/PropertySet_2.py"><code>tests/PropertySet_2.py</code></a></li>
<li><a href="#examples/citizen.cc"><code>examples/citizen.cc</code></a></li>
<li><a href="#include/lsst/daf/base/PropertySet.h"><code>include/lsst/daf/base/PropertySet.h</code></a></li>
<li><code>include/lsst/daf/base/Persistable.h</code></li>
<li><a href="#src/PropertyList.cc"><code>src/PropertyList.cc</code></a></li>
<li><code>lib/SConscript</code></li>
<li><code>python/lsst/__init__.py</code></li>
<li><code>ups/daf_base.build</code></li>
<li><code>python/lsst/daf/__init__.py</code></li>
<li><a href="#tests/citizen.cc"><code>tests/citizen.cc</code></a></li>
<li><a href="#tests/dateTime_1.cc"><code>tests/dateTime_1.cc</code></a></li>
<li><a href="#tests/PropertySet_1.cc"><code>tests/PropertySet_1.cc</code></a></li>
<li><code>python/lsst/daf/base/persistenceMacros.i</code></li>
<li><a href="#src/Citizen.cc"><code>src/Citizen.cc</code></a></li>
<li><code>src/Persistable.cc</code></li>
<li><a href="#python/lsst/daf/base/baseLib.i"><code>python/lsst/daf/base/baseLib.i</code></a></li>
<li><code>include/lsst/daf/base/DateTime.h</code></li>
</ul>

<h1 id="toc_2"><a name="tests/dateTime.py"/></a>tests/dateTime.py</h1>

<h3 id="toc_3">Diff:</h3>

<pre>
                #!/usr/bin/env python
                
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                
                import unittest
                
                from lsst.daf.base import DateTime
                import lsst.pex.exceptions as pexExcept
                import os
                import time
                
                class DateTimeTestCase(unittest.TestCase):
                    """A test case for DateTime."""
                
                    def testMJD(self):
                        ts = DateTime(45205.125, DateTime.MJD, DateTime.UTC)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 399006000000000000L)
                        self.assertEqual(ts.nsecs(DateTime.TAI), 399006021000000000L)
                        self.assertAlmostEqual(ts.get(DateTime.MJD, DateTime.UTC), 45205.125)
                        self.assertAlmostEqual(ts.get(DateTime.MJD, DateTime.TAI), 45205.125 + 21.0/86400.0)
                        # Following interface is deprecated
                        self.assertAlmostEqual(ts.mjd(DateTime.UTC), 45205.125)
                        self.assertAlmostEqual(ts.mjd(DateTime.TAI), 45205.125 + 21.0/86400.0)
                
                    def testNsecs(self):
                        ts = DateTime(1192755473000000000L, DateTime.UTC)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 1192755473000000000L)
                        self.assertEqual(ts.nsecs(DateTime.TAI), 1192755506000000000L)
                        self.assertEqual(ts.nsecs(), 1192755506000000000L)
                        self.assertAlmostEqual(ts.get(DateTime.MJD, DateTime.UTC), 54392.040196759262)
                        ts2 = ts
                        self.assertEqual(ts, ts2)
                        ts2 = DateTime(1192755473000000000L, DateTime.UTC)
                        self.assertEqual(ts, ts2)
                        ts2 = DateTime(1234567890000000000L, DateTime.UTC)
                        self.assertNotEqual(ts, ts2)
                
                    def testBoundaryMJD(self):
                        ts = DateTime(47892.0, DateTime.MJD, DateTime.UTC)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 631152000000000000L)
                        self.assertEqual(ts.nsecs(DateTime.TAI), 631152025000000000L)
                        self.assertEqual(ts.get(DateTime.MJD, DateTime.UTC), 47892.0)
                
                    def testCrossBoundaryNsecs(self):
                        ts = DateTime(631151998000000000L, DateTime.UTC)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 631151998000000000L)
                        self.assertEqual(ts.nsecs(DateTime.TAI), 631152022000000000L)
                
                    def testNsecsTAI(self):
                        ts = DateTime(1192755506000000000L, DateTime.TAI)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 1192755473000000000L)
                        self.assertEqual(ts.nsecs(DateTime.TAI), 1192755506000000000L)
                        self.assertEqual(ts.nsecs(), 1192755506000000000L)
                        self.assertAlmostEqual(ts.get(DateTime.MJD, DateTime.UTC), 54392.040196759262)
                
                    def testNsecsDefault(self):
                        ts = DateTime(1192755506000000000L)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 1192755473000000000L)
                        self.assertEqual(ts.nsecs(DateTime.TAI), 1192755506000000000L)
                        self.assertEqual(ts.nsecs(), 1192755506000000000L)
                        self.assertAlmostEqual(ts.get(DateTime.MJD, DateTime.UTC), 54392.040196759262)
                
                    def testNow(self):
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
85   <a href="#b545ccc3">b545ccc3</a> +         successes = 0</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
85   <a href="#9a8ab201">9a8ab201</a> -         for i in xrange(100):       # pylint: disable-msg=W0612</div>
              ?                           -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
86   <a href="#b545ccc3">b545ccc3</a> +         for i in xrange(10):       # pylint: disable-msg=W0612</div>
                            secs = time.time()
                            ts = DateTime.now()
                            diff = ts.nsecs(DateTime.UTC) / 1.0e9 - secs 
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
89   <a href="#9a8ab201">9a8ab201</a> -             self.assertAlmostEqual(diff, 0, places=2)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#b545ccc3">b545ccc3</a> +             if diff > -0.001 and diff < 0.1:</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
91   <a href="#b545ccc3">b545ccc3</a> +                 successes += 1</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
92   <a href="#b545ccc3">b545ccc3</a> +         self.assertGreaterEqual(successes, 3)</div>
                
                    def testIsoEpoch(self):
                        ts = DateTime("19700101T000000Z")
                        self.assertEqual(ts.nsecs(DateTime.UTC), 0L)
                        self.assertEqual(ts.toString(), "1970-01-01T00:00:00.000000000Z")
                
                    def testIsoBasic(self):
                        ts = DateTime("20090402T072639.314159265Z")
                        self.assertEqual(ts.nsecs(DateTime.TAI), 1238657233314159265L)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 1238657199314159265L)
                        self.assertEqual(ts.toString(), "2009-04-02T07:26:39.314159265Z")
                
                    def testIsoExpanded(self):
                        ts = DateTime("2009-04-02T07:26:39.314159265Z")
                        self.assertEqual(ts.nsecs(DateTime.TAI), 1238657233314159265L)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 1238657199314159265L)
                        self.assertEqual(ts.toString(), "2009-04-02T07:26:39.314159265Z")
                
                    def testIsoNoNSecs(self):
                        ts = DateTime("2009-04-02T07:26:39Z")
                        self.assertEqual(ts.nsecs(DateTime.TAI), 1238657233000000000L)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 1238657199000000000L)
                        self.assertEqual(ts.toString(), "2009-04-02T07:26:39.000000000Z")
                
                    def testIsoThrow(self):
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#cfdd37a1">cfdd37a1</a> -         self.assertRaises(pexExcept.LsstCppException, lambda: DateTime("20090401"))</div>
              ?                                     ^^^^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
118  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.DomainError, lambda: DateTime("20090401"))</div>
              ?                                     ^^^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
116  <a href="#cfdd37a1">cfdd37a1</a> -         self.assertRaises(pexExcept.LsstCppException, lambda: DateTime("20090401T"))</div>
              ?                                     ^^^^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
119  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.DomainError, lambda: DateTime("20090401T"))</div>
              ?                                     ^^^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
117  <a href="#cfdd37a1">cfdd37a1</a> -         self.assertRaises(pexExcept.LsstCppException, lambda: DateTime("2009-04-01T"))</div>
              ?                                     ^^^^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
120  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.DomainError, lambda: DateTime("2009-04-01T"))</div>
              ?                                     ^^^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
118  <a href="#cfdd37a1">cfdd37a1</a> -         self.assertRaises(pexExcept.LsstCppException, lambda: DateTime("2009-04-01T23:36:05"))</div>
              ?                                     ^^^^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
121  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.DomainError, lambda: DateTime("2009-04-01T23:36:05"))</div>
              ?                                     ^^^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
119  <a href="#cfdd37a1">cfdd37a1</a> -         self.assertRaises(pexExcept.LsstCppException, lambda: DateTime("20090401T23:36:05-0700"))</div>
              ?                                     ^^^^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
122  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.DomainError, lambda: DateTime("20090401T23:36:05-0700"))</div>
              ?                                     ^^^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
120  <a href="#cfdd37a1">cfdd37a1</a> -         self.assertRaises(pexExcept.LsstCppException, lambda: DateTime("2009/04/01T23:36:05Z"))</div>
              ?                                     ^^^^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
123  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.DomainError, lambda: DateTime("2009/04/01T23:36:05Z"))</div>
              ?                                     ^^^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
121  <a href="#cfdd37a1">cfdd37a1</a> -         self.assertRaises(pexExcept.LsstCppException, lambda: DateTime("2009/04/01T23:36:05Z"))</div>
              ?                                     ^^^^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
124  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.DomainError, lambda: DateTime("2009/04/01T23:36:05Z"))</div>
              ?                                     ^^^^^^ ^^ ^
                
                    def testNsecsTT(self):
                        ts = DateTime(1192755538184000000L, DateTime.TT)
                        self.assertEqual(ts.nsecs(DateTime.UTC), 1192755473000000000L)
                        self.assertEqual(ts.nsecs(DateTime.TAI), 1192755506000000000L)
                        self.assertEqual(ts.nsecs(), 1192755506000000000L)
                        self.assertAlmostEqual(ts.get(DateTime.MJD, DateTime.UTC), 54392.040196759262)
                
                    def testFracSecs(self):
                        ts = DateTime("2004-03-01T12:39:45.1Z")
                        self.assertEqual(ts.toString(), '2004-03-01T12:39:45.100000000Z')
                        ts = DateTime("2004-03-01T12:39:45.01Z")
                        self.assertEqual(ts.toString(), '2004-03-01T12:39:45.010000000Z')
                        ts = DateTime("2004-03-01T12:39:45.000000001Z") # nanosecond
                        self.assertEqual(ts.toString(), '2004-03-01T12:39:45.000000001Z')
                        ts = DateTime("2004-03-01T12:39:45.0000000001Z") # too small
                        self.assertEqual(ts.toString(), '2004-03-01T12:39:45.000000000Z')
                
                    def testNegative(self):
                        ts = DateTime("1969-03-01T00:00:32Z")
                        self.assertEqual(ts.toString(), '1969-03-01T00:00:32.000000000Z')
                        ts = DateTime("1969-01-01T00:00:00Z")
                        self.assertEqual(ts.toString(), '1969-01-01T00:00:00.000000000Z')
                        ts = DateTime("1969-01-01T00:00:40Z")
                        self.assertEqual(ts.toString(), '1969-01-01T00:00:40.000000000Z')
                        ts = DateTime("1969-01-01T00:00:38Z")
                        self.assertEqual(ts.toString(), '1969-01-01T00:00:38.000000000Z')
                        ts = DateTime("1969-03-01T12:39:45Z")
                        self.assertEqual(ts.toString(), '1969-03-01T12:39:45.000000000Z')
                        ts = DateTime("1969-03-01T12:39:45.000000001Z")
                        self.assertEqual(ts.toString(), '1969-03-01T12:39:45.000000001Z')
                
                        # Note slight inaccuracy in UTC-TAI-UTC round-trip
                        ts = DateTime("1969-03-01T12:39:45.12345Z")
                        self.assertEqual(ts.toString(), '1969-03-01T12:39:45.123449996Z')
                        ts = DateTime("1969-03-01T12:39:45.123456Z")
                        self.assertEqual(ts.toString(), '1969-03-01T12:39:45.123455996Z')
                
                        ts = DateTime()
                        self.assertEqual(ts.toString(), '1969-12-31T23:59:51.999918240Z')
                
                        ts = DateTime(-1L, DateTime.TAI)
                        self.assertEqual(ts.toString(), '1969-12-31T23:59:51.999918239Z')
                        ts = DateTime(0L, DateTime.TAI)
                        self.assertEqual(ts.toString(), '1969-12-31T23:59:51.999918240Z')
                        ts = DateTime(1L, DateTime.TAI)
                        self.assertEqual(ts.toString(), '1969-12-31T23:59:51.999918241Z')
                
                        ts = DateTime(-1L, DateTime.UTC)
                        self.assertEqual(ts.toString(), '1969-12-31T23:59:59.999999999Z')
                        ts = DateTime(0L, DateTime.UTC)
                        self.assertEqual(ts.toString(), '1970-01-01T00:00:00.000000000Z')
                        ts = DateTime(1L, DateTime.UTC)
                        self.assertEqual(ts.toString(), '1970-01-01T00:00:00.000000001Z')
                
                    def testConvert(self):
                        year = 2012
                        month = 7
                        day = 19
                        hour = 18
                        minute = 29
                        second = 33
                
                        ts = DateTime(year, month, day, hour, minute, second, DateTime.UTC)
                        dt = ts.toPython(DateTime.UTC)
                
                        self.assertEqual(dt.year, year)
                        self.assertEqual(dt.month, month)
                        self.assertEqual(dt.day, day)
                        self.assertEqual(dt.hour, hour)
                        self.assertEqual(dt.minute, minute)
                        self.assertEqual(dt.second, second)
                
                class TimeZoneBaseTestCase(DateTimeTestCase):
                    timezone = ""
                    def setUp(self):
                        self.tz = os.environ.setdefault('TZ', "")
                        os.environ['TZ'] = self.timezone
                
                    def tearDown(self):
                        if self.tz == "":
                            del os.environ['TZ']
                        else:
                            os.environ['TZ'] = self.tz
                
                class BritishTimeTestCase(TimeZoneBaseTestCase):
                    timezone = "Europe/London"
                
                class BritishTime2TestCase(TimeZoneBaseTestCase):
                    timezone = "GMT0BST"
                
                class PacificTimeTestCase(TimeZoneBaseTestCase):
                    timezone = "PST8PDT"
                
                if __name__ == '__main__':
                    unittest.main()
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="9a8ab201"/></a>9a8ab201</h3>

<pre>
commit 9a8ab201bc5b1828631fec02213a4460b6a9ee6b
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Wed Mar 31 19:15:43 2010 +0000

    Minor code checker fixes.
</pre>
<h3><a name="cfdd37a1"/></a>cfdd37a1</h3>

<pre>
commit cfdd37a1116a88ec0da0e26c1f5ade00cda3e7f6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Apr 2 08:15:09 2009 +0000

    Implement constructor from ISO8601 and toString(), with test cases.  Fix timezone problem with mktime().
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="ee7c5445"/></a>ee7c5445</h3>

<pre>
commit ee7c544513b5a8ce704733c028019930be619168
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 14:22:00 2014 -0400

    Adapt to changes in Python Swig interface (DM-827)
</pre>
<h3><a name="b545ccc3"/></a>b545ccc3</h3>

<pre>
commit b545ccc31104807347c265b57a66c1cbedefee7f
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Mon Jun 1 16:12:03 2015 -0700

    Loosen testNow() for busy machines.
    
    (But tighten up negative-going constraint.)
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_4"><a name="tests/PropertyList.py"/></a>tests/PropertyList.py</h1>

<h3 id="toc_5">Diff:</h3>

<pre>
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                import unittest
                import pickle
                
                import lsst.utils.tests as utilsTests
                import lsst.daf.base as dafBase
                import lsst.pex.exceptions as pexExcept
                
                
                class FloatSubClass(float):
                    """Intended to be something like numpy.float64, without introducing a dependency on numpy"""
                    pass
                
                
                class PropertyListTestCase(unittest.TestCase):
                    """A test case for PropertyList."""
                
                    def testConstruct(self):
                        apl = dafBase.PropertyList()
                        self.assert_(apl is not None)
                
                    def checkPickle(self, original):
                        new = pickle.loads(pickle.dumps(original))
                        self.assertEqual(original.nameCount(), new.nameCount())
                        self.assertEqual(original.getOrderedNames(), new.getOrderedNames())
                        for name in original.getOrderedNames():
                            self.assertEqual(original.get(name), new.get(name))
                            self.assertEqual(original.typeOf(name), new.typeOf(name))
                
                    def testScalar(self):
                        apl = dafBase.PropertyList()
                        apl.setBool("bool", True)
                        apl.setShort("short", 42)
                        apl.setInt("int", 2008)
                        apl.setLongLong("int64_t", 0xfeeddeadbeefL)
                        apl.setFloat("float", 3.14159)
                        apl.setDouble("double", 2.718281828459045)
                        apl.set("char*", "foo")
                        apl.setString("string", "bar")
                        apl.set("int2", 2009)
                        apl.set("dt", dafBase.DateTime("20090402T072639.314159265Z"))
                        apl.set("subclass", FloatSubClass(1.23456789))
                
                        self.assertEqual(apl.typeOf("bool"), dafBase.PropertyList.TYPE_Bool)
                        self.assertEqual(apl.getBool("bool"), True)
                        self.assertEqual(apl.typeOf("short"), dafBase.PropertyList.TYPE_Short)
                        self.assertEqual(apl.getShort("short"), 42)
                        self.assertEqual(apl.typeOf("int"), dafBase.PropertyList.TYPE_Int)
                        self.assertEqual(apl.getInt("int"), 2008)
                        self.assertEqual(apl.typeOf("int64_t"),
                                dafBase.PropertyList.TYPE_LongLong)
                        self.assertEqual(apl.getLongLong("int64_t"), 0xfeeddeadbeefL)
                        self.assertEqual(apl.typeOf("float"), dafBase.PropertyList.TYPE_Float)
                        self.assertAlmostEqual(apl.getFloat("float"), 3.14159, 6)
                        self.assertEqual(apl.typeOf("double"), dafBase.PropertyList.TYPE_Double)
                        self.assertEqual(apl.getDouble("double"), 2.718281828459045)
                        self.assertEqual(apl.typeOf("char*"), dafBase.PropertyList.TYPE_String)
                        self.assertEqual(apl.getString("char*"), "foo")
                        self.assertEqual(apl.typeOf("string"), dafBase.PropertyList.TYPE_String)
                        self.assertEqual(apl.getString("string"), "bar")
                        self.assertEqual(apl.typeOf("int2"), dafBase.PropertyList.TYPE_Int)
                        self.assertEqual(apl.getInt("int2"), 2009)
                        self.assertEqual(apl.get("int2"), 2009)
                        self.assertEqual(apl.typeOf("dt"), dafBase.PropertyList.TYPE_DateTime)
                        self.assertEqual(apl.getDateTime("dt").nsecs(), 1238657233314159265L)
                        self.assertEqual(apl.getDouble("subclass"), 1.23456789)
                        self.checkPickle(apl)
                
                    def testGetDefault(self):
                        apl = dafBase.PropertyList()
                        apl.setInt("int", 42)
                        self.assertEqual(apl.getInt("int"), 42)
                        self.assertEqual(apl.getInt("int", 2008), 42)
                        self.assertEqual(apl.getInt("foo", 2008), 2008)
                
                    def testExists(self):
                        apl = dafBase.PropertyList()
                        apl.setInt("int", 42)
                        self.assertEqual(apl.exists("int"), True)
                        self.assertEqual(apl.exists("foo"), False)
                
                    def testGetVector(self):
                        apl = dafBase.PropertyList()
                        v = (42, 2008, 1)
                        apl.setInt("ints", v)
                        apl.setInt("ints2", (10, 9, 8))
                        w = apl.getArrayInt("ints")
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v, w)
                        self.assertEqual(apl.getInt("ints2"), 8)
                        self.assertEqual(apl.getArrayInt("ints2"), (10, 9, 8))
                        w = apl.get("ints", asArray=True)
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v, w)
                        apl.setInt("int", 999)
                        x = apl.get("int")
                        self.assertEqual(x, 999)
                        x = apl.get("int", asArray=True)
                        self.assertEqual(len(x), 1)
                        self.assertEqual(x, (999,))
                
                        self.checkPickle(apl)
                
                    def testGetVector2(self):
                        apl = dafBase.PropertyList()
                        v = [42, 2008, 1]
                        apl.setInt("ints", v)
                        apl.setInt("ints2", [10, 9, 8])
                        w = apl.getArrayInt("ints")
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v[0], w[0])
                        self.assertEqual(v[1], w[1])
                        self.assertEqual(v[2], w[2])
                        self.assertEqual(apl.getInt("ints2"), 8)
                        self.assertEqual(apl.getArrayInt("ints2"), (10, 9, 8))
                
                        self.checkPickle(apl)
                
                    def testAddScalar(self):
                        apl = dafBase.PropertyList()
                        v = [42, 2008, 1]
                        apl.setInt("ints", v)
                        apl.addInt("ints", -999)
                        apl.add("other", "foo")
                        apl.add("ints", 13)
                        apl.add("subclass", FloatSubClass(1.23456789))
                        w = apl.getArrayInt("ints")
                        self.assertEqual(len(w), 5)
                        self.assertEqual(v[0], w[0])
                        self.assertEqual(v[1], w[1])
                        self.assertEqual(v[2], w[2])
                        self.assertEqual(w[3], -999)
                        self.assertEqual(w[4], 13)
                        self.assertEqual(apl.getString("other"), "foo")
                        self.assertEqual(apl.get("subclass"), 1.23456789)
                
                    def testDateTimeToString(self):
                        apl = dafBase.PropertyList()
                        apl.set("dt", dafBase.DateTime("20090402T072639.314159265Z"))
                        self.assertEqual(apl.toString(),
                                "dt = 2009-04-02T07:26:39.314159265Z\n")
                
                    def testGetScalarThrow(self):
                        apl = dafBase.PropertyList()
                        apl.setBool("bool", True)
                        apl.setShort("short", 42)
                        apl.setInt("int", 2008)
                        apl.setLongLong("int64_t", 0xfeeddeadbeefL)
                        apl.setFloat("float", 3.14159)
                        apl.setDouble("double", 2.718281828459045)
                        apl.setString("string", "bar")
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
173  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.get, "foo")</div>
              ?                                     ^^^  ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
173  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.NotFoundError, apl.get, "foo")</div>
              ?                                     ^^ +++++ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
174  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.getBool, "short")</div>
              ?                                     ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
174  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.TypeError, apl.getBool, "short")</div>
              ?                                     ^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
175  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.getBool, "int")</div>
              ?                                     ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
175  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.TypeError, apl.getBool, "int")</div>
              ?                                     ^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
176  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.getShort, "int")</div>
              ?                                     ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
176  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.TypeError, apl.getShort, "int")</div>
              ?                                     ^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
177  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.getInt, "short")</div>
              ?                                     ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
177  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.TypeError, apl.getInt, "short")</div>
              ?                                     ^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
178  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.getInt, "bool")</div>
              ?                                     ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
178  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.TypeError, apl.getInt, "bool")</div>
              ?                                     ^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
179  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.getDouble, "float")</div>
              ?                                     ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
179  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.TypeError, apl.getDouble, "float")</div>
              ?                                     ^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
180  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.getFloat, "double")</div>
              ?                                     ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
180  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.TypeError, apl.getFloat, "double")</div>
              ?                                     ^^^^ ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
181  <a href="#ee2a91c6">ee2a91c6</a> -         self.assertRaises(pexExcept.LsstException, apl.getString, "int")</div>
              ?                                     ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
181  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.TypeError, apl.getString, "int")</div>
              ?                                     ^^^^ ^^ ^
                
                    def testAddVector(self):
                        apl = dafBase.PropertyList()
                        v = [42, 2008, 1]
                        apl.set("ints", v)
                        apl.add("ints", [-42, -2008, -1])
                        subclass = (FloatSubClass(1.23), FloatSubClass(4.56), FloatSubClass(7.89))
                        apl.add("subclass", subclass)
                        self.assertEqual(apl.getArrayInt("ints"),
                                (42, 2008, 1, -42, -2008, -1))
                        self.assertEqual(apl.get("subclass"), subclass)
                
                    def testComment(self):
                        apl = dafBase.PropertyList()
                        apl.set("NAXIS", 2, "two-dimensional")
                        self.assertEqual(apl.get("NAXIS"), 2)
                        self.assertEqual(apl.getComment("NAXIS"), "two-dimensional")
                        apl.set("NAXIS", 3, "three-dimensional")
                        self.assertEqual(apl.get("NAXIS"), 3)
                        self.assertEqual(apl.getComment("NAXIS"), "three-dimensional")
                
                    def testOrder(self):
                        apl = dafBase.PropertyList()
                        apl.set("SIMPLE", True)
                        apl.set("BITPIX", -32)
                        apl.set("NAXIS", 2)
                        apl.set("RA", 3.14159, "decimal degrees")
                        apl.set("DEC", 2.71828, "decimal radians")
                        apl.set("COMMENT", "This is a test")
                        apl.add("COMMENT", "This is a test line 2")
                        correct = [
                                ("SIMPLE", True, ""),
                                ("BITPIX", -32, ""),
                                ("NAXIS", 2, ""),
                                ("RA", 3.14159, "decimal degrees"),
                                ("DEC", 2.71828, "decimal radians"),
                                ("COMMENT", "This is a test", ""),
                                ("COMMENT", "This is a test line 2", "")
                                ]
                        self.assertEqual(apl.toList(), correct)
                        apl.set("NAXIS1", 513, "length of data axis 1")
                        correct.append(("NAXIS1", 513, "length of data axis 1"))
                        self.assertEqual(apl.toList(), correct)
                        apl.set("RA", 1.414, inPlace=False)
                        del correct[3]
                        correct.append(("RA", 1.414, "decimal degrees"))
                        self.assertEqual(apl.toList(), correct)
                        apl.set("DEC", 1.732)
                        correct[3] = ("DEC", 1.732, "decimal radians")
                        self.assertEqual(apl.toList(), correct)
                        apl.set("DEC", -6.28, "")
                        correct[3] = ("DEC", -6.28, "")
                        self.assertEqual(apl.toList(), correct)
                        apl.add("COMMENT", "This is a test line 3", "")
                        correct.insert(6, ("COMMENT", "This is a test line 3", ""))
                        self.assertEqual(apl.toList(), correct)
                        apl.add("COMMENT", "This is a test line 4", "", inPlace=False)
                        correct.append(correct[4])
                        correct.append(correct[5])
                        correct.append(correct[6])
                        correct.append(("COMMENT", "This is a test line 4", ""))
                        del correct[4]
                        del correct[4]
                        del correct[4]
                        self.assertEqual(apl.toList(), correct)
                
                        self.checkPickle(apl)
                
                    def testHierarchy(self):
                        apl = dafBase.PropertyList()
                        apl.set("CURRENT", 49.5)
                        apl.set("CURRENT.foo", -32)
                        apl.set("CURRENT.bar", 2)
                        self.assertEqual(apl.get("CURRENT"), 49.5)
                        self.assertEqual(apl.get("CURRENT.foo"), -32)
                        self.assertEqual(apl.get("CURRENT.bar"), 2)
                
                        aps = dafBase.PropertySet()
                        aps.set("bottom", "x")
                        aps.set("sibling", 42)
                        apl.set("top", aps)
                        self.assertEqual(apl.get("top.bottom"), "x")
                        self.assertEqual(apl.get("top.sibling"), 42)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
265  <a href="#ecdc9472">ecdc9472</a> -         self.assertRaises(pexExcept.LsstException, apl.get, "top")</div>
              ?                                     ^^^  ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
265  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.NotFoundError, apl.get, "top")</div>
              ?                                     ^^ +++++ ^^ ^
                        self.assertEqual(apl.toString(),
                            'CURRENT = 49.500000000000\nCURRENT.foo = -32\nCURRENT.bar = 2\n'
                            'top.sibling = 42\ntop.bottom = "x"\n')
                
                        self.checkPickle(apl)
                
                    def testCastPropertySet(self):
                        """Test that we can dynamically cast a PropertySet pointer to a PropertyList; DM-1524"""
                        apl = dafBase.PropertyList()
                        apl.set("ONE", 1, "i")
                        apl.set("FIVE", 5, "v")
                        apl.set("TEN", 10, "x")
                
                        aps = apl.deepCopy()            # returns a PTR(PropertySet), not PropertyList (arguably a bug)
                        self.assertTrue(isinstance(aps, dafBase.PropertySet)) # ... but a bug that this test uses
                
                        with self.assertRaises(AttributeError):
                            print aps.getComment("FIVE")
                
                        aps = dafBase.PropertyList.cast(aps)
                        self.assertEqual(aps.getComment("FIVE"), "v")
                
                    def testCombineHierarchical(self):
                        # Test that we can perform a deep copy of a PropertyList containing a
                        # hierarchical (contains a '.') key.
                        # This was a segfault prior to addressing DM-882.
                        pl1 = dafBase.PropertyList()
                        pl1.set("a.b", 1)
                        pl2 = pl1.deepCopy() # should not segfault
                        self.assertEqual(pl1.get("a.b"), pl2.get("a.b"))
                
                def suite():
                    """Returns a suite containing all the test cases in this module."""
                
                    utilsTests.init()
                
                    suites = []
                    suites += unittest.makeSuite(PropertyListTestCase)
                    suites += unittest.makeSuite(utilsTests.MemoryTestCase)
                
                    return unittest.TestSuite(suites)
                
                def run(exit=False):
                    """Run the tests"""
                    return utilsTests.run(suite(), exit)
                
                if __name__ == '__main__':
                    run(True)
                
                # BOOST_AUTO_TEST_CASE(arrayProperties) {
                #     dafBase::PropertyList apl;
                #     std::vector<int> v;
                #     v.push_back(42);
                #     v.push_back(2008);
                #     v.push_back(1);
                #     apl.set("ints", v);
                #     apl.set("int", 365);
                #     apl.set("ints2", -42);
                #     apl.add("ints2", -2008);
                # 
                #     BOOST_CHECK_EQUAL(apl.isArray("ints"), true);
                #     BOOST_CHECK_EQUAL(apl.isArray("int"), false);
                #     BOOST_CHECK_EQUAL(apl.isArray("ints2"), true);
                #     BOOST_CHECK_EQUAL(apl.valueCount("ints"), 3U);
                #     BOOST_CHECK_EQUAL(apl.valueCount("int"), 1U);
                #     BOOST_CHECK_EQUAL(apl.valueCount("ints2"), 2U);
                #     BOOST_CHECK(apl.typeOf("ints") == typeid(int));
                #     BOOST_CHECK(apl.typeOf("int") == typeid(int));
                #     BOOST_CHECK(apl.typeOf("ints2") == typeid(int));
                # }
                # 
                # BOOST_AUTO_TEST_CASE(hierarchy) {
                #     dafBase::PropertyList apl;
                #     dafBase::PropertyList::Ptr aplp(new
                #     dafBase::PropertyList);
                # 
                #     aplp->set("pre", 1);
                #     apl.set("apl1", aplp);
                #     aplp->set("post", 2);
                #     apl.set("int", 42);
                #     apl.set("apl2", dafBase::PropertyList::Ptr(new
                #     dafBase::PropertyList));
                #     apl.get<dafBase::PropertyList::Ptr>("apl2")->set("plus", 10.24);
                #     apl.set("apl2.minus", -10.24);
                #     apl.set("apl3.sub1", "foo");
                #     apl.set("apl3.sub2", "bar");
                # 
                #     BOOST_CHECK(apl.exists("apl1"));
                #     BOOST_CHECK(apl.exists("apl2"));
                #     BOOST_CHECK(apl.exists("apl3"));
                #     BOOST_CHECK(apl.exists("apl1.pre"));
                #     BOOST_CHECK(apl.exists("apl1.post"));
                #     BOOST_CHECK(apl.exists("apl2.plus"));
                #     BOOST_CHECK(apl.exists("apl2.minus"));
                #     BOOST_CHECK(apl.exists("apl3.sub1"));
                #     BOOST_CHECK(apl.exists("apl3.sub2"));
                # 
                #     BOOST_CHECK(apl.isPropertyListPtr("apl1"));
                #     BOOST_CHECK(apl.isPropertyListPtr("apl2"));
                #     BOOST_CHECK(apl.isPropertyListPtr("apl3"));
                #     BOOST_CHECK(!apl.isPropertyListPtr("int"));
                #     BOOST_CHECK(!apl.isPropertyListPtr("apl1.pre"));
                #     BOOST_CHECK(!apl.isPropertyListPtr("apl1.post"));
                #     BOOST_CHECK(!apl.isPropertyListPtr("apl2.plus"));
                #     BOOST_CHECK(!apl.isPropertyListPtr("apl2.minus"));
                #     BOOST_CHECK(!apl.isPropertyListPtr("apl3.sub1"));
                #     BOOST_CHECK(!apl.isPropertyListPtr("apl3.sub2"));
                # 
                #     dafBase::PropertyList::Ptr aplp1 =
                #     apl.get<dafBase::PropertyList::Ptr>("apl1");
                #     dafBase::PropertyList::Ptr aplp2 =
                #     apl.get<dafBase::PropertyList::Ptr>("apl2");
                #     dafBase::PropertyList::Ptr aplp3 =
                #     apl.get<dafBase::PropertyList::Ptr>("apl3");
                #     BOOST_CHECK(aplp1);
                #     BOOST_CHECK(aplp2);
                #     BOOST_CHECK(aplp3);
                #     BOOST_CHECK(aplp1 == aplp);
                #     BOOST_CHECK(aplp1->exists("pre"));
                #     BOOST_CHECK(aplp1->exists("post"));
                #     BOOST_CHECK(aplp2->exists("plus"));
                #     BOOST_CHECK(aplp2->exists("minus"));
                #     BOOST_CHECK(aplp3->exists("sub1"));
                #     BOOST_CHECK(aplp3->exists("sub2"));
                #     BOOST_CHECK_EQUAL(aplp1->get<int>("pre"), 1);
                #     BOOST_CHECK_EQUAL(aplp1->get<int>("post"), 2);
                #     BOOST_CHECK_EQUAL(aplp2->get<double>("plus"), 10.24);
                #     BOOST_CHECK_EQUAL(aplp2->get<double>("minus"), -10.24);
                #     BOOST_CHECK_EQUAL(aplp3->get<std::string>("sub1"), "foo");
                #     BOOST_CHECK_EQUAL(aplp3->get<std::string>("sub2"), "bar");
                # 
                #     // Make sure checking a subproperty doesn't create it.
                #     BOOST_CHECK(!apl.exists("apl2.pre"));
                #     BOOST_CHECK(!apl.exists("apl2.pre"));
                #     // Make sure checking an element doesn't create it.
                #     BOOST_CHECK(!apl.exists("apl4"));
                #     BOOST_CHECK(!apl.exists("apl4"));
                #     // Make sure checking a subproperty with a nonexistent parent doesn't
                #     // create it.
                #     BOOST_CHECK(!apl.exists("apl4.sub"));
                #     BOOST_CHECK(!apl.exists("apl4.sub"));
                #     // Make sure checking a subproperty doesn't create its parent.
                #     BOOST_CHECK(!apl.exists("apl4"));
                # }
                # 
                # BOOST_AUTO_TEST_CASE(variousThrows) {
                #     dafBase::PropertyList apl;
                #     apl.set("int", 42);
                #     BOOST_CHECK_THROW(apl.set("int.sub", "foo"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
415  <a href="#ee2a91c6">ee2a91c6</a> - #                       lsst::pex::exceptions::InvalidParameterException);</div>
              ?                                                                 ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
415  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::InvalidParameterError);</div>
              ?                                                                 ^^ ^
                #     BOOST_CHECK_THROW(apl.get<double>("int"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(apl.get<double>("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
418  <a href="#ee2a91c6">ee2a91c6</a> - #                       lsst::pex::exceptions::NotFoundException);</div>
              ?                                                         ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
418  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::NotFoundError);</div>
              ?                                                         ^^ ^
                #     BOOST_CHECK_THROW(apl.getArray<double>("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
420  <a href="#ee2a91c6">ee2a91c6</a> - #                       lsst::pex::exceptions::NotFoundException);</div>
              ?                                                         ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
420  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::NotFoundError);</div>
              ?                                                         ^^ ^
                #     BOOST_CHECK_THROW(apl.typeOf("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
422  <a href="#ee2a91c6">ee2a91c6</a> - #                       lsst::pex::exceptions::NotFoundException);</div>
              ?                                                         ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
422  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::NotFoundError);</div>
              ?                                                         ^^ ^
                #     BOOST_CHECK_THROW(apl.add("int", 4.2),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
424  <a href="#ee2a91c6">ee2a91c6</a> - #                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                           ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
424  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::DomainError);</div>
                #     std::vector<double> v;
                #     v.push_back(3.14159);
                #     v.push_back(2.71828);
                #     BOOST_CHECK_THROW(apl.add("int", v),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
429  <a href="#ee2a91c6">ee2a91c6</a> - #                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                           ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
429  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::DomainError);</div>
                #     BOOST_CHECK_NO_THROW(apl.remove("foo.bar"));
                #     BOOST_CHECK_NO_THROW(apl.remove("int.sub"));
                # }
                # 
                # BOOST_AUTO_TEST_CASE(names) {
                #     dafBase::PropertyList apl;
                #     apl.set("apl1.pre", 1);
                #     apl.set("apl1.post", 2);
                #     apl.set("int", 42);
                #     apl.set("double", 3.14);
                #     apl.set("apl2.plus", 10.24);
                #     apl.set("apl2.minus", -10.24);
                # 
                #     BOOST_CHECK_EQUAL(apl.nameCount(), 4U);
                #     BOOST_CHECK_EQUAL(apl.nameCount(false), 8U);
                # 
                #     std::vector<std::string> v = apl.names();
                #     BOOST_CHECK_EQUAL(v.size(), 4U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "double");
                #     BOOST_CHECK_EQUAL(v[1], "int");
                #     BOOST_CHECK_EQUAL(v[2], "apl1");
                #     BOOST_CHECK_EQUAL(v[3], "apl2");
                #     v = apl.names(false);
                #     BOOST_CHECK_EQUAL(v.size(), 8U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "double");
                #     BOOST_CHECK_EQUAL(v[1], "int");
                #     BOOST_CHECK_EQUAL(v[2], "apl1");
                #     BOOST_CHECK_EQUAL(v[3], "apl1.post");
                #     BOOST_CHECK_EQUAL(v[4], "apl1.pre");
                #     BOOST_CHECK_EQUAL(v[5], "apl2");
                #     BOOST_CHECK_EQUAL(v[6], "apl2.minus");
                #     BOOST_CHECK_EQUAL(v[7], "apl2.plus");
                # }
                # 
                # BOOST_AUTO_TEST_CASE(paramNames) {
                #     dafBase::PropertyList apl;
                #     apl.set("apl1.pre", 1);
                #     apl.set("apl1.post", 2);
                #     apl.set("int", 42);
                #     apl.set("double", 3.14);
                #     apl.set("apl2.plus", 10.24);
                #     apl.set("apl2.minus", -10.24);
                # 
                #     std::vector<std::string> v = apl.paramNames();
                #     BOOST_CHECK_EQUAL(v.size(), 2U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "double");
                #     BOOST_CHECK_EQUAL(v[1], "int");
                #     v = apl.paramNames(false);
                #     BOOST_CHECK_EQUAL(v.size(), 6U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "double");
                #     BOOST_CHECK_EQUAL(v[1], "int");
                #     BOOST_CHECK_EQUAL(v[2], "apl1.post");
                #     BOOST_CHECK_EQUAL(v[3], "apl1.pre");
                #     BOOST_CHECK_EQUAL(v[4], "apl2.minus");
                #     BOOST_CHECK_EQUAL(v[5], "apl2.plus");
                # }
                # 
                # BOOST_AUTO_TEST_CASE(propertySetNames) {
                #     dafBase::PropertyList apl;
                #     apl.set("apl1.pre", 1);
                #     apl.set("apl1.post", 2);
                #     apl.set("int", 42);
                #     apl.set("double", 3.14);
                #     apl.set("apl2.plus", 10.24);
                #     apl.set("apl2.minus", -10.24);
                #     apl.set("apl3.sub.subsub", "foo");
                # 
                #     std::vector<std::string> v = apl.propertySetNames();
                #     BOOST_CHECK_EQUAL(v.size(), 3U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "apl1");
                #     BOOST_CHECK_EQUAL(v[1], "apl2");
                #     BOOST_CHECK_EQUAL(v[2], "apl3");
                #     v = apl.propertySetNames(false);
                #     BOOST_CHECK_EQUAL(v.size(), 4U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "apl1");
                #     BOOST_CHECK_EQUAL(v[1], "apl2");
                #     BOOST_CHECK_EQUAL(v[2], "apl3");
                #     BOOST_CHECK_EQUAL(v[3], "apl3.sub");
                # }
                # 
                # BOOST_AUTO_TEST_CASE(getAs) {
                #     dafBase::PropertyList apl;
                #     apl.set("bool", true);
                #     apl.set("char", 'A');
                #     short s = 42;
                #     apl.set("short", s);
                #     apl.set("int", 2008);
                #     apl.set("int64_t", 0xfeeddeadbeefLL);
                #     float f = 3.14159;
                #     apl.set("float", f);
                #     double d = 2.718281828459045;
                #     apl.set("double", d);
                #     apl.set<std::string>("char*", "foo");
                #     apl.set("char*2", "foo2");
                #     apl.set("string", std::string("bar"));
                #     dafBase::PropertyList::Ptr aplp(new
                #     dafBase::PropertyList);
                #     aplp->set("bottom", "x");
                #     apl.set("top", aplp);
                # 
                #     BOOST_CHECK_EQUAL(apl.getAsBool("bool"), true);
                #     BOOST_CHECK_THROW(apl.getAsBool("char"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(apl.getAsInt("bool"), 1);
                #     BOOST_CHECK_EQUAL(apl.getAsInt("char"), static_cast<int>('A'));
                #     BOOST_CHECK_EQUAL(apl.getAsInt("short"), 42);
                #     BOOST_CHECK_EQUAL(apl.getAsInt("int"), 2008);
                #     BOOST_CHECK_THROW(apl.getAsInt("int64_t"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(apl.getAsInt64("bool"), 1LL);
                #     BOOST_CHECK_EQUAL(apl.getAsInt64("char"), static_cast<int64_t>('A'));
                #     BOOST_CHECK_EQUAL(apl.getAsInt64("short"), 42LL);
                #     BOOST_CHECK_EQUAL(apl.getAsInt64("int"), 2008LL);
                #     BOOST_CHECK_EQUAL(apl.getAsInt64("int64_t"), 0xfeeddeadbeefLL);
                #     BOOST_CHECK_THROW(apl.getAsInt64("float"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("bool"), 1.0);
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("char"), static_cast<double>('A'));
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("short"), 42.0);
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("int"), 2008.0);
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("int64_t"),
                #                       static_cast<double>(0xfeeddeadbeefLL));
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("float"), 3.14159f);
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("double"), 2.718281828459045);
                #     BOOST_CHECK_THROW(apl.getAsDouble("char*"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(apl.getAsString("char"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(apl.getAsString("char*"), "foo");
                #     BOOST_CHECK_EQUAL(apl.getAsString("char*2"), "foo2");
                #     BOOST_CHECK_EQUAL(apl.getAsString("string"), "bar");
                #     BOOST_CHECK_THROW(apl.getAsString("int"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(apl.getAsString("top.bottom"), "x");
                #     BOOST_CHECK_EQUAL(apl.getAsPropertyListPtr("top"), aplp);
                #     BOOST_CHECK_THROW(apl.getAsPropertyListPtr("top.bottom"),
                #                       boost::bad_any_cast);
                # }
                # 
                # BOOST_AUTO_TEST_CASE(combine) {
                #     dafBase::PropertyList apl;
                #     apl.set("apl1.pre", 1);
                #     apl.set("apl1.post", 2);
                #     apl.set("int", 42);
                #     apl.set("double", 3.14);
                #     apl.set("apl2.plus", 10.24);
                #     apl.set("apl2.minus", -10.24);
                #     apl.set("apl3.sub.subsub", "foo");
                # 
                #     dafBase::PropertyList::Ptr aplp(new
                #     dafBase::PropertyList);
                #     aplp->set("apl1.pre", 3);
                #     aplp->add("apl1.pre", 4);
                #     aplp->set("int", 2008);
                #     aplp->set("apl2.foo", "bar");
                #     aplp->set("apl4.top", "bottom");
                # 
                #     apl.combine(aplp);
                # 
                #     BOOST_CHECK(apl.isPropertyListPtr("apl1"));
                #     BOOST_CHECK(apl.isPropertyListPtr("apl2"));
                #     BOOST_CHECK(apl.isPropertyListPtr("apl3"));
                #     BOOST_CHECK(apl.isPropertyListPtr("apl3.sub"));
                #     BOOST_CHECK(apl.isPropertyListPtr("apl4"));
                #     BOOST_CHECK(!apl.isArray("apl1"));
                #     BOOST_CHECK(apl.isArray("apl1.pre"));
                #     BOOST_CHECK(!apl.isArray("apl1.post"));
                #     BOOST_CHECK(!apl.isArray("apl2"));
                #     BOOST_CHECK(!apl.isArray("apl2.plus"));
                #     BOOST_CHECK(!apl.isArray("apl2.minus"));
                #     BOOST_CHECK(!apl.isArray("apl2.foo"));
                #     BOOST_CHECK(!apl.isArray("apl3"));
                #     BOOST_CHECK(!apl.isArray("apl3.sub"));
                #     BOOST_CHECK(!apl.isArray("apl3.subsub"));
                #     BOOST_CHECK(!apl.isArray("apl4"));
                #     BOOST_CHECK(!apl.isArray("apl4.top"));
                #     BOOST_CHECK(apl.isArray("int"));
                #     BOOST_CHECK(!apl.isArray("double"));
                #     BOOST_CHECK_EQUAL(apl.valueCount("apl1.pre"), 3U);
                #     BOOST_CHECK_EQUAL(apl.valueCount("int"), 2U);
                #     std::vector<int> v = apl.getArray<int>("apl1.pre");
                #     BOOST_CHECK_EQUAL(v[0], 1);
                #     BOOST_CHECK_EQUAL(v[1], 3);
                #     BOOST_CHECK_EQUAL(v[2], 4);
                #     v = apl.getArray<int>("int");
                #     BOOST_CHECK_EQUAL(v[0], 42);
                #     BOOST_CHECK_EQUAL(v[1], 2008);
                # }
                # 
                # BOOST_AUTO_TEST_CASE(combineThrow) {
                #     dafBase::PropertyList apl;
                #     apl.set("int", 42);
                # 
                #     dafBase::PropertyList::Ptr aplp(new
                #     dafBase::PropertyList);
                #     aplp->set("int", 3.14159);
                # 
                #     BOOST_CHECK_THROW(apl.combine(aplp),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
628  <a href="#ee2a91c6">ee2a91c6</a> - #                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                           ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
628  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::DomainError);</div>
                # }
                # 
                # BOOST_AUTO_TEST_CASE(remove) {
                #     dafBase::PropertyList apl;
                #     apl.set("int", 42);
                #     apl.set("double", 3.14159);
                #     apl.set("apl1.plus", 1);
                #     apl.set("apl1.minus", -1);
                #     apl.set("apl1.zero", 0);
                #     BOOST_CHECK_EQUAL(apl.nameCount(false), 6U);
                # 
                #     apl.remove("int");
                #     BOOST_CHECK(!apl.exists("int"));
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("double"), 3.14159);
                #     BOOST_CHECK_EQUAL(apl.getAsInt("apl1.plus"), 1);
                #     BOOST_CHECK_EQUAL(apl.getAsInt("apl1.minus"), -1);
                #     BOOST_CHECK_EQUAL(apl.getAsInt("apl1.zero"), 0);
                #     BOOST_CHECK_EQUAL(apl.nameCount(false), 5U);
                # 
                #     apl.remove("apl1.zero");
                #     BOOST_CHECK(!apl.exists("int"));
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("double"), 3.14159);
                #     BOOST_CHECK(!apl.exists("apl1.zero"));
                #     BOOST_CHECK_EQUAL(apl.getAsInt("apl1.plus"), 1);
                #     BOOST_CHECK_EQUAL(apl.getAsInt("apl1.minus"), -1);
                #     BOOST_CHECK_EQUAL(apl.nameCount(false), 4U);
                # 
                #     apl.remove("apl1");
                #     BOOST_CHECK(!apl.exists("int"));
                #     BOOST_CHECK_EQUAL(apl.getAsDouble("double"), 3.14159);
                #     BOOST_CHECK(!apl.exists("apl1"));
                #     BOOST_CHECK(!apl.exists("apl1.plus"));
                #     BOOST_CHECK(!apl.exists("apl1.minus"));
                #     BOOST_CHECK(!apl.exists("apl1.zero"));
                #     BOOST_CHECK_EQUAL(apl.nameCount(false), 1U);
                # 
                #     apl.remove("double");
                #     BOOST_CHECK(!apl.exists("int"));
                #     BOOST_CHECK(!apl.exists("double"));
                #     BOOST_CHECK(!apl.exists("apl1"));
                #     BOOST_CHECK(!apl.exists("apl1.plus"));
                #     BOOST_CHECK(!apl.exists("apl1.minus"));
                #     BOOST_CHECK(!apl.exists("apl1.zero"));
                #     BOOST_CHECK_EQUAL(apl.nameCount(false), 0U);
                # }
                # 
                # BOOST_AUTO_TEST_CASE(deepCopy) {
                #     dafBase::PropertyList apl;
                #     apl.set("int", 42);
                #     dafBase::PropertyList::Ptr aplp(new
                #     dafBase::PropertyList);
                #     aplp->set("bottom", "x");
                #     apl.set("top", aplp);
                # 
                #     dafBase::PropertyList::Ptr aplp2 = apl.deepCopy();
                #     BOOST_CHECK(aplp2->exists("int"));
                #     BOOST_CHECK(aplp2->exists("top.bottom"));
                #     BOOST_CHECK_EQUAL(aplp2->getAsInt("int"), 42);
                #     BOOST_CHECK_EQUAL(aplp2->getAsString("top.bottom"), "x");
                #     // Make sure it was indeed a deep copy.
                #     BOOST_CHECK(aplp2->getAsPropertyListPtr("top") != aplp);
                #     apl.set("int", 2008);
                #     apl.set("top.bottom", "y");
                #     BOOST_CHECK_EQUAL(apl.getAsInt("int"), 2008);
                #     BOOST_CHECK_EQUAL(apl.getAsString("top.bottom"), "y");
                #     BOOST_CHECK_EQUAL(aplp->getAsString("bottom"), "y");
                #     BOOST_CHECK_EQUAL(aplp2->getAsInt("int"), 42);
                #     BOOST_CHECK_EQUAL(aplp2->getAsString("top.bottom"), "x");
                # }
                # 
                # BOOST_AUTO_TEST_CASE(toString) {
                #     dafBase::PropertyList apl;
                #     apl.set("bool", true);
                #     apl.set("char", '*');
                #     short s = 42;
                #     apl.set("short", s);
                #     apl.set("int", 2008);
                #     apl.set("int64_t", 0xfeeddeadbeefLL);
                #     float f = 3.14159;
                #     apl.set("float", f);
                #     double d = 2.718281828459045;
                #     apl.set("double", d);
                #     apl.set<std::string>("char*", "foo");
                #     apl.set("char*2", "foo2");
                #     apl.set("string", std::string("bar"));
                #     apl.set("apl1.pre", 1);
                #     apl.set("apl1.post", 2);
                #     apl.set("apl2.plus", 10.24);
                #     apl.set("apl2.minus", -10.24);
                #     apl.set("apl3.sub.subsub", "foo");
                #     apl.add("v", 10);
                #     apl.add("v", 9);
                #     apl.add("v", 8);
                # 
                #     BOOST_CHECK_EQUAL(apl.toString(),
                #         "bool = 1\n"
                #         "char = '*'\n"
                #         "char* = \"foo\"\n"
                #         "char*2 = \"foo2\"\n"
                #         "double = 2.71828\n"
                #         "float = 3.14159\n"
                #         "int = 2008\n"
                #         "int64_t = 280297596632815\n"
                #         "apl1 = {\n"
                #         "..post = 2\n"
                #         "..pre = 1\n"
                #         "}\n"
                #         "apl2 = {\n"
                #         "..minus = -10.24\n"
                #         "..plus = 10.24\n"
                #         "}\n"
                #         "apl3 = {\n"
                #         "..sub = {\n"
                #         "....subsub = \"foo\"\n"
                #         "..}\n"
                #         "}\n"
                #         "short = 42\n"
                #         "string = \"bar\"\n"
                #         "v = [ 10, 9, 8 ]\n"
                #         );
                #     BOOST_CHECK_EQUAL(apl.toString(true),
                #         "bool = 1\n"
                #         "char = '*'\n"
                #         "char* = \"foo\"\n"
                #         "char*2 = \"foo2\"\n"
                #         "double = 2.71828\n"
                #         "float = 3.14159\n"
                #         "int = 2008\n"
                #         "int64_t = 280297596632815\n"
                #         "apl1 = { ... }\n"
                #         "apl2 = { ... }\n"
                #         "apl3 = { ... }\n"
                #         "short = 42\n"
                #         "string = \"bar\"\n"
                #         "v = [ 10, 9, 8 ]\n"
                #         );
                # }
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="ee2a91c6"/></a>ee2a91c6</h3>

<pre>
commit ee2a91c67a4aa6484cd323b788fc7813615051a6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Sat Nov 6 15:19:51 2010 +0000

    Merge from ticket #676 (order and comments for properties).
</pre>
<h3><a name="ecdc9472"/></a>ecdc9472</h3>

<pre>
commit ecdc94728b037204645a67cb40253943fdecf613
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Thu May 2 21:03:57 2013 -0700

    Add Python interface to allow PropertySets to be added to PropertyLists.
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="ee7c5445"/></a>ee7c5445</h3>

<pre>
commit ee7c544513b5a8ce704733c028019930be619168
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 14:22:00 2014 -0400

    Adapt to changes in Python Swig interface (DM-827)
</pre>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_6"><a name="src/PropertySet.cc"/></a>src/PropertySet.cc</h1>

<h3 id="toc_7">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
18   <a href="#3c68fcdc">3c68fcdc</a> -  * GNU General Public License for more details.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
18   <a href="#25738fd8">25738fd8</a> +  * GNU General Public License for more detailTypeErrors.</div>
              ?                                              +++++++++
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** @file
                  * @ingroup daf_base
                  *
                  * @brief Implementation for PropertySet class
                  *
                  * @version $Revision$
                  * @date $Date$
                  *
                  * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                  */
                
                #include "lsst/daf/base/PropertySet.h"
                
                #include <algorithm>
                #include <iomanip>
                #include <sstream>
                #include <stdexcept>
                
                #include "lsst/pex/exceptions/Runtime.h"
                #include "lsst/daf/base/DateTime.h"
                
                namespace dafBase = lsst::daf::base;
                namespace pexExcept = lsst::pex::exceptions;
                
                using namespace std;
                
                /** Constructor.
                  @param[in] flat false (default) = flatten hierarchy by ignoring dots in names
                  */
                dafBase::PropertySet::PropertySet(bool flat) : Citizen(typeid(*this)), _flat(flat) {
                }
                
                /** Destructor.
                  */
                dafBase::PropertySet::~PropertySet(void) {
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // Accessors
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Copy the PropertySet and all of its contents.
                  * @return PropertySet::Ptr pointing to the new copy.
                  */
                dafBase::PropertySet::Ptr dafBase::PropertySet::deepCopy(void) const {
                    Ptr n(new PropertySet(_flat));
                    for (AnyMap::const_iterator i = _map.begin(); i != _map.end(); ++i) {
                        if (i->second->back().type() == typeid(Ptr)) {
                            for (vector<boost::any>::const_iterator j =
                                 i->second->begin(); j != i->second->end(); ++j) {
                                Ptr p = boost::any_cast<Ptr>(*j);
                                if (p.get() == 0) {
                                    n->add(i->first, Ptr());
                                } else {
                                    n->add(i->first, p->deepCopy());
                                }
                            }
                        } else {
                            boost::shared_ptr< vector<boost::any> > vp(
                                new vector<boost::any>(*(i->second)));
                            n->_map[i->first] = vp;
                        }
                    }
                    return n;
                }
                
                /** Get the number of names in the PropertySet, optionally including those in
                  * subproperties.  The name of the subproperty is counted in that case.
                  * @param[in] topLevelOnly true (default) = don't include subproperties.
                  * @return Number of names.
                  */
                size_t dafBase::PropertySet::nameCount(bool topLevelOnly) const {
                    int n = 0;
                    for (AnyMap::const_iterator i = _map.begin(); i != _map.end(); ++i) {
                        ++n;
                        if (!topLevelOnly && i->second->back().type() == typeid(Ptr)) {
                            Ptr p = boost::any_cast<Ptr>(i->second->back());
                            if (p.get() != 0) {
                                n += p->nameCount(false);
                            }
                        }
                    }
                    return n;
                }
                
                /** Get the names in the PropertySet, optionally including those in
                  * subproperties.  The name of the subproperty is included in that case.
                  * Hierarchical subproperty names are separated by a period.
                  * @param[in] topLevelOnly true (default) = don't include subproperties.
                  * @return Vector of names.
                  */
                vector<string> dafBase::PropertySet::names(bool topLevelOnly) const {
                    vector<string> v;
                    for (AnyMap::const_iterator i = _map.begin(); i != _map.end(); ++i) {
                        v.push_back(i->first);
                        if (!topLevelOnly && i->second->back().type() == typeid(Ptr)) {
                            Ptr p = boost::any_cast<Ptr>(i->second->back());
                            if (p.get() != 0) {
                                vector<string> w = p->names(false);
                                for (vector<string>::const_iterator k = w.begin();
                                     k != w.end(); ++k) {
                                    v.push_back(i->first + "." + *k);
                                }
                            }
                        }
                    }
                    return v;
                }
                
                /** Get the names of parameters (non-subproperties) in the PropertySet,
                  * optionally including those in subproperties.  Hierarchical subproperty
                  * names are separated by a period.
                  * @param[in] topLevelOnly true (default) = don't include subproperties.
                  * @return Vector of parameter names.
                  */
                vector<string>
                dafBase::PropertySet::paramNames(bool topLevelOnly) const {
                    vector<string> v;
                    for (AnyMap::const_iterator i = _map.begin(); i != _map.end(); ++i) {
                        if (i->second->back().type() == typeid(Ptr)) {
                            Ptr p = boost::any_cast<Ptr>(i->second->back());
                            if (p.get() != 0 && !topLevelOnly) {
                                vector<string> w = p->paramNames(false);
                                for (vector<string>::const_iterator k = w.begin();
                                     k != w.end(); ++k) {
                                    v.push_back(i->first + "." + *k);
                                }
                            }
                        } else {
                            v.push_back(i->first);
                        }
                    }
                    return v;
                }
                
                /** Get the names of subproperties in the PropertySet, optionally including
                  * those in subproperties.  Hierarchical subproperty names are separated by a
                  * period.
                  * @param[in] topLevelOnly true (default) = don't include subproperties.
                  * @return Vector of subproperty names.
                  */
                vector<string>
                dafBase::PropertySet::propertySetNames(bool topLevelOnly) const {
                    vector<string> v;
                    for (AnyMap::const_iterator i = _map.begin(); i != _map.end(); ++i) {
                        if (i->second->back().type() == typeid(Ptr)) {
                            v.push_back(i->first);
                            Ptr p = boost::any_cast<Ptr>(i->second->back());
                            if (p.get() != 0 && !topLevelOnly) {
                                vector<string> w = p->propertySetNames(false);
                                for (vector<string>::const_iterator k = w.begin();
                                     k != w.end(); ++k) {
                                    v.push_back(i->first + "." + *k);
                                }
                            }
                        }
                    }
                    return v;
                }
                
                /** Determine if a name (possibly hierarchical) exists.
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return true if property exists.
                  */
                bool dafBase::PropertySet::exists(std::string const& name) const {
                    return _find(name) != _map.end();
                }
                
                /** Determine if a name (possibly hierarchical) has multiple values.
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return true if property exists and has more than one value.
                  */
                bool dafBase::PropertySet::isArray(std::string const& name) const {
                    AnyMap::const_iterator i = _find(name);
                    return i != _map.end() && i->second->size() > 1U;
                }
                
                /** Determine if a name (possibly hierarchical) is a subproperty.
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return true if property exists and its values are PropertySet::Ptrs.
                  */
                bool dafBase::PropertySet::isPropertySetPtr(std::string const& name) const {
                    AnyMap::const_iterator i = _find(name);
                    return i != _map.end() && i->second->back().type() == typeid(Ptr);
                }
                
                /** Get number of values for a property name (possibly hierarchical).
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Number of values for that property.  0 if it doesn't exist.
                  */
                size_t dafBase::PropertySet::valueCount(std::string const& name) const {
                    AnyMap::const_iterator i = _find(name);
                    if (i == _map.end()) return 0;
                    return i->second->size();
                }
                
                /** Get the type of values for a property name (possibly hierarchical).
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Type of values for that property.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
225  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
225  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
                  */
                type_info const& dafBase::PropertySet::typeOf(std::string const& name) const {
                    AnyMap::const_iterator i = _find(name);
                    if (i == _map.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
230  <a href="#5684f115">5684f115</a> -         throw LSST_EXCEPT(pexExcept::NotFoundException, name + " not found");</div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
230  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::NotFoundError, name + " not found");</div>
              ?                                               ^^ ^
                    }
                    return i->second->back().type();
                }
                
                // The following throw an exception if the type does not match exactly.
                
                /** Get the last value for a property name (possibly hierarchical).
                  * Note that the type must be explicitly specified for this template:
                  * @code int i = propertySet.get<int>("foo") @endcode
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Last value set or added.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
242  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
242  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
243  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value does not match desired type.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
243  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value does not match desired type.</div>
                  */
                template <typename T>
                T dafBase::PropertySet::get(string const& name) const { /* parasoft-suppress LsstDm-3-4a LsstDm-4-6 "allow template over bool" */
                    AnyMap::const_iterator i = _find(name);
                    if (i == _map.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
249  <a href="#5684f115">5684f115</a> -         throw LSST_EXCEPT(pexExcept::NotFoundException, name + " not found");</div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
249  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::NotFoundError, name + " not found");</div>
              ?                                               ^^ ^
                    }
                    try {
                        return boost::any_cast<T>(i->second->back());
                    }
                    catch (boost::bad_any_cast) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
255  <a href="#a494ae4a">a494ae4a</a> -         throw LSST_EXCEPT(TypeMismatchException, name);</div>
              ?                           --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
255  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::TypeError, name);</div>
              ?                             ^      ^^^^^^^^^ ^
                    }
                    // not reached
                    return boost::any_cast<T>(i->second->back());
                }
                
                /** Get the last value for a property name (possibly hierarchical).
                  * Returns the provided @a defaultValue if the property does not exist.
                  * Note that the type must be explicitly specified for this template:
                  * @code int i = propertySet.get<int>("foo", 42) @endcode
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @param[in] defaultValue Default value to return if property does not exist.
                  * @return Last value set or added.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
268  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value does not match desired type.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
268  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value does not match desired type.</div>
                  */
                template <typename T>
                T dafBase::PropertySet::get(string const& name, T const& defaultValue) const { /* parasoft-suppress LsstDm-3-4a LsstDm-4-6 "allow template over bool" */
                    AnyMap::const_iterator i = _find(name);
                    if (i == _map.end()) {
                        return defaultValue;
                    }
                    try {
                        return boost::any_cast<T>(i->second->back());
                    }
                    catch (boost::bad_any_cast) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
280  <a href="#a494ae4a">a494ae4a</a> -         throw LSST_EXCEPT(TypeMismatchException, name);</div>
              ?                           --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
280  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::TypeError, name);</div>
              ?                             ^      ^^^^^^^^^ ^
                    }
                    // not reached
                    return boost::any_cast<T>(i->second->back());
                }
                
                /** Get the vector of values for a property name (possibly hierarchical).
                  * Note that the type must be explicitly specified for this template:
                  * @code vector<int> v = propertySet.getArray<int>("foo") @endcode
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Vector of values.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
291  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
291  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
292  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value does not match desired type.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
292  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value does not match desired type.</div>
                  */
                template <typename T>
                vector<T> dafBase::PropertySet::getArray(string const& name) const {
                    AnyMap::const_iterator i = _find(name);
                    if (i == _map.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
298  <a href="#5684f115">5684f115</a> -         throw LSST_EXCEPT(pexExcept::NotFoundException, name + " not found");</div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
298  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::NotFoundError, name + " not found");</div>
              ?                                               ^^ ^
                    }
                    vector<T> v;
                    for (vector<boost::any>::const_iterator j = i->second->begin();
                         j != i->second->end(); ++j) {
                        try {
                            v.push_back(boost::any_cast<T>(*j));
                        }
                        catch (boost::bad_any_cast) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
307  <a href="#a494ae4a">a494ae4a</a> -             throw LSST_EXCEPT(TypeMismatchException, name);</div>
              ?                               --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
307  <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(pexExcept::TypeError, name);</div>
              ?                                 ^      ^^^^^^^^^ ^
                        }
                    }
                    return v;
                }
                
                // The following throw an exception if the conversion is inappropriate.
                
                /** Get the last value for a bool property name (possibly hierarchical).
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Value as a bool.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
318  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
318  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
319  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value is not a bool.</div>
              ?                 -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
319  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value is not a bool.</div>
              ?                  ^^ ^
                  */
                bool dafBase::PropertySet::getAsBool(std::string const& name) const { /* parasoft-suppress LsstDm-3-4a LsstDm-4-6 "for symmetry with other types" */
                    return get<bool>(name);
                }
                
                /** Get the last value for a bool/char/short/int property name (possibly
                  * hierarchical).  Unsigned int properties are not acceptable, but unsigned
                  * versions of smaller types are.
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Value as an int.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
330  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
330  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
331  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value cannot be converted to int.</div>
              ?                 -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
331  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value cannot be converted to int.</div>
              ?                  ^^ ^
                  */
                int dafBase::PropertySet::getAsInt(std::string const& name) const {
                    AnyMap::const_iterator i = _find(name);
                    if (i == _map.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
336  <a href="#5684f115">5684f115</a> -         throw LSST_EXCEPT(pexExcept::NotFoundException, name + " not found");</div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
336  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::NotFoundError, name + " not found");</div>
              ?                                               ^^ ^
                    }
                    boost::any v = i->second->back();
                    type_info const& t = v.type();
                    if (t == typeid(bool)) {
                        return boost::any_cast<bool>(v);
                    } else if (t == typeid(char)) {
                        return boost::any_cast<char>(v);
                    } else if (t == typeid(signed char)) {
                        return boost::any_cast<signed char>(v);
                    } else if (t == typeid(unsigned char)) {
                        return boost::any_cast<unsigned char>(v);
                    } else if (t == typeid(short)) {
                        return boost::any_cast<short>(v);
                    } else if (t == typeid(unsigned short)) {
                        return boost::any_cast<unsigned short>(v);
                    }
                    try {
                        return boost::any_cast<int>(v);
                    }
                    catch (boost::bad_any_cast) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
357  <a href="#a494ae4a">a494ae4a</a> -         throw LSST_EXCEPT(TypeMismatchException, name);</div>
              ?                           --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
357  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::TypeError, name);</div>
              ?                             ^      ^^^^^^^^^ ^
                    }
                    // not reached
                    return boost::any_cast<int>(v);
                }
                
                /** Get the last value for a bool/char/short/int/int64_t property name
                  * (possibly hierarchical).  Unsigned int64_t properties are not acceptable,
                  * but unsigned versions of smaller types are, except possibly unsigned long,
                  * depending on compiler.
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Value as an int64_t.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
369  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
369  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
370  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value cannot be converted to int64_t.</div>
              ?                 -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
370  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value cannot be converted to int64_t.</div>
              ?                  ^^ ^
                  */
                int64_t dafBase::PropertySet::getAsInt64(std::string const& name) const {
                    AnyMap::const_iterator i = _find(name);
                    if (i == _map.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
375  <a href="#5684f115">5684f115</a> -         throw LSST_EXCEPT(pexExcept::NotFoundException, name + " not found");</div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
375  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::NotFoundError, name + " not found");</div>
              ?                                               ^^ ^
                    }
                    boost::any v = i->second->back();
                    type_info const& t = v.type();
                    if (t == typeid(bool)) return boost::any_cast<bool>(v);
                    if (t == typeid(char)) return boost::any_cast<char>(v);
                    if (t == typeid(signed char)) return boost::any_cast<signed char>(v);
                    if (t == typeid(unsigned char)) return boost::any_cast<unsigned char>(v);
                    if (t == typeid(short)) return boost::any_cast<short>(v);
                    if (t == typeid(unsigned short)) return boost::any_cast<unsigned short>(v);
                    if (t == typeid(int)) return boost::any_cast<int>(v);
                    if (t == typeid(unsigned int)) return boost::any_cast<unsigned int>(v);
                    if (t == typeid(long)) return boost::any_cast<long>(v);
                    if (t == typeid(long long)) return boost::any_cast<long long>(v);
                    try {
                        return boost::any_cast<int64_t>(v);
                    }
                    catch (boost::bad_any_cast) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
393  <a href="#a494ae4a">a494ae4a</a> -         throw LSST_EXCEPT(TypeMismatchException, name);</div>
              ?                           --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
393  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::TypeError, name);</div>
              ?                             ^      ^^^^^^^^^ ^
                    }
                    // not reached
                    return boost::any_cast<int64_t>(v);
                }
                
                /** Get the last value for any arithmetic property name (possibly
                  * hierarchical).
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Value as a double.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
403  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
403  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
404  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value cannot be converted to double.</div>
              ?                 -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
404  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value cannot be converted to double.</div>
              ?                  ^^ ^
                  */
                double dafBase::PropertySet::getAsDouble(std::string const& name) const {
                    AnyMap::const_iterator i = _find(name);
                    if (i == _map.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
409  <a href="#5684f115">5684f115</a> -         throw LSST_EXCEPT(pexExcept::NotFoundException, name + " not found");</div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
409  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::NotFoundError, name + " not found");</div>
              ?                                               ^^ ^
                    }
                    boost::any v = i->second->back();
                    type_info const& t = v.type();
                    if (t == typeid(bool)) return boost::any_cast<bool>(v);
                    if (t == typeid(char)) return boost::any_cast<char>(v);
                    if (t == typeid(signed char)) return boost::any_cast<signed char>(v);
                    if (t == typeid(unsigned char)) return boost::any_cast<unsigned char>(v);
                    if (t == typeid(short)) return boost::any_cast<short>(v);
                    if (t == typeid(unsigned short)) return boost::any_cast<unsigned short>(v);
                    if (t == typeid(int)) return boost::any_cast<int>(v);
                    if (t == typeid(unsigned int)) return boost::any_cast<unsigned int>(v);
                    if (t == typeid(long)) return boost::any_cast<long>(v);
                    if (t == typeid(unsigned long)) return boost::any_cast<unsigned long>(v);
                    if (t == typeid(long long)) return boost::any_cast<long long>(v);
                    if (t == typeid(unsigned long long)) return boost::any_cast<unsigned long long>(v);
                    if (t == typeid(float)) return boost::any_cast<float>(v);
                    try {
                        return boost::any_cast<double>(v);
                    }
                    catch (boost::bad_any_cast) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
430  <a href="#a494ae4a">a494ae4a</a> -         throw LSST_EXCEPT(TypeMismatchException, name);</div>
              ?                           --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
430  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::TypeError, name);</div>
              ?                             ^      ^^^^^^^^^ ^
                    }
                    // not reached
                    return boost::any_cast<double>(v);
                }
                
                /** Get the last value for a string property name (possibly hierarchical).
                  * Note that properties set with <tt>char const*</tt> can be retrieved as
                  * strings using this method.
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return String value.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
441  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
441  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
442  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value is not a string.</div>
              ?                 -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
442  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value is not a string.</div>
              ?                  ^^ ^
                  */
                std::string dafBase::PropertySet::getAsString(std::string const& name) const {
                    return get<string>(name);
                }
                
                /** Get the last value for a subproperty name (possibly hierarchical).
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return PropertySet::Ptr value.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
451  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
451  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
452  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value is not a PropertySet::Ptr.</div>
              ?                 -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
452  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value is not a PropertySet::Ptr.</div>
              ?                  ^^ ^
                  */
                dafBase::PropertySet::Ptr
                dafBase::PropertySet::getAsPropertySetPtr(std::string const& name) const {
                    return get<Ptr>(name);
                }
                
                /** Get the last value for a Persistable name (possibly hierarchical).
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Persistable::Ptr value.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
462  <a href="#5684f115">5684f115</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
462  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
463  <a href="#a494ae4a">a494ae4a</a> -   * @throws TypeMismatchException Value is not a Persistable::Ptr.</div>
              ?                 -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
463  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value is not a Persistable::Ptr.</div>
              ?                  ^^ ^
                  */
                dafBase::Persistable::Ptr
                dafBase::PropertySet::getAsPersistablePtr(std::string const& name) const {
                    return get<Persistable::Ptr>(name);
                }
                
                /** Generate a string representation of the PropertySet.
                  * Use this for debugging, not for serialization/persistence.
                  * @param[in] topLevelOnly false (default) = do include subproperties.
                  * @param[in] indent String to indent lines by (default none).
                  * @return String representation of the PropertySet.
                  */
                std::string dafBase::PropertySet::toString(bool topLevelOnly,
                                                           std::string const& indent) const {
                    ostringstream s;
                    vector<string> nv = names();
                    sort(nv.begin(), nv.end());
                    for (vector<string>::const_iterator i = nv.begin(); i != nv.end(); ++i) {
                        boost::shared_ptr< vector<boost::any> > vp = _map.find(*i)->second;
                        type_info const& t = vp->back().type();
                        if (t == typeid(Ptr)) {
                            s << indent << *i << " = ";
                            if (topLevelOnly) {
                                s << "{ ... }";
                            } else {
                                Ptr p = boost::any_cast<Ptr>(vp->back());
                                if (p.get() == 0) {
                                    s << "{ NULL }";
                                } else {
                                    s << '{' << endl;
                                    s << p->toString(false, indent + "..");
                                    s << indent << '}';
                                }
                            }
                            s << endl;
                        }
                        else {
                            s << indent << _format(*i);
                        }
                    }
                    return s.str();
                }
                
                std::string dafBase::PropertySet::_format(std::string const& name) const {
                    ostringstream s;
                    s << std::showpoint; // Always show a decimal point for floats
                    AnyMap::const_iterator j = _map.find(name);
                    s << j->first << " = ";
                    boost::shared_ptr< vector<boost::any> > vp = j->second;
                    if (vp->size() > 1) {
                        s << "[ ";
                    }
                    type_info const& t = vp->back().type();
                    for (vector<boost::any>::const_iterator k = vp->begin();
                         k != vp->end(); ++k) {
                        if (k != vp->begin()) {
                            s << ", ";
                        }
                        boost::any const& v(*k);
                        if (t == typeid(bool)) {
                            s << boost::any_cast<bool>(v);
                        } else if (t == typeid(char)) {
                            s << '\'' << boost::any_cast<char>(v) << '\'';
                        } else if (t == typeid(signed char)) {
                            s << '\'' << boost::any_cast<signed char>(v) << '\'';
                        } else if (t == typeid(unsigned char)) {
                            s << '\'' << boost::any_cast<unsigned char>(v) << '\'';
                        } else if (t == typeid(short)) {
                            s << boost::any_cast<short>(v);
                        } else if (t == typeid(unsigned short)) {
                            s << boost::any_cast<unsigned short>(v);
                        } else if (t == typeid(int)) {
                            s << boost::any_cast<int>(v);
                        } else if (t == typeid(unsigned int)) {
                            s << boost::any_cast<unsigned int>(v);
                        } else if (t == typeid(long)) {
                            s << boost::any_cast<long>(v);
                        } else if (t == typeid(unsigned long)) {
                            s << boost::any_cast<unsigned long>(v);
                        } else if (t == typeid(long long)) {
                            s << boost::any_cast<long long>(v);
                        } else if (t == typeid(unsigned long long)) {
                            s << boost::any_cast<unsigned long long>(v);
                        } else if (t == typeid(float)) {
                            s << std::setprecision(7) << boost::any_cast<float>(v);
                        } else if (t == typeid(double)) {
                            s << std::setprecision(14) << boost::any_cast<double>(v);
                        } else if (t == typeid(string)) {
                            s << '"' << boost::any_cast<string>(v) << '"';
                        } else if (t == typeid(dafBase::DateTime)) {
                            s << boost::any_cast<dafBase::DateTime>(v).toString();
                        } else if (t == typeid(Ptr)) {
                            s << "{ ... }";
                        } else if (t == typeid(Persistable::Ptr)) {
                            s << "<Persistable>";
                        } else {
                            s << "<Unknown>";
                        }
                    }
                    if (j->second->size() > 1) {
                        s << " ]";
                    }
                    s << endl;
                    return s.str();
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // Modifiers
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Replace all values for a property name (possibly hierarchical) with a new
                  * value.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Value to set.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
578  <a href="#5684f115">5684f115</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
578  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void dafBase::PropertySet::set(std::string const& name, T const& value) {
                    boost::shared_ptr< vector<boost::any> > vp(new vector<boost::any>);
                    vp->push_back(value);
                    _set(name, vp);
                }
                
                /** Replace all values for a property name (possibly hierarchical) with a
                  * vector of new values.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Vector of values to set.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
591  <a href="#5684f115">5684f115</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
591  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void dafBase::PropertySet::set(std::string const& name,
                                               vector<T> const& value) {
                    if (value.empty()) return;
                    boost::shared_ptr< vector<boost::any> > vp(new vector<boost::any>);
                    vp->insert(vp->end(), value.begin(), value.end());
                    _set(name, vp);
                }
                
                /** Replace all values for a property name (possibly hierarchical) with a
                  * string value.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Character string (converted to \c std::string ).
                  */
                void dafBase::PropertySet::set(std::string const& name, char const* value) {
                    set(name, string(value));
                }
                
                /** Appends a single value to the vector of values for a property name
                  * (possibly hierarchical).  Sets the value if the property does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value Value to append.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
615  <a href="#2715d452">2715d452</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
615  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
616  <a href="#5684f115">5684f115</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
616  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void dafBase::PropertySet::add(std::string const& name, T const& value) {
                    AnyMap::iterator i = _find(name);
                    if (i == _map.end()) {
                        set(name, value);
                    }
                    else {
                        if (i->second->back().type() != typeid(T)) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
626  <a href="#2715d452">2715d452</a> -             throw LSST_EXCEPT(TypeMismatchException,</div>
              ?                               --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
626  <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(pexExcept::TypeError,</div>
              ?                                 ^      ^^^^^^^^^ ^
                                              name + " has mismatched type");
                        }
                        i->second->push_back(value);
                    }
                }
                
                // Specialize for Ptrs to check for cycles.
                template <> void dafBase::PropertySet::add<dafBase::PropertySet::Ptr>(
                    std::string const& name, Ptr const& value) {
                    AnyMap::iterator i = _find(name);
                    if (i == _map.end()) {
                        set(name, value);
                    }
                    else {
                        if (i->second->back().type() != typeid(Ptr)) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
642  <a href="#2715d452">2715d452</a> -             throw LSST_EXCEPT(TypeMismatchException,</div>
              ?                               --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
642  <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(pexExcept::TypeError,</div>
              ?                                 ^      ^^^^^^^^^ ^
                                              name + " has mismatched type");
                        }
                        _cycleCheckPtr(value, name);
                        i->second->push_back(value);
                    }
                }
                
                /** Appends a vector of values to the vector of values for a property name
                  * (possibly hierarchical).  Sets the values if the property does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value Vector of values to append.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
654  <a href="#2715d452">2715d452</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
654  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
655  <a href="#5684f115">5684f115</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
655  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  * @note
                  * May only partially add the vector if an exception occurs.
                  */
                template <typename T>
                void dafBase::PropertySet::add(std::string const& name,
                                               vector<T> const& value) {
                    AnyMap::iterator i = _find(name);
                    if (i == _map.end()) {
                        set(name, value);
                    }
                    else {
                        if (i->second->back().type() != typeid(T)) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
668  <a href="#2715d452">2715d452</a> -             throw LSST_EXCEPT(TypeMismatchException,</div>
              ?                               --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
668  <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(pexExcept::TypeError,</div>
              ?                                 ^      ^^^^^^^^^ ^
                                              name + " has mismatched type");
                        }
                        i->second->insert(i->second->end(), value.begin(), value.end());
                    }
                }
                
                // Specialize for Ptrs to check for cycles.
                template<> void dafBase::PropertySet::add<dafBase::PropertySet::Ptr>(
                    std::string const& name, vector<Ptr> const& value) {
                    AnyMap::iterator i = _find(name);
                    if (i == _map.end()) {
                        set(name, value);
                    }
                    else {
                        if (i->second->back().type() != typeid(Ptr)) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
684  <a href="#2715d452">2715d452</a> -             throw LSST_EXCEPT(TypeMismatchException,</div>
              ?                               --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
684  <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(pexExcept::TypeError,</div>
              ?                                 ^      ^^^^^^^^^ ^
                                              name + " has mismatched type");
                        }
                        _cycleCheckPtrVec(value, name);
                        i->second->insert(i->second->end(), value.begin(), value.end());
                    }
                }
                
                /** Appends a <tt>char const*</tt> value to the vector of values for a
                  * property name (possibly hierarchical).  Sets the value if the property
                  * does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value Character string value to append.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
697  <a href="#2715d452">2715d452</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
697  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
698  <a href="#5684f115">5684f115</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
698  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void dafBase::PropertySet::add(std::string const& name, char const* value) {
                    add(name, string(value));
                }
                
                /** Replaces a single value vector in the destination with one from the
                  * \a source.
                  * @param[in] dest Destination property name.
                  * @param[in] source PropertySet::Ptr for the source PropertySet.
                  * @param[in] name Property name to extract.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
709  <a href="#581fb78e">581fb78e</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
709  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
710  <a href="#581fb78e">581fb78e</a> -   * @throws InvalidParameterException Name does not exist in source.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
710  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Name does not exist in source.</div>
              ?                              ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
711  <a href="#581fb78e">581fb78e</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
711  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void dafBase::PropertySet::copy(std::string const& dest,
                                                ConstPtr source, std::string const& name) {
                    if (source.get() == 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
716  <a href="#581fb78e">581fb78e</a> -         throw LSST_EXCEPT(pexExcept::InvalidParameterException,</div>
              ?                                                       ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
716  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::InvalidParameterError,</div>
              ?                                                       ^^ ^
                                          "Missing source");
                    }
                    AnyMap::const_iterator sj = source->_find(name);
                    if (sj == source->_map.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
721  <a href="#581fb78e">581fb78e</a> -         throw LSST_EXCEPT(pexExcept::InvalidParameterException,</div>
              ?                                                       ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
721  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::InvalidParameterError,</div>
              ?                                                       ^^ ^
                                          name + " not in source");
                    }
                    remove(dest);
                    boost::shared_ptr< vector<boost::any> > vp(
                        new vector<boost::any>(*(sj->second)));
                    _set(dest, vp);
                }
                
                /** Appends all value vectors from the \a source to their corresponding
                  * properties.  Sets values if a property does not exist.
                  * @param[in] source PropertySet::Ptr for the source PropertySet.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
733  <a href="#2715d452">2715d452</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
733  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
734  <a href="#5684f115">5684f115</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
734  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  * @note
                  * May only partially combine the PropertySets if an exception occurs.
                  */
                void dafBase::PropertySet::combine(ConstPtr source) {
                    if (source.get() == 0) {
                        return;
                    }
                    vector<string> names = source->paramNames(false);
                    for (vector<string>::const_iterator i = names.begin();
                         i != names.end(); ++i) {
                        AnyMap::const_iterator sp = source->_find(*i);
                        _add(*i, sp->second);
                    }
                }
                
                /** Removes all values for a property name (possibly hierarchical).  Does
                  * nothing if the property does not exist.
                  * @param[in] name Property name to remove, possibly hierarchical.
                  */
                void dafBase::PropertySet::remove(std::string const& name) {
                    string::size_type i = name.find('.');
                    if (_flat || i == name.npos) {
                        _map.erase(name);
                        return;
                    }
                    string prefix(name, 0, i);
                    AnyMap::iterator j = _map.find(prefix);
                    if (j == _map.end() || j->second->back().type() != typeid(Ptr)) {
                        return;
                    }
                    Ptr p = boost::any_cast<Ptr>(j->second->back());
                    if (p.get() != 0) {
                        string suffix(name, i + 1);
                        p->remove(suffix);
                    }
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // Private member functions
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Finds the property name (possibly hierarchical).
                  * @param[in] name Property name to find, possibly hierarchical.
                  * @return unordered_map::iterator to the property or end() if nonexistent.
                  */
                dafBase::PropertySet::AnyMap::iterator
                dafBase::PropertySet::_find(std::string const& name) {
                    string::size_type i = name.find('.');
                    if (_flat || i == name.npos) {
                        return _map.find(name);
                    }
                    string prefix(name, 0, i);
                    AnyMap::iterator j = _map.find(prefix);
                    if (j == _map.end() || j->second->back().type() != typeid(Ptr)) {
                        return _map.end();
                    }
                    Ptr p = boost::any_cast<Ptr>(j->second->back());
                    if (p.get() == 0) {
                        return _map.end();
                    }
                    string suffix(name, i + 1);
                    AnyMap::iterator x = p->_find(suffix);
                    if (x == p->_map.end()) {
                        return _map.end();
                    }
                    return x;
                }
                
                /** Finds the property name (possibly hierarchical).  Const version.
                  * @param[in] name Property name to find, possibly hierarchical.
                  * @return unordered_map::const_iterator to the property or end().
                  */
                dafBase::PropertySet::AnyMap::const_iterator
                dafBase::PropertySet::_find(std::string const& name) const {
                    string::size_type i = name.find('.');
                    if (_flat || i == name.npos) {
                        return _map.find(name);
                    }
                    string prefix(name, 0, i);
                    AnyMap::const_iterator j = _map.find(prefix);
                    if (j == _map.end() || j->second->back().type() != typeid(Ptr)) {
                        return _map.end();
                    }
                    Ptr p = boost::any_cast<Ptr>(j->second->back());
                    if (p.get() == 0) {
                        return _map.end();
                    }
                    string suffix(name, i + 1);
                    AnyMap::const_iterator x = p->_find(suffix);
                    if (x == p->_map.end()) {
                        return _map.end();
                    }
                    return x;
                }
                
                /** Finds the property name (possibly hierarchical) and sets or replaces its
                  * value with the given vector of values.  Hook for subclass overrides of
                  * top-level setting.
                  * @param[in] name Property name to find, possibly hierarchical.
                  * @param[in] vp shared_ptr to vector of values.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
835  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
835  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void dafBase::PropertySet::_set(
                    std::string const& name, boost::shared_ptr< std::vector<boost::any> > vp) {
                    _findOrInsert(name, vp);
                }
                
                /** Finds the property name (possibly hierarchical) and appends or sets its
                  * value with the given vector of values.
                  * @param[in] name Property name to find, possibly hierarchical.
                  * @param[in] vp shared_ptr to vector of values.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
846  <a href="#ab5b2c4c">ab5b2c4c</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
846  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void dafBase::PropertySet::_add(
                    std::string const& name, boost::shared_ptr< std::vector<boost::any> > vp) {
                
                    AnyMap::const_iterator dp = _find(name);
                    if (dp == _map.end()) {
                        _set(name, vp);
                    }
                    else {
                        if (vp->back().type() != dp->second->back().type()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
857  <a href="#ab5b2c4c">ab5b2c4c</a> -             throw LSST_EXCEPT(TypeMismatchException,</div>
              ?                               --  ^^^^^^^^      ^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
857  <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(pexExcept::TypeError,</div>
              ?                                 ^      ^^^^^^^^^ ^
                                              name + " has mismatched type");
                        }
                        // Check for cycles
                        if (vp->back().type() == typeid(Ptr)) {
                            _cycleCheckAnyVec(*vp, name);
                        }
                        dp->second->insert(dp->second->end(), vp->begin(), vp->end());
                    }
                }
                
                /** Finds the property name (possibly hierarchical) and sets or replaces its
                  * value with the given vector of values.
                  * @param[in] name Property name to find, possibly hierarchical.
                  * @param[in] vp shared_ptr to vector of values.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
872  <a href="#5684f115">5684f115</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
872  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void dafBase::PropertySet::_findOrInsert(
                    std::string const& name, boost::shared_ptr< std::vector<boost::any> > vp) {
                    if (vp->back().type() == typeid(Ptr)) {
                        if (_flat) {
                            Ptr source = boost::any_cast<Ptr>(vp->back());
                            vector<string> names = source->paramNames(false);
                            for (vector<string>::const_iterator i = names.begin();
                                 i != names.end(); ++i) {
                                AnyMap::const_iterator sp = source->_find(*i);
                                _add(name + "." + *i, sp->second);
                            }
                            return;
                        }
                
                        // Check for cycles
                        _cycleCheckAnyVec(*vp, name);
                    }
                
                    string::size_type i = name.find('.');
                    if (_flat || i == name.npos) {
                        _map[name] = vp;
                        return;
                    }
                    string prefix(name, 0, i);
                    string suffix(name, i + 1);
                    AnyMap::iterator j = _map.find(prefix);
                    if (j == _map.end()) {
                        PropertySet::Ptr pp(new PropertySet);
                        pp->_findOrInsert(suffix, vp);
                        boost::shared_ptr< vector<boost::any> > temp(new vector<boost::any>);
                        temp->push_back(pp);
                        _map[prefix] = temp;
                        return;
                    }
                    else if (j->second->back().type() != typeid(Ptr)) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
909  <a href="#5684f115">5684f115</a> -         throw LSST_EXCEPT(pexExcept::InvalidParameterException,</div>
              ?                                                       ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
909  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::InvalidParameterError,</div>
              ?                                                       ^^ ^
                                          prefix +
                                          " exists but does not contain PropertySet::Ptrs");
                    }
                    Ptr p = boost::any_cast<Ptr>(j->second->back());
                    if (p.get() == 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
915  <a href="#0ed7c27e">0ed7c27e</a> -         throw LSST_EXCEPT(pexExcept::InvalidParameterException,</div>
              ?                                                       ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
915  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::InvalidParameterError,</div>
              ?                                                       ^^ ^
                                          prefix +
                                          " exists but contains null PropertySet::Ptr");
                    }
                    p->_findOrInsert(suffix, vp);
                }
                
                void dafBase::PropertySet::_cycleCheckPtrVec(std::vector<Ptr> const& v,
                                                         std::string const& name) {
                    for (vector<Ptr>::const_iterator i = v.begin(); i != v.end(); ++i) {
                        _cycleCheckPtr(*i, name);
                    }
                }
                
                void dafBase::PropertySet::_cycleCheckAnyVec(std::vector<boost::any> const& v,
                                                         std::string const& name) {
                    for (vector<boost::any>::const_iterator i = v.begin(); i != v.end(); ++i) {
                        _cycleCheckPtr(boost::any_cast<Ptr>(*i), name);
                    }
                }
                
                void dafBase::PropertySet::_cycleCheckPtr(Ptr const& v,
                                                         std::string const& name) {
                    if (v.get() == this) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
939  <a href="#2715d452">2715d452</a> -         throw LSST_EXCEPT(pexExcept::InvalidParameterException,</div>
              ?                                                       ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
939  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexExcept::InvalidParameterError,</div>
              ?                                                       ^^ ^
                                          name + " would cause a cycle");
                    }
                    vector<string> sets = v->propertySetNames(false);
                    for (vector<string>::const_iterator i = sets.begin();
                         i != sets.end(); ++i) {
                        if (v->getAsPropertySetPtr(*i).get() == this) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
946  <a href="#14b5a130">14b5a130</a> -             throw LSST_EXCEPT(pexExcept::InvalidParameterException,</div>
              ?                                                           ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
946  <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(pexExcept::InvalidParameterError,</div>
              ?                                                           ^^ ^
                                              name + " would cause a cycle");
                        }
                    }
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // Explicit template instantiations
                ///////////////////////////////////////////////////////////////////////////////
                
                /// @cond
                // Explicit template instantiations are not well understood by doxygen.
                
                #define INSTANTIATE(t) \
                    template t dafBase::PropertySet::get<t>(string const& name) const; \
                    template t dafBase::PropertySet::get<t>(string const& name, t const& defaultValue) const; \
                    template vector<t> dafBase::PropertySet::getArray<t>(string const& name) const; \
                    template void dafBase::PropertySet::set<t>(string const& name, t const& value); \
                    template void dafBase::PropertySet::set<t>(string const& name, vector<t> const& value); \
                    template void dafBase::PropertySet::add<t>(string const& name, t const& value); \
                    template void dafBase::PropertySet::add<t>(string const& name, vector<t> const& value);
                
                INSTANTIATE(bool)
                INSTANTIATE(char)
                INSTANTIATE(signed char)
                INSTANTIATE(unsigned char)
                INSTANTIATE(short)
                INSTANTIATE(unsigned short)
                INSTANTIATE(int)
                INSTANTIATE(unsigned int)
                INSTANTIATE(long)
                INSTANTIATE(unsigned long)
                INSTANTIATE(long long)
                INSTANTIATE(unsigned long long)
                INSTANTIATE(float)
                INSTANTIATE(double)
                INSTANTIATE(string)
                INSTANTIATE(dafBase::PropertySet::Ptr)
                INSTANTIATE(dafBase::Persistable::Ptr)
                INSTANTIATE(dafBase::DateTime)
                
                /// @endcond
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="14b5a130"/></a>14b5a130</h3>

<pre>
commit 14b5a1306ff7a4216b36b75a66217ee98c7e96a9
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Mon Jan 12 23:08:24 2009 +0000

    Add pointer cycle checking.  #561
</pre>
<h3><a name="ab5b2c4c"/></a>ab5b2c4c</h3>

<pre>
commit ab5b2c4cf63fa69eb918b4fe9a95ee8b51558763
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Tue Dec 11 12:00:05 2012 -0800

    Enable flattened PropertySets.  Make PropertyLists default to flat.  Add PropertySets/Lists to flattened PropertySets by using dotted names.  Refactor common code into _add().
</pre>
<h3><a name="ee2a91c6"/></a>ee2a91c6</h3>

<pre>
commit ee2a91c67a4aa6484cd323b788fc7813615051a6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Sat Nov 6 15:19:51 2010 +0000

    Merge from ticket #676 (order and comments for properties).
</pre>
<h3><a name="0ed7c27e"/></a>0ed7c27e</h3>

<pre>
commit 0ed7c27e53789ae2447c103641ebe4581c8cd9d7
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Sat Dec 13 18:04:19 2008 +0000

    Check for zero PropertySet::Ptrs. #536
</pre>
<h3><a name="2715d452"/></a>2715d452</h3>

<pre>
commit 2715d4523b801e729a8fd055f79b6b2949e58544
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Jan 13 02:38:34 2009 +0000

    Check for adding parents directly to child PropertySets.  #561
</pre>
<h3><a name="5684f115"/></a>5684f115</h3>

<pre>
commit 5684f1152b34043b04aa78a9a22e2040d334aea0
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Nov 27 00:55:47 2008 +0000

    Merged revisions 6456-6607 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/base/tickets/480
    
    ........
      r6456 | ktlim | 2008-11-22 19:10:27 -0800 (Sat, 22 Nov 2008) | 2 lines
    
      Create new ticket branch for PropertySet addition.
    ........
      r6486 | ktlim | 2008-11-24 21:51:45 -0800 (Mon, 24 Nov 2008) | 1 line
    
      Initial checkin of PropertySet skeleton.
    ........
      r6487 | ktlim | 2008-11-24 23:39:09 -0800 (Mon, 24 Nov 2008) | 1 line
    
      Begin implementing get() and set() methods.
    ........
      r6555 | ktlim | 2008-11-25 21:12:26 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Remove old DataProperty.i.
    ........
      r6556 | ktlim | 2008-11-25 21:13:21 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Add many, many test cases for PropertySet.
    ........
      r6557 | ktlim | 2008-11-25 21:14:03 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Only boost headers are needed now.  TR1 is tested for in sconsUtils.
    ........
      r6558 | ktlim | 2008-11-25 21:17:59 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Major implementation change: use a vector<boost::any> instead of a boost::any containing a vector<T>.  Simplifies the normal cases substantially.  getArray() now has to return a vector instead of a reference.  Added convenience methods to allow set() and add() with char const* (still retrieved as std::string).  Added private methods for recursive descent with multipart names.
    ........
      r6559 | ktlim | 2008-11-25 21:18:30 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Implement all PropertySet functionality.
    ........
      r6564 | ktlim | 2008-11-25 23:53:45 -0800 (Tue, 25 Nov 2008) | 1 line
    
      remove() doesn't throw, even if the name doesn't or can't exist.  Test for various exceptions.
    ........
      r6565 | ktlim | 2008-11-26 01:51:28 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Add char test cases.  Change type of exception returned by bad combine.
    ........
      r6566 | ktlim | 2008-11-26 01:57:08 -0800 (Wed, 26 Nov 2008) | 2 lines
    
      Improve exception safety for private findOrInsert() method.  Add handling for signed char.  Instantiate templates for char/signed char/unsigned char.  Improve toString() output for char types.  Change exception type returned for mismatches in combine().  Standardize on back() for type checking rather than at(0).  Add lots of doxygen comments.
    ........
      r6580 | ktlim | 2008-11-26 09:10:10 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Exclude python (for now) and tests directories from docs.  Set (a slightly more meaningful) version number.
    ........
      r6581 | ktlim | 2008-11-26 09:10:33 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Fix comment for getAsInt64().
    ........
      r6582 | ktlim | 2008-11-26 09:12:37 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Enable use of vectors, set(), add(), and getArray() from Python.  Types must be specified explicitly except for set(string) and add(string).  Only bool, int, double, string are supported for now.
    ........
      r6583 | ktlim | 2008-11-26 11:55:45 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Use pex_exceptions instead of std::runtime_error.
    ........
      r6584 | ktlim | 2008-11-26 12:36:51 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Improve PropertySet Python interface.
    ........
      r6602 | ktlim | 2008-11-26 14:56:42 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Handle topLevelOnly better.
    ........
      r6603 | ktlim | 2008-11-26 14:58:49 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Add a test for toString(true).
    ........
      r6606 | ktlim | 2008-11-26 16:53:12 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Initial Python tests.
    ........
</pre>
<h3><a name="3c68fcdc"/></a>3c68fcdc</h3>

<pre>
commit 3c68fcdc1afb25841e23651a61e59c3de82b52ca
Author: dgehrig <dgehrig@git.lsstcorp.org>
Date:   Mon Jul 12 00:06:35 2010 +0000

    adding copyright notices
</pre>
<h3><a name="a494ae4a"/></a>a494ae4a</h3>

<pre>
commit a494ae4ac055a8632a6688d128c0e3a100122ff6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Jan 13 00:15:19 2009 +0000

    Throw dafBase::TypeMismatchException instead of boost::bad_any_cast.  #564
</pre>
<h3><a name="581fb78e"/></a>581fb78e</h3>

<pre>
commit 581fb78e8c9821dfc4f8b9fbff970a8687f49c61
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Mar 10 17:43:23 2009 +0000

    Add copy() method to PropertySet.
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_8"><a name="tests/PropertyList.cc"/></a>tests/PropertyList.cc</h1>

<h3 id="toc_9">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                #include "lsst/daf/base/PropertyList.h"
                
                #define BOOST_TEST_MODULE PropertyList
                #define BOOST_TEST_DYN_LINK
                #pragma clang diagnostic push
                #pragma clang diagnostic ignored "-Wunused-variable"
                #include "boost/test/unit_test.hpp"
                #pragma clang diagnostic pop
                
                #include <algorithm>
                
                #include "lsst/pex/exceptions/Runtime.h"
                
                #define INT64CONST(x) static_cast<int64_t>(x ## LL)
                
                namespace test = boost::test_tools;
                namespace dafBase = lsst::daf::base;
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
40   <a href="#86425aff">86425aff</a> + namespace pexExcept = lsst::pex::exceptions;</div>
                
                BOOST_AUTO_TEST_SUITE(PropertyListSuite) /* parasoft-suppress LsstDm-3-2a LsstDm-3-6a LsstDm-4-6 "Boost test harness macros" */
                
                BOOST_AUTO_TEST_CASE(construct) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    dafBase::PropertyList::Ptr plp(new dafBase::PropertyList);
                    BOOST_CHECK_EQUAL(!plp, false);
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertyList);
                    BOOST_CHECK_EQUAL(!psp, false);
                }
                
                BOOST_AUTO_TEST_CASE(bases) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList::Ptr plp(new dafBase::PropertyList);
                    dafBase::PropertySet::Ptr psp = plp;
                    BOOST_CHECK_EQUAL(!plp, false);
                    boost::shared_ptr<dafBase::Persistable> pp = plp;
                    BOOST_CHECK_EQUAL(!pp, false);
                    boost::shared_ptr<dafBase::Citizen> cp = plp;
                    BOOST_CHECK_EQUAL(!cp, false);
                }
                
                BOOST_AUTO_TEST_CASE(getScalar) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("bool", true);
                    pl.set("char", '*');
                    short s = 42;
                    pl.set("short", s);
                    pl.set("int", 2008);
                    pl.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    pl.set("float", f);
                    double d = 2.718281828459045;
                    pl.set("double", d);
                    pl.set<std::string>("char*", "foo");
                    pl.set("char*2", "foo2");
                    pl.set("string", std::string("bar"));
                
                    BOOST_CHECK_EQUAL(pl.get<bool>("bool"), true);
                    BOOST_CHECK_EQUAL(pl.get<char>("char"), '*');
                    BOOST_CHECK_EQUAL(pl.get<short>("short"), 42);
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), 2008);
                    BOOST_CHECK_EQUAL(pl.get<int64_t>("int64_t"), INT64CONST(0xfeeddeadbeef));
                    BOOST_CHECK_EQUAL(pl.get<float>("float"), 3.14159f);
                    BOOST_CHECK_EQUAL(pl.get<double>("double"), 2.718281828459045);
                    BOOST_CHECK_EQUAL(pl.get<std::string>("char*"), "foo");
                    BOOST_CHECK_EQUAL(pl.get<std::string>("char*2"), "foo2");
                    BOOST_CHECK_EQUAL(pl.get<std::string>("string"), "bar");
                }
                
                BOOST_AUTO_TEST_CASE(getScalarPSP) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertyList);
                    psp->set("bool", true);
                    psp->set("char", '*');
                    short s = 42;
                    psp->set("short", s);
                    psp->set("int", 2008);
                    psp->set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    psp->set("float", f);
                    double d = 2.718281828459045;
                    psp->set("double", d);
                    psp->set<std::string>("char*", "foo");
                    psp->set("char*2", "foo2");
                    psp->set("string", std::string("bar"));
                
                    BOOST_CHECK_EQUAL(psp->get<bool>("bool"), true);
                    BOOST_CHECK_EQUAL(psp->get<char>("char"), '*');
                    BOOST_CHECK_EQUAL(psp->get<short>("short"), 42);
                    BOOST_CHECK_EQUAL(psp->get<int>("int"), 2008);
                    BOOST_CHECK_EQUAL(psp->get<int64_t>("int64_t"), INT64CONST(0xfeeddeadbeef));
                    BOOST_CHECK_EQUAL(psp->get<float>("float"), 3.14159f);
                    BOOST_CHECK_EQUAL(psp->get<double>("double"), 2.718281828459045);
                    BOOST_CHECK_EQUAL(psp->get<std::string>("char*"), "foo");
                    BOOST_CHECK_EQUAL(psp->get<std::string>("char*2"), "foo2");
                    BOOST_CHECK_EQUAL(psp->get<std::string>("string"), "bar");
                }
                
                BOOST_AUTO_TEST_CASE(resetScalar) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("bool", true);
                    pl.set("char", '*');
                    short s = 42;
                    pl.set("short", s);
                    pl.set("int", 2008);
                    pl.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    pl.set("float", f);
                    double d = 2.718281828459045;
                    pl.set("double", d);
                    pl.set<std::string>("char*", "foo");
                    pl.set("char*2", "foo2");
                    pl.set("string", std::string("bar"));
                
                    BOOST_CHECK_EQUAL(pl.get<bool>("bool"), true);
                    BOOST_CHECK_EQUAL(pl.get<char>("char"), '*');
                    BOOST_CHECK_EQUAL(pl.get<short>("short"), 42);
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), 2008);
                    BOOST_CHECK_EQUAL(pl.get<int64_t>("int64_t"), INT64CONST(0xfeeddeadbeef));
                    BOOST_CHECK_EQUAL(pl.get<float>("float"), 3.14159f);
                    BOOST_CHECK_EQUAL(pl.get<double>("double"), 2.718281828459045);
                    BOOST_CHECK_EQUAL(pl.get<std::string>("char*"), "foo");
                    BOOST_CHECK_EQUAL(pl.get<std::string>("char*2"), "foo2");
                    BOOST_CHECK_EQUAL(pl.get<std::string>("string"), "bar");
                
                    pl.set("bool", false);
                    pl.set("char", '%');
                    s = 2008;
                    pl.set("short", s);
                    pl.set("int", 42);
                    pl.set("int64_t", INT64CONST(0xcafefacade));
                    f = 2.71828;
                    pl.set("float", f);
                    d = 3.1415926535897932;
                    pl.set("double", d);
                    pl.set<std::string>("char*", "baz");
                    pl.set("char*2", "random2");
                    pl.set("string", std::string("xyzzy"));
                
                    BOOST_CHECK_EQUAL(pl.get<bool>("bool"), false);
                    BOOST_CHECK_EQUAL(pl.get<char>("char"), '%');
                    BOOST_CHECK_EQUAL(pl.get<short>("short"), 2008);
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), 42);
                    BOOST_CHECK_EQUAL(pl.get<int64_t>("int64_t"), INT64CONST(0xcafefacade));
                    BOOST_CHECK_EQUAL(pl.get<float>("float"), 2.71828f);
                    BOOST_CHECK_EQUAL(pl.get<double>("double"), 3.1415926535897932);
                    BOOST_CHECK_EQUAL(pl.get<std::string>("char*"), "baz");
                    BOOST_CHECK_EQUAL(pl.get<std::string>("char*2"), "random2");
                    BOOST_CHECK_EQUAL(pl.get<std::string>("string"), "xyzzy");
                }
                
                BOOST_AUTO_TEST_CASE(getDefault) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("int", 42);
                
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), 42);
                    BOOST_CHECK_EQUAL(pl.get<int>("int", 2008), 42);
                    BOOST_CHECK_EQUAL(pl.get<int>("foo", 2008), 2008);
                }
                
                BOOST_AUTO_TEST_CASE(comments) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("int", 42);
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), 42);
                    BOOST_CHECK_EQUAL(pl.getComment("int"), "");
                    pl.set("int", 31, "test");
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), 31);
                    BOOST_CHECK_EQUAL(pl.getComment("int"), "test");
                    pl.set("int", 20, std::string("test2"));
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), 20);
                    BOOST_CHECK_EQUAL(pl.getComment("int"), "test2");
                    pl.set("int", 9);
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), 9);
                    BOOST_CHECK_EQUAL(pl.getComment("int"), "test2");
                    pl.set("int", -2, "");
                    BOOST_CHECK_EQUAL(pl.get<int>("int"), -2);
                    BOOST_CHECK_EQUAL(pl.getComment("int"), "");
                }
                
                BOOST_AUTO_TEST_CASE(deepCopy) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList::Ptr plp(new dafBase::PropertyList);
                    plp->set("int", 31, "test");
                    BOOST_CHECK_EQUAL(plp->get<int>("int"), 31);
                    dafBase::PropertySet::Ptr psp = plp;
                    dafBase::PropertySet::Ptr psp2 = psp->deepCopy();
                    BOOST_CHECK_EQUAL(psp2->get<int>("int"), 31);
                    dafBase::PropertyList::Ptr plp2 =
                        boost::dynamic_pointer_cast<dafBase::PropertyList,
                        dafBase::PropertySet>(psp2);
                    BOOST_CHECK_EQUAL(!plp2, false);
                    BOOST_CHECK_EQUAL(plp2->get<int>("int"), 31);
                    BOOST_CHECK_EQUAL(plp2->getComment("int"), "test");
                }
                
                
                BOOST_AUTO_TEST_CASE(exists) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("int", 42);
                    BOOST_CHECK_EQUAL(pl.exists("int"), true);
                    BOOST_CHECK_EQUAL(pl.exists("foo"), false);
                }
                
                BOOST_AUTO_TEST_CASE(getScalarThrow) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("bool", true);
                    short s = 42;
                    pl.set("short", s);
                    pl.set("int", 2008);
                    pl.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    pl.set("float", f);
                    double d = 2.718281828459045;
                    pl.set("double", d);
                    pl.set<std::string>("char*", "foo");
                    pl.set("char*2", "foo2");
                    pl.set("string", std::string("bar"));
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
236  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<bool>("short"), dafBase::TypeMismatchException);</div>
              ?                                              ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
237  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<bool>("short"), pexExcept::TypeError);</div>
              ?                                              ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
237  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<bool>("int"), dafBase::TypeMismatchException);</div>
              ?                                            ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
238  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<bool>("int"), pexExcept::TypeError);</div>
              ?                                            ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
238  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<short>("int"), dafBase::TypeMismatchException);</div>
              ?                                             ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
239  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<short>("int"), pexExcept::TypeError);</div>
              ?                                             ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
239  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<int>("short"), dafBase::TypeMismatchException);</div>
              ?                                             ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
240  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<int>("short"), pexExcept::TypeError);</div>
              ?                                             ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
240  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<int>("bool"), dafBase::TypeMismatchException);</div>
              ?                                            ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
241  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<int>("bool"), pexExcept::TypeError);</div>
              ?                                            ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
241  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<unsigned int>("int"), dafBase::TypeMismatchException);</div>
              ?                                                    ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
242  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<unsigned int>("int"), pexExcept::TypeError);</div>
              ?                                                    ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
242  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<double>("float"), dafBase::TypeMismatchException);</div>
              ?                                                ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
243  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<double>("float"), pexExcept::TypeError);</div>
              ?                                                ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
243  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<float>("double"), dafBase::TypeMismatchException);</div>
              ?                                                ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
244  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<float>("double"), pexExcept::TypeError);</div>
              ?                                                ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
244  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.get<std::string>("int"), dafBase::TypeMismatchException);</div>
              ?                                                   ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
245  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.get<std::string>("int"), pexExcept::TypeError);</div>
              ?                                                   ^ +++++++       ^^ ^
                }
                
                BOOST_AUTO_TEST_CASE(getVector) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    std::vector<int> v;
                    v.push_back(42);
                    v.push_back(2008);
                    v.push_back(1);
                    pl.set("ints", v);
                
                    std::vector<int> w = pl.getArray<int>("ints");
                    BOOST_CHECK_EQUAL(w.size(), 3U);
                    for (int i = 0; i < 3; ++i) {
                        BOOST_CHECK_EQUAL(v[i], w[i]);
                    }
                }
                
                BOOST_AUTO_TEST_CASE(addScalar) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    std::vector<int> v;
                    v.push_back(42);
                    v.push_back(2008);
                    v.push_back(1);
                    pl.set("ints", v);
                    pl.add("ints", -999);
                    pl.add("other", "foo");
                
                    std::vector<int> w = pl.getArray<int>("ints");
                    BOOST_CHECK_EQUAL(w.size(), 4U);
                    for (int i = 0; i < 3; ++i) {
                        BOOST_CHECK_EQUAL(v[i], w[i]);
                    }
                    BOOST_CHECK_EQUAL(w[3], -999);
                    BOOST_CHECK_EQUAL(pl.get<std::string>("other"), "foo");
                }
                
                BOOST_AUTO_TEST_CASE(addVector) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    std::vector<int> v;
                    v.push_back(42);
                    v.push_back(2008);
                    v.push_back(1);
                    pl.set("ints", v);
                
                    std::vector<int> vv;
                    vv.push_back(-42);
                    vv.push_back(-2008);
                    vv.push_back(-1);
                    pl.add("ints", vv);
                
                    std::vector<int> w = pl.getArray<int>("ints");
                    BOOST_CHECK_EQUAL(w.size(), 6U);
                    for (int i = 0; i < 3; ++i) {
                        BOOST_CHECK_EQUAL(v[i], w[i]);
                        BOOST_CHECK_EQUAL(vv[i], w[i + 3]);
                    }
                }
                
                BOOST_AUTO_TEST_CASE(typeOf) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("bool", true);
                    pl.set("char", '*');
                    short s = 42;
                    pl.set("short", s);
                    pl.set("int", 2008);
                    pl.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    pl.set("float", f);
                    double d = 2.718281828459045;
                    pl.set("double", d);
                    pl.set("char*", "foo");
                    pl.set("string", std::string("bar"));
                
                    BOOST_CHECK(pl.typeOf("bool") == typeid(bool));
                    BOOST_CHECK(pl.typeOf("char") == typeid(char));
                    BOOST_CHECK(pl.typeOf("short") == typeid(short));
                    BOOST_CHECK(pl.typeOf("int") == typeid(int));
                    BOOST_CHECK(pl.typeOf("int64_t") == typeid(int64_t));
                    BOOST_CHECK(pl.typeOf("float") == typeid(float));
                    BOOST_CHECK(pl.typeOf("double") == typeid(double));
                    BOOST_CHECK(pl.typeOf("char*") == typeid(std::string));
                    BOOST_CHECK(pl.typeOf("string") == typeid(std::string));
                }
                
                BOOST_AUTO_TEST_CASE(arrayProperties) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    std::vector<int> v;
                    v.push_back(42);
                    v.push_back(2008);
                    v.push_back(1);
                    pl.set("ints", v);
                    pl.set("int", 365);
                    pl.set("ints2", -42);
                    pl.add("ints2", -2008);
                
                    BOOST_CHECK_EQUAL(pl.isArray("ints"), true);
                    BOOST_CHECK_EQUAL(pl.isArray("int"), false);
                    BOOST_CHECK_EQUAL(pl.isArray("ints2"), true);
                    BOOST_CHECK_EQUAL(pl.valueCount("ints"), 3U);
                    BOOST_CHECK_EQUAL(pl.valueCount("int"), 1U);
                    BOOST_CHECK_EQUAL(pl.valueCount("ints2"), 2U);
                    BOOST_CHECK(pl.typeOf("ints") == typeid(int));
                    BOOST_CHECK(pl.typeOf("int") == typeid(int));
                    BOOST_CHECK(pl.typeOf("ints2") == typeid(int));
                }
                
                BOOST_AUTO_TEST_CASE(getAs) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("bool", true);
                    pl.set("char", 'A');
                    short s = 42;
                    pl.set("short", s);
                    pl.set("int", 2008);
                    pl.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    pl.set("float", f);
                    double d = 2.718281828459045;
                    pl.set("double", d);
                    pl.set<std::string>("char*", "foo");
                    pl.set("char*2", "foo2");
                    pl.set("string", std::string("bar"));
                    dafBase::PropertySet::Ptr plp(new dafBase::PropertySet);
                    plp->set("bottom", "x");
                    pl.set("top", plp);
                
                    BOOST_CHECK_EQUAL(pl.getAsBool("bool"), true);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
371  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.getAsBool("char"), dafBase::TypeMismatchException);</div>
              ?                                             ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
372  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.getAsBool("char"), pexExcept::TypeError);</div>
              ?                                             ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(pl.getAsInt("bool"), 1);
                    BOOST_CHECK_EQUAL(pl.getAsInt("char"), static_cast<int>('A'));
                    BOOST_CHECK_EQUAL(pl.getAsInt("short"), 42);
                    BOOST_CHECK_EQUAL(pl.getAsInt("int"), 2008);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
376  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.getAsInt("int64_t"), dafBase::TypeMismatchException);</div>
              ?                                               ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
377  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.getAsInt("int64_t"), pexExcept::TypeError);</div>
              ?                                               ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(pl.getAsInt64("bool"), INT64CONST(1));
                    BOOST_CHECK_EQUAL(pl.getAsInt64("char"), static_cast<int64_t>('A'));
                    BOOST_CHECK_EQUAL(pl.getAsInt64("short"), INT64CONST(42));
                    BOOST_CHECK_EQUAL(pl.getAsInt64("int"), INT64CONST(2008));
                    BOOST_CHECK_EQUAL(pl.getAsInt64("int64_t"), INT64CONST(0xfeeddeadbeef));
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
382  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.getAsInt64("float"), dafBase::TypeMismatchException);</div>
              ?                                               ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
383  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.getAsInt64("float"), pexExcept::TypeError);</div>
              ?                                               ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(pl.getAsDouble("bool"), 1.0);
                    BOOST_CHECK_EQUAL(pl.getAsDouble("char"), static_cast<double>('A'));
                    BOOST_CHECK_EQUAL(pl.getAsDouble("short"), 42.0);
                    BOOST_CHECK_EQUAL(pl.getAsDouble("int"), 2008.0);
                    BOOST_CHECK_EQUAL(pl.getAsDouble("int64_t"),
                                      static_cast<double>(INT64CONST(0xfeeddeadbeef)));
                    BOOST_CHECK_EQUAL(pl.getAsDouble("float"), 3.14159f);
                    BOOST_CHECK_EQUAL(pl.getAsDouble("double"), 2.718281828459045);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
391  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.getAsDouble("char*"), dafBase::TypeMismatchException);</div>
              ?                                                ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
392  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.getAsDouble("char*"), pexExcept::TypeError);</div>
              ?                                                ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
392  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.getAsString("char"), dafBase::TypeMismatchException);</div>
              ?                                               ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
393  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.getAsString("char"), pexExcept::TypeError);</div>
              ?                                               ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(pl.getAsString("char*"), "foo");
                    BOOST_CHECK_EQUAL(pl.getAsString("char*2"), "foo2");
                    BOOST_CHECK_EQUAL(pl.getAsString("string"), "bar");
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
396  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.getAsString("int"), dafBase::TypeMismatchException);</div>
              ?                                              ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
397  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.getAsString("int"), pexExcept::TypeError);</div>
              ?                                              ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(pl.getAsString("top.bottom"), "x");
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
398  <a href="#ecdc9472">ecdc9472</a> -     BOOST_CHECK_THROW(pl.getAsPropertySetPtr("top"), pexExcept::NotFoundException);</div>
              ?                                                                          ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
399  <a href="#25738fd8">25738fd8</a> +     BOOST_CHECK_THROW(pl.getAsPropertySetPtr("top"), pexExcept::NotFoundError);</div>
              ?                                                                          ^^ ^
                }
                
                BOOST_AUTO_TEST_CASE(combineThrow) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList pl;
                    pl.set("int", 42);
                
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    psp->set("int", 3.14159);
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
408  <a href="#ee2a91c6">ee2a91c6</a> -     BOOST_CHECK_THROW(pl.combine(psp), dafBase::TypeMismatchException);</div>
              ?                                        ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
409  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(pl.combine(psp), pexExcept::TypeError);</div>
              ?                                        ^ +++++++       ^^ ^
                }
                
                BOOST_AUTO_TEST_CASE(combineHierarchical) {
                    // Test for DM-882.
                    // Prior to that issue, the deepCopy() would segfault.
                    dafBase::PropertyList pl;
                    pl.set("a.b", 1);
                
                    dafBase::PropertySet::Ptr plp;
                    BOOST_CHECK_NO_THROW(plp = pl.deepCopy());
                
                    BOOST_CHECK_EQUAL(pl.getAsInt("a.b"), plp->getAsInt("a.b"));
                }
                
                BOOST_AUTO_TEST_CASE(combineAsPS) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertyList::Ptr plp1(new dafBase::PropertyList);
                    dafBase::PropertyList::Ptr plp2(new dafBase::PropertyList);
                    plp1->set("int", 42, "comment");
                    plp2->set("float", 3.14159, "stuff");
                    dafBase::PropertySet::Ptr psp =
                        boost::static_pointer_cast<dafBase::PropertySet,
                        dafBase::PropertyList>(plp1);
                    psp.get()->set("foo", 36);
                    psp.get()->combine(plp2);
                    dafBase::PropertyList::Ptr newPlp =
                        boost::dynamic_pointer_cast<dafBase::PropertyList,
                        dafBase::PropertySet>(psp);
                    BOOST_CHECK_EQUAL(!newPlp, false);
                    BOOST_CHECK_EQUAL(newPlp->get<int>("int"), 42);
                    BOOST_CHECK_EQUAL(newPlp->get<int>("foo"), 36);
                    BOOST_CHECK_EQUAL(newPlp->get<double>("float"), 3.14159);
                    BOOST_CHECK_EQUAL(newPlp->getComment("int"), "comment");
                    BOOST_CHECK_EQUAL(newPlp->getComment("float"), "stuff");
                }
                
                
                BOOST_AUTO_TEST_SUITE_END()
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="ee2a91c6"/></a>ee2a91c6</h3>

<pre>
commit ee2a91c67a4aa6484cd323b788fc7813615051a6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Sat Nov 6 15:19:51 2010 +0000

    Merge from ticket #676 (order and comments for properties).
</pre>
<h3><a name="ecdc9472"/></a>ecdc9472</h3>

<pre>
commit ecdc94728b037204645a67cb40253943fdecf613
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Thu May 2 21:03:57 2013 -0700

    Add Python interface to allow PropertySets to be added to PropertyLists.
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="86425aff"/></a>86425aff</h3>

<pre>
commit 86425aff3c781e9a2d98ad5fb3fee804928b2878
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 25 15:52:17 2014 -0700

    Respond to K-T's review by unifying the namespace usage for exceptions in two files.
</pre>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_10"><a name="ups/daf_base.cfg"/></a>ups/daf_base.cfg</h1>

<h3 id="toc_11">Diff:</h3>

<pre>
                # -*- python -*-
                
                import lsst.sconsUtils
                
                dependencies = {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#352a96b3">352a96b3</a> -     "required": ["utils", "boost_regex"],</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#bb936e92">bb936e92</a> +     "required": ["utils", "boost_regex", "numpy"],</div>
              ?                                        +++++++++
                    "buildRequired": ["boost_test", "swig"],
                }
                
                config = lsst.sconsUtils.Configuration(
                    __file__,
                    headers=["lsst/daf/base.h"],
                    hasDoxygenInclude=False,
                    hasSwigFiles=True,
                )
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="352a96b3"/></a>352a96b3</h3>

<pre>
commit 352a96b3f35c467fab252f5d96e54e1dded1bfed
Author: jbosch <jbosch@git.lsstcorp.org>
Date:   Thu Oct 13 21:20:34 2011 +0000

    daf_base #1780 - fixed cfg
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="bb936e92"/></a>bb936e92</h3>

<pre>
commit bb936e9230d470ba6cfc08d8407d9afcd46a827e
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Wed Apr 8 16:20:54 2015 -0400

    Use new numeric typemaps to support NumPy scalar arguments.
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_12"><a name="ups/daf_base.table"/></a>ups/daf_base.table</h1>

<h3 id="toc_13">Diff:</h3>

<pre>
                setupRequired(utils)
                setupRequired(pex_exceptions)
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
3    <a href="#bb936e92">bb936e92</a> + setupRequired(numpy)</div>
                
                envPrepend(LD_LIBRARY_PATH, ${PRODUCT_DIR}/lib)
                envPrepend(DYLD_LIBRARY_PATH, ${PRODUCT_DIR}/lib)
                
                envPrepend(PYTHONPATH, ${PRODUCT_DIR}/python)
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="bb936e92"/></a>bb936e92</h3>

<pre>
commit bb936e9230d470ba6cfc08d8407d9afcd46a827e
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Wed Apr 8 16:20:54 2015 -0400

    Use new numeric typemaps to support NumPy scalar arguments.
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_14"><a name="src/DateTime.cc"/></a>src/DateTime.cc</h1>

<h3 id="toc_15">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                
                /** \file
                 * \brief Implementation of DateTime class.
                 *
                 * \author $Author: ktlim $
                 * \version $Revision: 2151 $
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_base
                 */
                
                #include <limits>
                #include <cmath>
                
                #include "lsst/daf/base/DateTime.h"
                
                #include "boost/format.hpp"
                #include "boost/regex.hpp"
                #include <vector>
                
                #include "lsst/pex/exceptions.h"
                
                namespace dafBase = lsst::daf::base;
                namespace pexEx   = lsst::pex::exceptions;
                
                // Epoch = 1970 JAN  1 00:00:00 = JD 2440587.5 = MJD 40587.0
                static double const MJD_TO_JD = 2400000.5;
                static double const EPOCH_IN_MJD = 40587.0;
                static double const JD2000 = 2451544.50;
                
                /// Nanoseconds per day.
                static double const NSEC_PER_DAY = 86.4e12;
                
                /// Nanoseconds per day/second as a long long.
                static long long const LL_NSEC_PER_SEC = 1000000000LL;
                // static long long const LL_NSEC_PER_DAY = 86400 * LL_NSEC_PER_SEC;
                
                // Maximum number of days expressible as signed 64-bit nanoseconds.
                // 2^64 / 2 / 1e9 / 86400
                // NOTE: long long nsecs will wrap:
                // -- earliest date representable = sep 21, 1677 00:00:00
                // -- latest date representable   = apr 12, 2262 00:00:00
                static double const MAX_DAYS = 106751.99;
                
                
                #ifdef CAL_TO_JD
                static double const HOURS_PER_DAY = 24.0;
                static double const MIN_PER_DAY   = 1440.0;
                static double const SEC_PER_DAY   = 86400.0;
                #endif
                
                // Difference between Terrestrial Time and TAI.
                static double const TT_MINUS_TAI_NSECS = 32184000000LL;
                
                /* Leap second table as string.
                 *
                 * Source: http://maia.usno.navy.mil/ser7/tai-utc.dat
                 */
                static std::string leapString =
                "\
                1961 JAN  1 =JD 2437300.5  TAI-UTC=   1.4228180 S + (MJD - 37300.) X 0.001296 S\n\
                1961 AUG  1 =JD 2437512.5  TAI-UTC=   1.3728180 S + (MJD - 37300.) X 0.001296 S\n\
                1962 JAN  1 =JD 2437665.5  TAI-UTC=   1.8458580 S + (MJD - 37665.) X 0.0011232S\n\
                1963 NOV  1 =JD 2438334.5  TAI-UTC=   1.9458580 S + (MJD - 37665.) X 0.0011232S\n\
                1964 JAN  1 =JD 2438395.5  TAI-UTC=   3.2401300 S + (MJD - 38761.) X 0.001296 S\n\
                1964 APR  1 =JD 2438486.5  TAI-UTC=   3.3401300 S + (MJD - 38761.) X 0.001296 S\n\
                1964 SEP  1 =JD 2438639.5  TAI-UTC=   3.4401300 S + (MJD - 38761.) X 0.001296 S\n\
                1965 JAN  1 =JD 2438761.5  TAI-UTC=   3.5401300 S + (MJD - 38761.) X 0.001296 S\n\
                1965 MAR  1 =JD 2438820.5  TAI-UTC=   3.6401300 S + (MJD - 38761.) X 0.001296 S\n\
                1965 JUL  1 =JD 2438942.5  TAI-UTC=   3.7401300 S + (MJD - 38761.) X 0.001296 S\n\
                1965 SEP  1 =JD 2439004.5  TAI-UTC=   3.8401300 S + (MJD - 38761.) X 0.001296 S\n\
                1966 JAN  1 =JD 2439126.5  TAI-UTC=   4.3131700 S + (MJD - 39126.) X 0.002592 S\n\
                1968 FEB  1 =JD 2439887.5  TAI-UTC=   4.2131700 S + (MJD - 39126.) X 0.002592 S\n\
                1972 JAN  1 =JD 2441317.5  TAI-UTC=  10.0       S + (MJD - 41317.) X 0.0      S\n\
                1972 JUL  1 =JD 2441499.5  TAI-UTC=  11.0       S + (MJD - 41317.) X 0.0      S\n\
                1973 JAN  1 =JD 2441683.5  TAI-UTC=  12.0       S + (MJD - 41317.) X 0.0      S\n\
                1974 JAN  1 =JD 2442048.5  TAI-UTC=  13.0       S + (MJD - 41317.) X 0.0      S\n\
                1975 JAN  1 =JD 2442413.5  TAI-UTC=  14.0       S + (MJD - 41317.) X 0.0      S\n\
                1976 JAN  1 =JD 2442778.5  TAI-UTC=  15.0       S + (MJD - 41317.) X 0.0      S\n\
                1977 JAN  1 =JD 2443144.5  TAI-UTC=  16.0       S + (MJD - 41317.) X 0.0      S\n\
                1978 JAN  1 =JD 2443509.5  TAI-UTC=  17.0       S + (MJD - 41317.) X 0.0      S\n\
                1979 JAN  1 =JD 2443874.5  TAI-UTC=  18.0       S + (MJD - 41317.) X 0.0      S\n\
                1980 JAN  1 =JD 2444239.5  TAI-UTC=  19.0       S + (MJD - 41317.) X 0.0      S\n\
                1981 JUL  1 =JD 2444786.5  TAI-UTC=  20.0       S + (MJD - 41317.) X 0.0      S\n\
                1982 JUL  1 =JD 2445151.5  TAI-UTC=  21.0       S + (MJD - 41317.) X 0.0      S\n\
                1983 JUL  1 =JD 2445516.5  TAI-UTC=  22.0       S + (MJD - 41317.) X 0.0      S\n\
                1985 JUL  1 =JD 2446247.5  TAI-UTC=  23.0       S + (MJD - 41317.) X 0.0      S\n\
                1988 JAN  1 =JD 2447161.5  TAI-UTC=  24.0       S + (MJD - 41317.) X 0.0      S\n\
                1990 JAN  1 =JD 2447892.5  TAI-UTC=  25.0       S + (MJD - 41317.) X 0.0      S\n\
                1991 JAN  1 =JD 2448257.5  TAI-UTC=  26.0       S + (MJD - 41317.) X 0.0      S\n\
                1992 JUL  1 =JD 2448804.5  TAI-UTC=  27.0       S + (MJD - 41317.) X 0.0      S\n\
                1993 JUL  1 =JD 2449169.5  TAI-UTC=  28.0       S + (MJD - 41317.) X 0.0      S\n\
                1994 JUL  1 =JD 2449534.5  TAI-UTC=  29.0       S + (MJD - 41317.) X 0.0      S\n\
                1996 JAN  1 =JD 2450083.5  TAI-UTC=  30.0       S + (MJD - 41317.) X 0.0      S\n\
                1997 JUL  1 =JD 2450630.5  TAI-UTC=  31.0       S + (MJD - 41317.) X 0.0      S\n\
                1999 JAN  1 =JD 2451179.5  TAI-UTC=  32.0       S + (MJD - 41317.) X 0.0      S\n\
                2006 JAN  1 =JD 2453736.5  TAI-UTC=  33.0       S + (MJD - 41317.) X 0.0      S\n\
                2009 JAN  1 =JD 2454832.5  TAI-UTC=  34.0       S + (MJD - 41317.) X 0.0      S\n\
                2012 JUL  1 =JD 2456109.5  TAI-UTC=  35.0       S + (MJD - 41317.) X 0.0      S\n\
                ";
                
                // Anonymous namespace for structures, classes, and formerly file-static
                // functions.
                namespace {
                
                /// Leap second descriptor.
                struct Leap {
                    long long whenUtc; ///< UTC nanosecs of change
                    long long whenTai; ///< TAI nanosecs of change
                    double offset; ///< TAI - UTC
                    double mjdRef; ///< Intercept for MJD interpolation
                    double drift; ///< Slope of MJD interpolation
                };
                
                class LeapTable : public std::vector<Leap> {
                public:
                    LeapTable(void);
                };
                
                LeapTable leapSecTable;
                
                LeapTable::LeapTable(void) {
                    dafBase::DateTime::initializeLeapSeconds(leapString);
                }
                
                /** Convert UTC time to TAI time.
                 * \param[in] nsecs Number of nanoseconds since the epoch in UTC
                 * \return Number of nanoseconds since the epoch in TAI
                 */
                template<typename NsType>
                NsType utcToTai(NsType nsecs) {
                    size_t i;
                    for (i = 0; i < leapSecTable.size(); ++i) {
                        if (nsecs < leapSecTable[i].whenUtc) break;
                    }
                    if (i == 0) {
                        throw LSST_EXCEPT(
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
165  <a href="#cff8d7ad">cff8d7ad</a> -             lsst::pex::exceptions::DomainErrorException,</div>
              ?                                               ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
165  <a href="#25738fd8">25738fd8</a> +             lsst::pex::exceptions::DomainError,</div>
                            (boost::format(
                                    "DateTime value too early for UTC-TAI conversion: %1%"
                                    ) % nsecs).str());
                    }
                    Leap const& l(leapSecTable[i - 1]);
                    double mjd = static_cast<double>(nsecs) / NSEC_PER_DAY + EPOCH_IN_MJD;
                    double leapSecs = l.offset + (mjd - l.mjdRef) * l.drift;
                    NsType leapNSecs = static_cast<NsType>(leapSecs * 1.0e9 + 0.5);
                    return nsecs + leapNSecs;
                }
                
                /** Convert TAI time to UTC time.
                 * \param[in] nsecs Number of nanoseconds since the epoch in TAI
                 * \return Number of nanoseconds since the epoch in UTC
                 */
                template<typename NsType>
                NsType taiToUtc(NsType nsecs) {
                    size_t i;
                    for (i = 0; i < leapSecTable.size(); ++i) {
                        if (nsecs < leapSecTable[i].whenTai) break;
                    }
                    if (i == 0) {
                        throw LSST_EXCEPT(
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
189  <a href="#cff8d7ad">cff8d7ad</a> -             lsst::pex::exceptions::DomainErrorException,</div>
              ?                                               ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
189  <a href="#25738fd8">25738fd8</a> +             lsst::pex::exceptions::DomainError,</div>
                            (boost::format(
                                    "DateTime value too early for TAI-UTC conversion: %1%"
                                    ) % nsecs).str());
                    }
                    Leap const& l(leapSecTable[i - 1]);
                    double mjd = static_cast<double>(nsecs) / NSEC_PER_DAY + EPOCH_IN_MJD;
                    double leapSecs = l.offset + (mjd - l.mjdRef) * l.drift;
                    // Correct for TAI MJD vs. UTC MJD.
                    leapSecs /= 1.0 + l.drift * 1.0e9 / NSEC_PER_DAY;
                    NsType leapNSecs = static_cast<NsType>(leapSecs * 1.0e9 + 0.5);
                    return nsecs - leapNSecs;
                }
                
                
                #ifdef CAL_TO_JD
                /**
                 * A function to compute the Julian day from a calendar date.
                 * \param[in] year Year number.
                 * \param[in] month Month number (Jan = 1).
                 * \param[in] day Day number (1 to 31).
                 * \param[in] hr Hour number (0 to 23).
                 * \param[in] min Minute number (0 to 59).
                 * \param[in] sec Second number (0 to 60).
                 *
                 */
                double calendarToJd(int year, int month, int day, int hour, int min, double sec) {
                    if ( month <= 2 ) {
                        year -= 1;
                        month += 12;
                    }
                    int a = int(year/100);
                    int b =  2 - a + int(a/4); 
                
                    int yy = 1582, mm = 10; //, d = 4;
                    if (year < yy || (year == yy && month < mm) || (year == yy && month == mm && day <= 4)) {
                        b = 0;
                    }
                
                    double jd = static_cast<int>(365.25*(year + 4716)) +
                        static_cast<int>(30.6001*(month + 1)) + day + b - 1524.5;
                    jd += hour/HOURS_PER_DAY + min/MIN_PER_DAY + sec/SEC_PER_DAY;
                
                    return jd;
                }
                
                #endif // CAL_TO_JD
                } // end anonymous namespace
                
                
                /**
                 * @brief a function to convert MJD to interal nsecs
                 * @param[in] mjd The Modified Julian Day
                 * @param[in] scale The time scale (TAI, or UTC)
                 *
                 */
                void dafBase::DateTime::setNsecsFromMjd(double mjd, Timescale scale) {
                
                    if (mjd > EPOCH_IN_MJD + MAX_DAYS) {
                        throw LSST_EXCEPT(
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
249  <a href="#3aad899d">3aad899d</a> -                           lsst::pex::exceptions::DomainErrorException,</div>
              ?                                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
249  <a href="#25738fd8">25738fd8</a> +                           lsst::pex::exceptions::DomainError,</div>
                                          (boost::format("MJD too far in the future: %1%") % mjd).str());
                    }
                    if (mjd < EPOCH_IN_MJD - MAX_DAYS) {
                        throw LSST_EXCEPT(
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
254  <a href="#3aad899d">3aad899d</a> -                           lsst::pex::exceptions::DomainErrorException,</div>
              ?                                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
254  <a href="#25738fd8">25738fd8</a> +                           lsst::pex::exceptions::DomainError,</div>
                                          (boost::format("MJD too far in the past: %1%") % mjd).str());
                    }
                    _nsecs = static_cast<long long>((mjd - EPOCH_IN_MJD) * NSEC_PER_DAY);
                    if (scale == UTC) {
                        _nsecs = utcToTai(_nsecs);
                    } else if (scale == TT) {
                        _nsecs -= TT_MINUS_TAI_NSECS;
                    }
                
                }
                    
                /**
                 * @brief a function to convert JD to internal nsecs
                 * @param[in] jd The Julian Day
                 * @param[in] scale The time scale (TAI, or UTC)
                 */
                void dafBase::DateTime::setNsecsFromJd(double jd, Timescale scale) {
                    setNsecsFromMjd(jd - MJD_TO_JD, scale);
                }
                    
                /**
                 * @brief a function to convert epoch to internal nsecs
                 * @param[in] epoch The Julian epoch
                 * @param[in] scale The time scale (TAI, or UTC)
                 */
                void dafBase::DateTime::setNsecsFromEpoch(double epoch, Timescale scale) {
                    setNsecsFromMjd(365.25*(epoch - 2000.0) + JD2000 - MJD_TO_JD, scale);
                }
                    
                
                
                /** Constructor.
                 * \param[in] nsecs Number of nanoseconds since the epoch.
                 * \param[in] scale Timescale of input (TAI or UTC, default TAI).
                 */
                dafBase::DateTime::DateTime(long long nsecs, Timescale scale) : _nsecs(nsecs) {
                    if (scale == UTC) {
                        _nsecs = utcToTai(_nsecs);
                    } else if (scale == TT) {
                        _nsecs -= TT_MINUS_TAI_NSECS;
                    }
                }
                
                /** Constructor.
                 * \param[in] date Date.
                 * \param[in] system The requested date system (JD, MJD, or Julian epoch)
                 * \param[in] scale Timescale of input (TAI or UTC, default TAI).
                 */
                dafBase::DateTime::DateTime(double date, DateSystem system, Timescale scale) {
                    switch (system) {
                      case MJD:
                        setNsecsFromMjd(date, scale);
                        break;
                      case JD:
                        setNsecsFromJd(date, scale);
                        break;
                      case EPOCH:
                        setNsecsFromEpoch(date, scale);
                        break;
                      default:
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
315  <a href="#3aad899d">3aad899d</a> -         throw LSST_EXCEPT(pexEx::InvalidParameterException, "DateSystem must be MJD, JD, or EPOCH.");</div>
              ?                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
315  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexEx::InvalidParameterError, "DateSystem must be MJD, JD, or EPOCH.");</div>
              ?                                                   ^^ ^
                        break;
                    }
                }
                
                
                
                /** Constructor.
                 * \param[in] year Year number.
                 * \param[in] month Month number (Jan = 1).
                 * \param[in] day Day number (1 to 31).
                 * \param[in] hr Hour number (0 to 23).
                 * \param[in] min Minute number (0 to 59).
                 * \param[in] sec Second number (0 to 60).
                 * \param[in] scale Timescale of input (TAI or UTC, default TAI).
                 */
                dafBase::DateTime::DateTime(int year, int month, int day,
                                            int hr, int min, int sec, Timescale scale) {
                
                
                    struct tm tm;
                    tm.tm_year = year - 1900;
                    tm.tm_mon = month - 1;
                    tm.tm_mday = day;
                    tm.tm_hour = hr;
                    tm.tm_min = min;
                    tm.tm_sec = sec;
                    tm.tm_wday = 0;
                    tm.tm_yday = 0;
                    tm.tm_isdst = 0;
                    tm.tm_gmtoff = 0;
                    
                    // Convert to seconds since the epoch, correcting to UTC.
                    // Although timegm() is non-standard, it is a commonly-supported
                    // extension and is much safer/more reliable than mktime(3) in that
                    // it doesn't try to deal with the anomalies of local time zones.
                    time_t secs = timegm(&tm);
                    
                    // long long nsecs will blow out beyond sep 21, 1677 0:00:00, and apr 12 2262 00:00:00
                    // (refering to the values of EPOCH_IN_MJD +/- MAX_DAYS ... exceeds 64 bits.)
                    // However, a tm struct is only 32 bits, and saturates at:
                    //    low end - Dec 13 1901, 20:45:52
                    //    hi end  - Jan 19 2038, 03:14:07
                    
                    if (secs == -1) {
                        throw LSST_EXCEPT(
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
361  <a href="#85a19562">85a19562</a> -                           lsst::pex::exceptions::DomainErrorException,</div>
              ?                                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
361  <a href="#25738fd8">25738fd8</a> +                           lsst::pex::exceptions::DomainError,</div>
                                          (boost::format("Unconvertible date: %04d-%02d-%02dT%02d:%02d:%02d")
                                           % year % month % day % hr % min % sec).str());
                    }
                    
                    _nsecs = secs * LL_NSEC_PER_SEC;
                    if (scale == UTC) {
                        _nsecs = utcToTai(_nsecs);
                    } else if (scale == TT) {
                        _nsecs -= TT_MINUS_TAI_NSECS;
                    }
                
                }
                
                /** Constructor.  Accepts a restricted subset of ISO8601:
                  * yyyy-mm-ddThh:mm:ss.nnnnnnnnnZ where the - and : separators are optional,
                  * the fractional seconds are also optional, and the decimal point may be a
                  * comma.
                 * \param[in] iso8601 ISO8601 representation of date and time.  Must be UTC.
                 */
                dafBase::DateTime::DateTime(std::string const& iso8601) {
                    boost::regex re("(\\d{4})-?(\\d{2})-?(\\d{2})" "T"
                                    "(\\d{2}):?(\\d{2}):?(\\d{2})" "([.,](\\d*))?" "Z");
                    boost::smatch matches;
                    if (!regex_match(iso8601, matches, re)) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
386  <a href="#cfdd37a1">cfdd37a1</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::DomainErrorException,</div>
              ?                                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
386  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::DomainError,</div>
                                          "Not in acceptable ISO8601 format: " + iso8601);
                    }
                    DateTime dt(atoi(matches.str(1).c_str()), atoi(matches.str(2).c_str()),
                                atoi(matches.str(3).c_str()), atoi(matches.str(4).c_str()),
                                atoi(matches.str(5).c_str()), atoi(matches.str(6).c_str()),
                                UTC);
                    _nsecs = dt._nsecs;
                    if (matches[7].matched) {
                        std::string frac = matches.str(8);
                        int places = frac.size();
                        if (places > 9) { // truncate fractional nanosec
                            frac.erase(9);
                        }
                        int value = atoi(frac.c_str());
                        while (places < 9) {
                            value *= 10;
                            ++places;
                        }
                        _nsecs += value;
                    }
                }
                
                
                /** Generic Accessor
                 * @return the date in the required system, for the requested scale
                 * @param[in] system The type of date requested (JD, MJD, or EPOCH)
                 * @param[in] scale The time scale (UTC, or TAI)
                 *
                 * @note The NSECS can't be requested here as they're in long long form.
                 *       A factory could be constructed, but it's more trouble than it's worth at this point.
                 */
                double dafBase::DateTime::get(DateSystem system, Timescale scale) const {
                    switch (system) {
                      case MJD:
                        return _getMjd(scale);
                        break;
                      case JD:
                        return _getJd(scale);
                        break;
                      case EPOCH:
                        return _getEpoch(scale);
                        break;
                      default:
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
430  <a href="#3aad899d">3aad899d</a> -         throw LSST_EXCEPT(pexEx::InvalidParameterException,</div>
              ?                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
430  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(pexEx::InvalidParameterError,</div>
              ?                                                   ^^ ^
                                          "DateSystem must be MJD, JD, or EPOCH.");
                        break;
                    }
                }
                
                
                /** Accessor.
                 * \return Number of nanoseconds since the epoch in UTC or TAI.
                 */
                long long dafBase::DateTime::nsecs(Timescale scale) const {
                    if (scale == TAI) {
                        return _nsecs;
                    } else if (scale == TT) {
                        return _nsecs + TT_MINUS_TAI_NSECS;
                    } else {
                        return taiToUtc(_nsecs);
                    }
                }
                
                
                /** Convert to Modified Julian Day.
                 * \param[in] scale Desired timescale (TAI or UTC, default TAI).
                 * \return The Modified Julian Day corresponding to the time.
                 */
                double dafBase::DateTime::_getMjd(Timescale scale) const {
                
                    double nsecs;
                    if (scale == TAI) {
                        nsecs = static_cast<double>(_nsecs);
                    } else if (scale == TT) {
                        nsecs = static_cast<double>(_nsecs) + TT_MINUS_TAI_NSECS;
                    } else {
                        nsecs = static_cast<double>(taiToUtc(_nsecs));
                    }
                    return nsecs / NSEC_PER_DAY + EPOCH_IN_MJD;
                }
                
                
                /** Convert to Julian Day.
                 * \param[in] scale Desired timescale (TAI or UTC, default TAI).
                 * \return The Julian Day corresponding to the time.
                 */
                double dafBase::DateTime::_getJd(Timescale scale) const {
                    return _getMjd(scale) + MJD_TO_JD;
                }
                
                /** Convert to Julian Epoch.
                 * \param[in] scale Desired timescale (TAI or UTC, default TAI).
                 * \return The Julian Epoch corresponding to the time.
                 */
                double dafBase::DateTime::_getEpoch(Timescale scale) const {
                    return 2000.0 + (_getJd(scale) - JD2000)/365.25;
                }
                
                
                
                
                /** Convert to struct tm.  Truncate fractional seconds.
                 * \return Structure with decoded time in UTC.
                 */
                struct tm dafBase::DateTime::gmtime(void) const {
                    struct tm gmt;
                    long long nsecs = taiToUtc(_nsecs);
                    // Round to negative infinity
                    long long frac = nsecs % LL_NSEC_PER_SEC;
                    if (nsecs < 0 && frac < 0) {
                        nsecs -= LL_NSEC_PER_SEC + frac;
                    }
                    else {
                        nsecs -= frac;
                    }
                    time_t secs = static_cast<time_t>(nsecs / LL_NSEC_PER_SEC);
                    gmtime_r(&secs, &gmt);
                    return gmt;
                }
                
                /** Convert to struct timespec.
                 * \return Structure with UTC time in seconds and nanoseconds.
                 */
                struct timespec dafBase::DateTime::timespec(void) const {
                    struct timespec ts;
                    long long nsecs = taiToUtc(_nsecs);
                    ts.tv_sec = static_cast<time_t>(nsecs / LL_NSEC_PER_SEC);
                    ts.tv_nsec = static_cast<int>(nsecs % LL_NSEC_PER_SEC);
                    return ts;
                }
                
                /** Convert time to struct timeval.
                 * \return Structure with UTC time in seconds and microseconds.
                 */
                struct timeval dafBase::DateTime::timeval(void) const {
                    struct timeval tv;
                    long long nsecs = taiToUtc(_nsecs);
                    tv.tv_sec = static_cast<time_t>(nsecs / LL_NSEC_PER_SEC);
                    tv.tv_usec = static_cast<int>((nsecs % LL_NSEC_PER_SEC) / 1000);
                    return tv;
                }
                
                /** Accessor.
                 * \return ISO8601-formatted string representation.  Always UTC.
                 */
                std::string dafBase::DateTime::toString(void) const {
                    struct tm gmt(this->gmtime());
                    long long nsecs = taiToUtc(_nsecs) % LL_NSEC_PER_SEC;
                    if (nsecs < 0) {
                        nsecs += LL_NSEC_PER_SEC;
                    }
                    return (boost::format("%04d-%02d-%02dT%02d:%02d:%02d.%09dZ") %
                            (gmt.tm_year + 1900) % (gmt.tm_mon + 1) % gmt.tm_mday %
                            gmt.tm_hour % gmt.tm_min % gmt.tm_sec % nsecs).str();
                }
                
                /** Equality operator.
                 * \return True if both DateTimes have the same nanosecond representation.
                 */
                bool dafBase::DateTime::operator==(DateTime const& rhs) const {
                    return _nsecs == rhs._nsecs;
                }
                
                /** Return current time as a DateTime.
                  * \return DateTime representing the current time.
                  */
                dafBase::DateTime dafBase::DateTime::now(void) {
                    struct timeval tv;
                    int ret = gettimeofday(&tv, 0);
                    if (ret != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
557  <a href="#ff6e9935">ff6e9935</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException,</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
557  <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                                          "Unable to get current time");
                    }
                    long long nsecs = tv.tv_sec * LL_NSEC_PER_SEC + tv.tv_usec * 1000LL;
                    return DateTime(nsecs, DateTime::UTC);
                }
                
                /** Initialize leap second table.
                  * \param leapString Leap second table from USNO as a single multiline string.
                  */
                void dafBase::DateTime::initializeLeapSeconds(std::string const& leapString) {
                    Leap l;
                    leapSecTable.clear();
                    boost::regex re("^\\d{4}.*?=JD\\s*([\\d.]+)\\s+TAI-UTC=\\s+([\\d.]+)\\s+S"
                                    " \\+ \\(MJD - ([\\d.]+)\\) X ([\\d.]+)\\s*S$");
                    for (boost::cregex_iterator i = make_regex_iterator(leapString.c_str(), re);
                         i != boost::cregex_iterator(); ++i) {
                        double mjdUtc = strtod((*i)[1].first, 0) - MJD_TO_JD;
                        l.offset = strtod((*i)[2].first, 0);
                        l.mjdRef = strtod((*i)[3].first, 0);
                        l.drift = strtod((*i)[4].first, 0);
                        l.whenUtc = static_cast<long long>(
                            (mjdUtc - EPOCH_IN_MJD) * NSEC_PER_DAY);
                        l.whenTai = l.whenUtc + static_cast<long long>(
                            1.0e9 * (l.offset + (mjdUtc - l.mjdRef) * l.drift));
                        leapSecTable.push_back(l);
                    }
                }
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="cff8d7ad"/></a>cff8d7ad</h3>

<pre>
commit cff8d7ad5c5444d2e169e0bd01f821093447042c
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu May 7 00:48:05 2009 +0000

    Throw exceptions if parameters to DateTime constructors are out of valid ranges.  #800
</pre>
<h3><a name="cfdd37a1"/></a>cfdd37a1</h3>

<pre>
commit cfdd37a1116a88ec0da0e26c1f5ade00cda3e7f6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Apr 2 08:15:09 2009 +0000

    Implement constructor from ISO8601 and toString(), with test cases.  Fix timezone problem with mktime().
</pre>
<h3><a name="3aad899d"/></a>3aad899d</h3>

<pre>
commit 3aad899deae8094f199059544e1ca9d00a7afd05
Author: bick <bick@git.lsstcorp.org>
Date:   Sat Mar 13 02:32:53 2010 +0000

    work in progress on #1188.  Putting jd and epoch into DateTime.
</pre>
<h3><a name="ff6e9935"/></a>ff6e9935</h3>

<pre>
commit ff6e9935a7f1afc5f2ea3af78fd0b87d386794e0
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Mon Mar 9 23:16:43 2009 +0000

    Throw an exception if we can't get the current time.
</pre>
<h3><a name="85a19562"/></a>85a19562</h3>

<pre>
commit 85a19562bc211d895b4f8cd698847ae7b323a1fc
Author: bick <bick@git.lsstcorp.org>
Date:   Sat Mar 20 22:21:18 2010 +0000

    Removed the double variant of _nsecs.  Unnecessary for now.
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_16"><a name="tests/PropertySet_2.py"/></a>tests/PropertySet_2.py</h1>

<h3 id="toc_17">Diff:</h3>

<pre>
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                import unittest
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
24   <a href="#bb936e92">bb936e92</a> + import numpy</div>
                
                import lsst.utils.tests as utilsTests
                import lsst.daf.base as dafBase
                import lsst.pex.exceptions as pexExcept
                
                class PropertySetTestCase(unittest.TestCase):
                    """A test case for PropertySet."""
                
                    def testConstruct(self):
                        ps = dafBase.PropertySet()
                        self.assert_(ps is not None)
                
                    def testScalar(self):
                        ps = dafBase.PropertySet()
                        ps.setBool("bool", True)
                        ps.setShort("short", 42)
                        ps.setInt("int", 2008)
                        ps.setLongLong("int64_t", 0xfeeddeadbeefL)
                        ps.setFloat("float", 3.14159)
                        ps.setDouble("double", 2.718281828459045)
                        ps.set("char*", "foo")
                        ps.setString("string", "bar")
                        ps.set("int2", 2009)
                        ps.set("dt", dafBase.DateTime("20090402T072639.314159265Z"))
                
                        self.assertEqual(ps.typeOf("bool"), dafBase.PropertySet.TYPE_Bool)
                        self.assertEqual(ps.getBool("bool"), True)
                        self.assertEqual(ps.typeOf("short"), dafBase.PropertySet.TYPE_Short)
                        self.assertEqual(ps.getShort("short"), 42)
                        self.assertEqual(ps.typeOf("int"), dafBase.PropertySet.TYPE_Int)
                        self.assertEqual(ps.getInt("int"), 2008)
                        self.assertEqual(ps.typeOf("int64_t"),
                                dafBase.PropertySet.TYPE_LongLong)
                        self.assertEqual(ps.getLongLong("int64_t"), 0xfeeddeadbeefL)
                        self.assertEqual(ps.typeOf("float"), dafBase.PropertySet.TYPE_Float)
                        self.assertAlmostEqual(ps.getFloat("float"), 3.14159, 6)
                        self.assertEqual(ps.typeOf("double"), dafBase.PropertySet.TYPE_Double)
                        self.assertEqual(ps.getDouble("double"), 2.718281828459045)
                        self.assertEqual(ps.typeOf("char*"), dafBase.PropertySet.TYPE_String)
                        self.assertEqual(ps.getString("char*"), "foo")
                        self.assertEqual(ps.typeOf("string"), dafBase.PropertySet.TYPE_String)
                        self.assertEqual(ps.getString("string"), "bar")
                        self.assertEqual(ps.typeOf("int2"), dafBase.PropertySet.TYPE_Int)
                        self.assertEqual(ps.getInt("int2"), 2009)
                        self.assertEqual(ps.get("int2"), 2009)
                        self.assertEqual(ps.typeOf("dt"), dafBase.PropertySet.TYPE_DateTime)
                        self.assertEqual(ps.getDateTime("dt").nsecs(), 1238657233314159265L)
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
73   <a href="#bb936e92">bb936e92</a> +     def testNumPyScalars(self):</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
74   <a href="#bb936e92">bb936e92</a> +         """Test that we can also pass NumPy array scalars to PropertySet setters.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
75   <a href="#bb936e92">bb936e92</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
76   <a href="#bb936e92">bb936e92</a> +         The custom Swig typemaps that enable this behavior are implemented in</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
77   <a href="#bb936e92">bb936e92</a> +         utils, but we want a test outside utils to verify that the approach</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
78   <a href="#bb936e92">bb936e92</a> +         works in downstream packages.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
79   <a href="#bb936e92">bb936e92</a> +         """</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
80   <a href="#bb936e92">bb936e92</a> +         ps = dafBase.PropertySet()</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
81   <a href="#bb936e92">bb936e92</a> +         ps.setShort("short", numpy.int16(42))</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
82   <a href="#bb936e92">bb936e92</a> +         ps.setInt("int", numpy.int32(2008))</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
83   <a href="#bb936e92">bb936e92</a> +         ps.setLongLong("int64_t", numpy.int64(0xfeeddeadbeefL))</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
84   <a href="#bb936e92">bb936e92</a> +         ps.setFloat("float", numpy.float32(3.14159))</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
85   <a href="#bb936e92">bb936e92</a> +         ps.setDouble("double", numpy.float64(2.718281828459045))</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
86   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.typeOf("short"), dafBase.PropertySet.TYPE_Short)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.getShort("short"), 42)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
88   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.typeOf("int"), dafBase.PropertySet.TYPE_Int)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
89   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.getInt("int"), 2008)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.typeOf("int64_t"),</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
91   <a href="#bb936e92">bb936e92</a> +                 dafBase.PropertySet.TYPE_LongLong)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
92   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.getLongLong("int64_t"), 0xfeeddeadbeefL)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
93   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.typeOf("float"), dafBase.PropertySet.TYPE_Float)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
94   <a href="#bb936e92">bb936e92</a> +         self.assertAlmostEqual(ps.getFloat("float"), 3.14159, 6)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
95   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.typeOf("double"), dafBase.PropertySet.TYPE_Double)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
96   <a href="#bb936e92">bb936e92</a> +         self.assertEqual(ps.getDouble("double"), 2.718281828459045)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
97   <a href="#bb936e92">bb936e92</a> + </div>
                    def testGetDefault(self):
                        ps = dafBase.PropertySet()
                        ps.setInt("int", 42)
                        self.assertEqual(ps.getInt("int"), 42)
                        self.assertEqual(ps.getInt("int", 2008), 42)
                        self.assertEqual(ps.getInt("foo", 2008), 2008)
                
                    def testExists(self):
                        ps = dafBase.PropertySet()
                        ps.setInt("int", 42)
                        self.assertEqual(ps.exists("int"), True)
                        self.assertEqual(ps.exists("foo"), False)
                
                    def testGetVector(self):
                        ps = dafBase.PropertySet()
                        v = (42, 2008, 1)
                        ps.setInt("ints", v)
                        ps.setInt("ints2", (10, 9, 8))
                        w = ps.getArrayInt("ints")
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v, w)
                        self.assertEqual(ps.getInt("ints2"), 8)
                        self.assertEqual(ps.getArrayInt("ints2"), (10, 9, 8))
                        w = ps.get("ints", asArray=True)
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v, w)
                        ps.setInt("int", 999)
                        x = ps.get("int")
                        self.assertEqual(x, 999)
                        x = ps.get("int", asArray=True)
                        self.assertEqual(len(x), 1)
                        self.assertEqual(x, (999,))
                
                    def testGetVector2(self):
                        ps = dafBase.PropertySet()
                        v = [42, 2008, 1]
                        ps.setInt("ints", v)
                        ps.setInt("ints2", [10, 9, 8])
                        w = ps.getArrayInt("ints")
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v[0], w[0])
                        self.assertEqual(v[1], w[1])
                        self.assertEqual(v[2], w[2])
                        self.assertEqual(ps.getInt("ints2"), 8)
                        self.assertEqual(ps.getArrayInt("ints2"), (10, 9, 8))
                
                    def testAddScalar(self):
                        ps = dafBase.PropertySet()
                        v = [42, 2008, 1]
                        ps.setInt("ints", v)
                        ps.addInt("ints", -999)
                        ps.add("other", "foo")
                        ps.add("ints", 13)
                        w = ps.getArrayInt("ints")
                        self.assertEqual(len(w), 5)
                        self.assertEqual(v[0], w[0])
                        self.assertEqual(v[1], w[1])
                        self.assertEqual(v[2], w[2])
                        self.assertEqual(w[3], -999)
                        self.assertEqual(w[4], 13)
                        self.assertEqual(ps.getString("other"), "foo")
                
                    def testDateTimeToString(self):
                        ps = dafBase.PropertySet()
                        ps.set("dt", dafBase.DateTime("20090402T072639.314159265Z"))
                        self.assertEqual(ps.toString(),
                                "dt = 2009-04-02T07:26:39.314159265Z\n")
                
                    def testGetScalarThrow(self):
                        ps = dafBase.PropertySet()
                        ps.setBool("bool", True)
                        ps.setShort("short", 42)
                        ps.setInt("int", 2008)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
145  <a href="#32535046">32535046</a> -         self.assertRaises(pexExcept.LsstException, ps.get, "foo")</div>
              ?                                     ^^^  ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
171  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.NotFoundError, ps.get, "foo")</div>
              ?                                     ^^ +++++ ^^ ^
                
                    def testSubPS(self):
                        ps = dafBase.PropertySet()
                        ps1 = dafBase.PropertySet()
                        ps1.set("a", 1)
                        ps.setPropertySet("b", ps1)
                        self.assertEqual(ps.get("b.a"), 1)
                        ps.set("c", ps1)
                        self.assertEqual(ps.get("c.a"), 1)
                        ps.set("c.a", 2)
                        self.assertEqual(ps.get("b.a"), 2)
                        self.assertEqual(ps.get("b").get("a"), 2)
                
                class FlatTestCase(unittest.TestCase):
                    """A test case for flattened PropertySets."""
                
                    def testConstruct(self):
                        ps = dafBase.PropertySet(flat=True)
                        self.assert_(ps is not None)
                
                    def testScalar(self):
                        ps = dafBase.PropertySet(flat=True)
                        ps.setBool("bool", True)
                        ps.setShort("short", 42)
                        ps.setInt("int", 2008)
                        ps.setLongLong("int64_t", 0xfeeddeadbeefL)
                        ps.setFloat("float", 3.14159)
                        ps.setDouble("double", 2.718281828459045)
                        ps.set("char*", "foo")
                        ps.setString("string", "bar")
                        ps.set("int2", 2009)
                        ps.set("dt", dafBase.DateTime("20090402T072639.314159265Z"))
                
                        self.assertEqual(ps.typeOf("bool"), dafBase.PropertySet.TYPE_Bool)
                        self.assertEqual(ps.getBool("bool"), True)
                        self.assertEqual(ps.typeOf("short"), dafBase.PropertySet.TYPE_Short)
                        self.assertEqual(ps.getShort("short"), 42)
                        self.assertEqual(ps.typeOf("int"), dafBase.PropertySet.TYPE_Int)
                        self.assertEqual(ps.getInt("int"), 2008)
                        self.assertEqual(ps.typeOf("int64_t"),
                                dafBase.PropertySet.TYPE_LongLong)
                        self.assertEqual(ps.getLongLong("int64_t"), 0xfeeddeadbeefL)
                        self.assertEqual(ps.typeOf("float"), dafBase.PropertySet.TYPE_Float)
                        self.assertAlmostEqual(ps.getFloat("float"), 3.14159, 6)
                        self.assertEqual(ps.typeOf("double"), dafBase.PropertySet.TYPE_Double)
                        self.assertEqual(ps.getDouble("double"), 2.718281828459045)
                        self.assertEqual(ps.typeOf("char*"), dafBase.PropertySet.TYPE_String)
                        self.assertEqual(ps.getString("char*"), "foo")
                        self.assertEqual(ps.typeOf("string"), dafBase.PropertySet.TYPE_String)
                        self.assertEqual(ps.getString("string"), "bar")
                        self.assertEqual(ps.typeOf("int2"), dafBase.PropertySet.TYPE_Int)
                        self.assertEqual(ps.getInt("int2"), 2009)
                        self.assertEqual(ps.get("int2"), 2009)
                        self.assertEqual(ps.typeOf("dt"), dafBase.PropertySet.TYPE_DateTime)
                        self.assertEqual(ps.getDateTime("dt").nsecs(), 1238657233314159265L)
                
                    def testGetDefault(self):
                        ps = dafBase.PropertySet(flat=True)
                        ps.setInt("int", 42)
                        self.assertEqual(ps.getInt("int"), 42)
                        self.assertEqual(ps.getInt("int", 2008), 42)
                        self.assertEqual(ps.getInt("foo", 2008), 2008)
                
                    def testExists(self):
                        ps = dafBase.PropertySet(flat=True)
                        ps.setInt("int", 42)
                        self.assertEqual(ps.exists("int"), True)
                        self.assertEqual(ps.exists("foo"), False)
                
                    def testGetVector(self):
                        ps = dafBase.PropertySet(flat=True)
                        v = (42, 2008, 1)
                        ps.setInt("ints", v)
                        ps.setInt("ints2", (10, 9, 8))
                        w = ps.getArrayInt("ints")
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v, w)
                        self.assertEqual(ps.getInt("ints2"), 8)
                        self.assertEqual(ps.getArrayInt("ints2"), (10, 9, 8))
                        w = ps.get("ints", asArray=True)
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v, w)
                        ps.setInt("int", 999)
                        x = ps.get("int")
                        self.assertEqual(x, 999)
                        x = ps.get("int", asArray=True)
                        self.assertEqual(len(x), 1)
                        self.assertEqual(x, (999,))
                
                    def testGetVector2(self):
                        ps = dafBase.PropertySet(flat=True)
                        v = [42, 2008, 1]
                        ps.setInt("ints", v)
                        ps.setInt("ints2", [10, 9, 8])
                        w = ps.getArrayInt("ints")
                        self.assertEqual(len(w), 3)
                        self.assertEqual(v[0], w[0])
                        self.assertEqual(v[1], w[1])
                        self.assertEqual(v[2], w[2])
                        self.assertEqual(ps.getInt("ints2"), 8)
                        self.assertEqual(ps.getArrayInt("ints2"), (10, 9, 8))
                
                    def testAddScalar(self):
                        ps = dafBase.PropertySet(flat=True)
                        v = [42, 2008, 1]
                        ps.setInt("ints", v)
                        ps.addInt("ints", -999)
                        ps.add("other", "foo")
                        ps.add("ints", 13)
                        w = ps.getArrayInt("ints")
                        self.assertEqual(len(w), 5)
                        self.assertEqual(v[0], w[0])
                        self.assertEqual(v[1], w[1])
                        self.assertEqual(v[2], w[2])
                        self.assertEqual(w[3], -999)
                        self.assertEqual(w[4], 13)
                        self.assertEqual(ps.getString("other"), "foo")
                
                    def testDateTimeToString(self):
                        ps = dafBase.PropertySet(flat=True)
                        ps.set("dt", dafBase.DateTime("20090402T072639.314159265Z"))
                        self.assertEqual(ps.toString(),
                                "dt = 2009-04-02T07:26:39.314159265Z\n")
                
                    def testGetScalarThrow(self):
                        ps = dafBase.PropertySet(flat=True)
                        ps.setBool("bool", True)
                        ps.setShort("short", 42)
                        ps.setInt("int", 2008)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
275  <a href="#ab5b2c4c">ab5b2c4c</a> -         self.assertRaises(pexExcept.LsstException, ps.get, "foo")</div>
              ?                                     ^^^  ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
301  <a href="#ee7c5445">ee7c5445</a> +         self.assertRaises(pexExcept.NotFoundError, ps.get, "foo")</div>
              ?                                     ^^ +++++ ^^ ^
                
                    def testSubPS(self):
                        ps = dafBase.PropertySet(flat=True)
                        ps1 = dafBase.PropertySet()
                        ps1.set("a", 1)
                        ps1.add("a", 2)
                        ps1.set("foo", "bar")
                        ps.setPropertySet("b", ps1)
                        self.assertEqual(ps.exists("b.a"), True)
                        self.assertEqual(ps.get("b.a"), (1, 2))
                        self.assertEqual(ps.exists("b"), False)
                        self.assertEqual(ps.exists("b.foo"), True)
                        self.assertEqual(ps.get("b.foo"), "bar")
                
                        ps.set("b.c", 20)
                        self.assertEqual(ps.exists("b.c"), True)
                        self.assertEqual(ps.get("b.c"), 20)
                        self.assertEqual(ps.exists("b"), False)
                
                def suite():
                    """Returns a suite containing all the test cases in this module."""
                
                    utilsTests.init()
                
                    suites = []
                    suites += unittest.makeSuite(PropertySetTestCase)
                    suites += unittest.makeSuite(utilsTests.MemoryTestCase)
                
                    return unittest.TestSuite(suites)
                
                def run(exit=False):
                    """Run the tests"""
                    return utilsTests.run(suite(), exit)
                
                if __name__ == '__main__':
                    run(True)
                
                
                # BOOST_AUTO_TEST_CASE(getScalarThrow) {
                #     dafBase::PropertySet ps;
                #     ps.set("bool", true);
                #     short s = 42;
                #     ps.set("short", s);
                #     ps.set("int", 2008);
                #     ps.set("int64_t", 0xfeeddeadbeefLL);
                #     float f = 3.14159;
                #     ps.set("float", f);
                #     double d = 2.718281828459045;
                #     ps.set("double", d);
                #     ps.set<std::string>("char*", "foo");
                #     ps.set("char*2", "foo2");
                #     ps.set("string", std::string("bar"));
                # 
                #     BOOST_CHECK_THROW(ps.get<bool>("short"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<bool>("int"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<short>("int"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<int>("short"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<int>("bool"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<unsigned int>("int"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<double>("float"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<float>("double"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<std::string>("int"), boost::bad_any_cast);
                # }
                # 
                # 
                # BOOST_AUTO_TEST_CASE(addVector) {
                #     dafBase::PropertySet ps;
                #     std::vector<int> v;
                #     v.push_back(42);
                #     v.push_back(2008);
                #     v.push_back(1);
                #     ps.set("ints", v);
                # 
                #     std::vector<int> vv;
                #     vv.push_back(-42);
                #     vv.push_back(-2008);
                #     vv.push_back(-1);
                #     ps.add("ints", vv);
                # 
                #     std::vector<int> w = ps.getArray<int>("ints");
                #     BOOST_CHECK_EQUAL(w.size(), 6U);
                #     for (int i = 0; i < 3; ++i) {
                #         BOOST_CHECK_EQUAL(v[i], w[i]);
                #         BOOST_CHECK_EQUAL(vv[i], w[i + 3]);
                #     }
                # }
                # 
                # BOOST_AUTO_TEST_CASE(arrayProperties) {
                #     dafBase::PropertySet ps;
                #     std::vector<int> v;
                #     v.push_back(42);
                #     v.push_back(2008);
                #     v.push_back(1);
                #     ps.set("ints", v);
                #     ps.set("int", 365);
                #     ps.set("ints2", -42);
                #     ps.add("ints2", -2008);
                # 
                #     BOOST_CHECK_EQUAL(ps.isArray("ints"), true);
                #     BOOST_CHECK_EQUAL(ps.isArray("int"), false);
                #     BOOST_CHECK_EQUAL(ps.isArray("ints2"), true);
                #     BOOST_CHECK_EQUAL(ps.valueCount("ints"), 3U);
                #     BOOST_CHECK_EQUAL(ps.valueCount("int"), 1U);
                #     BOOST_CHECK_EQUAL(ps.valueCount("ints2"), 2U);
                #     BOOST_CHECK(ps.typeOf("ints") == typeid(int));
                #     BOOST_CHECK(ps.typeOf("int") == typeid(int));
                #     BOOST_CHECK(ps.typeOf("ints2") == typeid(int));
                # }
                # 
                # BOOST_AUTO_TEST_CASE(hierarchy) {
                #     dafBase::PropertySet ps;
                #     dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                # 
                #     psp->set("pre", 1);
                #     ps.set("ps1", psp);
                #     psp->set("post", 2);
                #     ps.set("int", 42);
                #     ps.set("ps2", dafBase::PropertySet::Ptr(new dafBase::PropertySet));
                #     ps.get<dafBase::PropertySet::Ptr>("ps2")->set("plus", 10.24);
                #     ps.set("ps2.minus", -10.24);
                #     ps.set("ps3.sub1", "foo");
                #     ps.set("ps3.sub2", "bar");
                # 
                #     BOOST_CHECK(ps.exists("ps1"));
                #     BOOST_CHECK(ps.exists("ps2"));
                #     BOOST_CHECK(ps.exists("ps3"));
                #     BOOST_CHECK(ps.exists("ps1.pre"));
                #     BOOST_CHECK(ps.exists("ps1.post"));
                #     BOOST_CHECK(ps.exists("ps2.plus"));
                #     BOOST_CHECK(ps.exists("ps2.minus"));
                #     BOOST_CHECK(ps.exists("ps3.sub1"));
                #     BOOST_CHECK(ps.exists("ps3.sub2"));
                # 
                #     BOOST_CHECK(ps.isPropertySetPtr("ps1"));
                #     BOOST_CHECK(ps.isPropertySetPtr("ps2"));
                #     BOOST_CHECK(ps.isPropertySetPtr("ps3"));
                #     BOOST_CHECK(!ps.isPropertySetPtr("int"));
                #     BOOST_CHECK(!ps.isPropertySetPtr("ps1.pre"));
                #     BOOST_CHECK(!ps.isPropertySetPtr("ps1.post"));
                #     BOOST_CHECK(!ps.isPropertySetPtr("ps2.plus"));
                #     BOOST_CHECK(!ps.isPropertySetPtr("ps2.minus"));
                #     BOOST_CHECK(!ps.isPropertySetPtr("ps3.sub1"));
                #     BOOST_CHECK(!ps.isPropertySetPtr("ps3.sub2"));
                # 
                #     dafBase::PropertySet::Ptr psp1 = ps.get<dafBase::PropertySet::Ptr>("ps1");
                #     dafBase::PropertySet::Ptr psp2 = ps.get<dafBase::PropertySet::Ptr>("ps2");
                #     dafBase::PropertySet::Ptr psp3 = ps.get<dafBase::PropertySet::Ptr>("ps3");
                #     BOOST_CHECK(psp1);
                #     BOOST_CHECK(psp2);
                #     BOOST_CHECK(psp3);
                #     BOOST_CHECK(psp1 == psp);
                #     BOOST_CHECK(psp1->exists("pre"));
                #     BOOST_CHECK(psp1->exists("post"));
                #     BOOST_CHECK(psp2->exists("plus"));
                #     BOOST_CHECK(psp2->exists("minus"));
                #     BOOST_CHECK(psp3->exists("sub1"));
                #     BOOST_CHECK(psp3->exists("sub2"));
                #     BOOST_CHECK_EQUAL(psp1->get<int>("pre"), 1);
                #     BOOST_CHECK_EQUAL(psp1->get<int>("post"), 2);
                #     BOOST_CHECK_EQUAL(psp2->get<double>("plus"), 10.24);
                #     BOOST_CHECK_EQUAL(psp2->get<double>("minus"), -10.24);
                #     BOOST_CHECK_EQUAL(psp3->get<std::string>("sub1"), "foo");
                #     BOOST_CHECK_EQUAL(psp3->get<std::string>("sub2"), "bar");
                # 
                #     // Make sure checking a subproperty doesn't create it.
                #     BOOST_CHECK(!ps.exists("ps2.pre"));
                #     BOOST_CHECK(!ps.exists("ps2.pre"));
                #     // Make sure checking an element doesn't create it.
                #     BOOST_CHECK(!ps.exists("ps4"));
                #     BOOST_CHECK(!ps.exists("ps4"));
                #     // Make sure checking a subproperty with a nonexistent parent doesn't
                #     // create it.
                #     BOOST_CHECK(!ps.exists("ps4.sub"));
                #     BOOST_CHECK(!ps.exists("ps4.sub"));
                #     // Make sure checking a subproperty doesn't create its parent.
                #     BOOST_CHECK(!ps.exists("ps4"));
                # }
                # 
                # BOOST_AUTO_TEST_CASE(variousThrows) {
                #     dafBase::PropertySet ps;
                #     ps.set("int", 42);
                #     BOOST_CHECK_THROW(ps.set("int.sub", "foo"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
458  <a href="#5684f115">5684f115</a> - #                       lsst::pex::exceptions::InvalidParameterException);</div>
              ?                                                                 ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
484  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::InvalidParameterError);</div>
              ?                                                                 ^^ ^
                #     BOOST_CHECK_THROW(ps.get<double>("int"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.get<double>("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
461  <a href="#5684f115">5684f115</a> - #                       lsst::pex::exceptions::NotFoundException);</div>
              ?                                                         ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
487  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::NotFoundError);</div>
              ?                                                         ^^ ^
                #     BOOST_CHECK_THROW(ps.getArray<double>("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
463  <a href="#5684f115">5684f115</a> - #                       lsst::pex::exceptions::NotFoundException);</div>
              ?                                                         ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
489  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::NotFoundError);</div>
              ?                                                         ^^ ^
                #     BOOST_CHECK_THROW(ps.typeOf("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
465  <a href="#5684f115">5684f115</a> - #                       lsst::pex::exceptions::NotFoundException);</div>
              ?                                                         ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
491  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::NotFoundError);</div>
              ?                                                         ^^ ^
                #     BOOST_CHECK_THROW(ps.add("int", 4.2),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
467  <a href="#5684f115">5684f115</a> - #                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                           ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
493  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::DomainError);</div>
                #     std::vector<double> v;
                #     v.push_back(3.14159);
                #     v.push_back(2.71828);
                #     BOOST_CHECK_THROW(ps.add("int", v),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
472  <a href="#5684f115">5684f115</a> - #                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                           ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
498  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::DomainError);</div>
                #     BOOST_CHECK_NO_THROW(ps.remove("foo.bar"));
                #     BOOST_CHECK_NO_THROW(ps.remove("int.sub"));
                # }
                # 
                # BOOST_AUTO_TEST_CASE(names) {
                #     dafBase::PropertySet ps;
                #     ps.set("ps1.pre", 1);
                #     ps.set("ps1.post", 2);
                #     ps.set("int", 42);
                #     ps.set("double", 3.14);
                #     ps.set("ps2.plus", 10.24);
                #     ps.set("ps2.minus", -10.24);
                # 
                #     BOOST_CHECK_EQUAL(ps.nameCount(), 4U);
                #     BOOST_CHECK_EQUAL(ps.nameCount(false), 8U);
                # 
                #     std::vector<std::string> v = ps.names();
                #     BOOST_CHECK_EQUAL(v.size(), 4U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "double");
                #     BOOST_CHECK_EQUAL(v[1], "int");
                #     BOOST_CHECK_EQUAL(v[2], "ps1");
                #     BOOST_CHECK_EQUAL(v[3], "ps2");
                #     v = ps.names(false);
                #     BOOST_CHECK_EQUAL(v.size(), 8U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "double");
                #     BOOST_CHECK_EQUAL(v[1], "int");
                #     BOOST_CHECK_EQUAL(v[2], "ps1");
                #     BOOST_CHECK_EQUAL(v[3], "ps1.post");
                #     BOOST_CHECK_EQUAL(v[4], "ps1.pre");
                #     BOOST_CHECK_EQUAL(v[5], "ps2");
                #     BOOST_CHECK_EQUAL(v[6], "ps2.minus");
                #     BOOST_CHECK_EQUAL(v[7], "ps2.plus");
                # }
                # 
                # BOOST_AUTO_TEST_CASE(paramNames) {
                #     dafBase::PropertySet ps;
                #     ps.set("ps1.pre", 1);
                #     ps.set("ps1.post", 2);
                #     ps.set("int", 42);
                #     ps.set("double", 3.14);
                #     ps.set("ps2.plus", 10.24);
                #     ps.set("ps2.minus", -10.24);
                # 
                #     std::vector<std::string> v = ps.paramNames();
                #     BOOST_CHECK_EQUAL(v.size(), 2U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "double");
                #     BOOST_CHECK_EQUAL(v[1], "int");
                #     v = ps.paramNames(false);
                #     BOOST_CHECK_EQUAL(v.size(), 6U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "double");
                #     BOOST_CHECK_EQUAL(v[1], "int");
                #     BOOST_CHECK_EQUAL(v[2], "ps1.post");
                #     BOOST_CHECK_EQUAL(v[3], "ps1.pre");
                #     BOOST_CHECK_EQUAL(v[4], "ps2.minus");
                #     BOOST_CHECK_EQUAL(v[5], "ps2.plus");
                # }
                # 
                # BOOST_AUTO_TEST_CASE(propertySetNames) {
                #     dafBase::PropertySet ps;
                #     ps.set("ps1.pre", 1);
                #     ps.set("ps1.post", 2);
                #     ps.set("int", 42);
                #     ps.set("double", 3.14);
                #     ps.set("ps2.plus", 10.24);
                #     ps.set("ps2.minus", -10.24);
                #     ps.set("ps3.sub.subsub", "foo");
                # 
                #     std::vector<std::string> v = ps.propertySetNames();
                #     BOOST_CHECK_EQUAL(v.size(), 3U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "ps1");
                #     BOOST_CHECK_EQUAL(v[1], "ps2");
                #     BOOST_CHECK_EQUAL(v[2], "ps3");
                #     v = ps.propertySetNames(false);
                #     BOOST_CHECK_EQUAL(v.size(), 4U);
                #     std::sort(v.begin(), v.end());
                #     BOOST_CHECK_EQUAL(v[0], "ps1");
                #     BOOST_CHECK_EQUAL(v[1], "ps2");
                #     BOOST_CHECK_EQUAL(v[2], "ps3");
                #     BOOST_CHECK_EQUAL(v[3], "ps3.sub");
                # }
                # 
                # BOOST_AUTO_TEST_CASE(getAs) {
                #     dafBase::PropertySet ps;
                #     ps.set("bool", true);
                #     ps.set("char", 'A');
                #     short s = 42;
                #     ps.set("short", s);
                #     ps.set("int", 2008);
                #     ps.set("int64_t", 0xfeeddeadbeefLL);
                #     float f = 3.14159;
                #     ps.set("float", f);
                #     double d = 2.718281828459045;
                #     ps.set("double", d);
                #     ps.set<std::string>("char*", "foo");
                #     ps.set("char*2", "foo2");
                #     ps.set("string", std::string("bar"));
                #     dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                #     psp->set("bottom", "x");
                #     ps.set("top", psp);
                # 
                #     BOOST_CHECK_EQUAL(ps.getAsBool("bool"), true);
                #     BOOST_CHECK_THROW(ps.getAsBool("char"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(ps.getAsInt("bool"), 1);
                #     BOOST_CHECK_EQUAL(ps.getAsInt("char"), static_cast<int>('A'));
                #     BOOST_CHECK_EQUAL(ps.getAsInt("short"), 42);
                #     BOOST_CHECK_EQUAL(ps.getAsInt("int"), 2008);
                #     BOOST_CHECK_THROW(ps.getAsInt("int64_t"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(ps.getAsInt64("bool"), 1LL);
                #     BOOST_CHECK_EQUAL(ps.getAsInt64("char"), static_cast<int64_t>('A'));
                #     BOOST_CHECK_EQUAL(ps.getAsInt64("short"), 42LL);
                #     BOOST_CHECK_EQUAL(ps.getAsInt64("int"), 2008LL);
                #     BOOST_CHECK_EQUAL(ps.getAsInt64("int64_t"), 0xfeeddeadbeefLL);
                #     BOOST_CHECK_THROW(ps.getAsInt64("float"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("bool"), 1.0);
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("char"), static_cast<double>('A'));
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("short"), 42.0);
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("int"), 2008.0);
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("int64_t"),
                #                       static_cast<double>(0xfeeddeadbeefLL));
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("float"), 3.14159f);
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("double"), 2.718281828459045);
                #     BOOST_CHECK_THROW(ps.getAsDouble("char*"), boost::bad_any_cast);
                #     BOOST_CHECK_THROW(ps.getAsString("char"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(ps.getAsString("char*"), "foo");
                #     BOOST_CHECK_EQUAL(ps.getAsString("char*2"), "foo2");
                #     BOOST_CHECK_EQUAL(ps.getAsString("string"), "bar");
                #     BOOST_CHECK_THROW(ps.getAsString("int"), boost::bad_any_cast);
                #     BOOST_CHECK_EQUAL(ps.getAsString("top.bottom"), "x");
                #     BOOST_CHECK_EQUAL(ps.getAsPropertySetPtr("top"), psp);
                #     BOOST_CHECK_THROW(ps.getAsPropertySetPtr("top.bottom"),
                #                       boost::bad_any_cast);
                # }
                # 
                # BOOST_AUTO_TEST_CASE(combine) {
                #     dafBase::PropertySet ps;
                #     ps.set("ps1.pre", 1);
                #     ps.set("ps1.post", 2);
                #     ps.set("int", 42);
                #     ps.set("double", 3.14);
                #     ps.set("ps2.plus", 10.24);
                #     ps.set("ps2.minus", -10.24);
                #     ps.set("ps3.sub.subsub", "foo");
                # 
                #     dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                #     psp->set("ps1.pre", 3);
                #     psp->add("ps1.pre", 4);
                #     psp->set("int", 2008);
                #     psp->set("ps2.foo", "bar");
                #     psp->set("ps4.top", "bottom");
                # 
                #     ps.combine(psp);
                # 
                #     BOOST_CHECK(ps.isPropertySetPtr("ps1"));
                #     BOOST_CHECK(ps.isPropertySetPtr("ps2"));
                #     BOOST_CHECK(ps.isPropertySetPtr("ps3"));
                #     BOOST_CHECK(ps.isPropertySetPtr("ps3.sub"));
                #     BOOST_CHECK(ps.isPropertySetPtr("ps4"));
                #     BOOST_CHECK(!ps.isArray("ps1"));
                #     BOOST_CHECK(ps.isArray("ps1.pre"));
                #     BOOST_CHECK(!ps.isArray("ps1.post"));
                #     BOOST_CHECK(!ps.isArray("ps2"));
                #     BOOST_CHECK(!ps.isArray("ps2.plus"));
                #     BOOST_CHECK(!ps.isArray("ps2.minus"));
                #     BOOST_CHECK(!ps.isArray("ps2.foo"));
                #     BOOST_CHECK(!ps.isArray("ps3"));
                #     BOOST_CHECK(!ps.isArray("ps3.sub"));
                #     BOOST_CHECK(!ps.isArray("ps3.subsub"));
                #     BOOST_CHECK(!ps.isArray("ps4"));
                #     BOOST_CHECK(!ps.isArray("ps4.top"));
                #     BOOST_CHECK(ps.isArray("int"));
                #     BOOST_CHECK(!ps.isArray("double"));
                #     BOOST_CHECK_EQUAL(ps.valueCount("ps1.pre"), 3U);
                #     BOOST_CHECK_EQUAL(ps.valueCount("int"), 2U);
                #     std::vector<int> v = ps.getArray<int>("ps1.pre");
                #     BOOST_CHECK_EQUAL(v[0], 1);
                #     BOOST_CHECK_EQUAL(v[1], 3);
                #     BOOST_CHECK_EQUAL(v[2], 4);
                #     v = ps.getArray<int>("int");
                #     BOOST_CHECK_EQUAL(v[0], 42);
                #     BOOST_CHECK_EQUAL(v[1], 2008);
                # }
                # 
                # BOOST_AUTO_TEST_CASE(combineThrow) {
                #     dafBase::PropertySet ps;
                #     ps.set("int", 42);
                # 
                #     dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                #     psp->set("int", 3.14159);
                # 
                #     BOOST_CHECK_THROW(ps.combine(psp),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
668  <a href="#5684f115">5684f115</a> - #                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                           ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
694  <a href="#25738fd8">25738fd8</a> + #                       lsst::pex::exceptions::DomainError);</div>
                # }
                # 
                # BOOST_AUTO_TEST_CASE(remove) {
                #     dafBase::PropertySet ps;
                #     ps.set("int", 42);
                #     ps.set("double", 3.14159);
                #     ps.set("ps1.plus", 1);
                #     ps.set("ps1.minus", -1);
                #     ps.set("ps1.zero", 0);
                #     BOOST_CHECK_EQUAL(ps.nameCount(false), 6U);
                # 
                #     ps.remove("int");
                #     BOOST_CHECK(!ps.exists("int"));
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("double"), 3.14159);
                #     BOOST_CHECK_EQUAL(ps.getAsInt("ps1.plus"), 1);
                #     BOOST_CHECK_EQUAL(ps.getAsInt("ps1.minus"), -1);
                #     BOOST_CHECK_EQUAL(ps.getAsInt("ps1.zero"), 0);
                #     BOOST_CHECK_EQUAL(ps.nameCount(false), 5U);
                # 
                #     ps.remove("ps1.zero");
                #     BOOST_CHECK(!ps.exists("int"));
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("double"), 3.14159);
                #     BOOST_CHECK(!ps.exists("ps1.zero"));
                #     BOOST_CHECK_EQUAL(ps.getAsInt("ps1.plus"), 1);
                #     BOOST_CHECK_EQUAL(ps.getAsInt("ps1.minus"), -1);
                #     BOOST_CHECK_EQUAL(ps.nameCount(false), 4U);
                # 
                #     ps.remove("ps1");
                #     BOOST_CHECK(!ps.exists("int"));
                #     BOOST_CHECK_EQUAL(ps.getAsDouble("double"), 3.14159);
                #     BOOST_CHECK(!ps.exists("ps1"));
                #     BOOST_CHECK(!ps.exists("ps1.plus"));
                #     BOOST_CHECK(!ps.exists("ps1.minus"));
                #     BOOST_CHECK(!ps.exists("ps1.zero"));
                #     BOOST_CHECK_EQUAL(ps.nameCount(false), 1U);
                # 
                #     ps.remove("double");
                #     BOOST_CHECK(!ps.exists("int"));
                #     BOOST_CHECK(!ps.exists("double"));
                #     BOOST_CHECK(!ps.exists("ps1"));
                #     BOOST_CHECK(!ps.exists("ps1.plus"));
                #     BOOST_CHECK(!ps.exists("ps1.minus"));
                #     BOOST_CHECK(!ps.exists("ps1.zero"));
                #     BOOST_CHECK_EQUAL(ps.nameCount(false), 0U);
                # }
                # 
                # BOOST_AUTO_TEST_CASE(deepCopy) {
                #     dafBase::PropertySet ps;
                #     ps.set("int", 42);
                #     dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                #     psp->set("bottom", "x");
                #     ps.set("top", psp);
                # 
                #     dafBase::PropertySet::Ptr psp2 = ps.deepCopy();
                #     BOOST_CHECK(psp2->exists("int"));
                #     BOOST_CHECK(psp2->exists("top.bottom"));
                #     BOOST_CHECK_EQUAL(psp2->getAsInt("int"), 42);
                #     BOOST_CHECK_EQUAL(psp2->getAsString("top.bottom"), "x");
                #     // Make sure it was indeed a deep copy.
                #     BOOST_CHECK(psp2->getAsPropertySetPtr("top") != psp);
                #     ps.set("int", 2008);
                #     ps.set("top.bottom", "y");
                #     BOOST_CHECK_EQUAL(ps.getAsInt("int"), 2008);
                #     BOOST_CHECK_EQUAL(ps.getAsString("top.bottom"), "y");
                #     BOOST_CHECK_EQUAL(psp->getAsString("bottom"), "y");
                #     BOOST_CHECK_EQUAL(psp2->getAsInt("int"), 42);
                #     BOOST_CHECK_EQUAL(psp2->getAsString("top.bottom"), "x");
                # }
                # 
                # BOOST_AUTO_TEST_CASE(toString) {
                #     dafBase::PropertySet ps;
                #     ps.set("bool", true);
                #     ps.set("char", '*');
                #     short s = 42;
                #     ps.set("short", s);
                #     ps.set("int", 2008);
                #     ps.set("int64_t", 0xfeeddeadbeefLL);
                #     float f = 3.14159;
                #     ps.set("float", f);
                #     double d = 2.718281828459045;
                #     ps.set("double", d);
                #     ps.set<std::string>("char*", "foo");
                #     ps.set("char*2", "foo2");
                #     ps.set("string", std::string("bar"));
                #     ps.set("ps1.pre", 1);
                #     ps.set("ps1.post", 2);
                #     ps.set("ps2.plus", 10.24);
                #     ps.set("ps2.minus", -10.24);
                #     ps.set("ps3.sub.subsub", "foo");
                #     ps.add("v", 10);
                #     ps.add("v", 9);
                #     ps.add("v", 8);
                # 
                #     BOOST_CHECK_EQUAL(ps.toString(),
                #         "bool = 1\n"
                #         "char = '*'\n"
                #         "char* = \"foo\"\n"
                #         "char*2 = \"foo2\"\n"
                #         "double = 2.71828\n"
                #         "float = 3.14159\n"
                #         "int = 2008\n"
                #         "int64_t = 280297596632815\n"
                #         "ps1 = {\n"
                #         "..post = 2\n"
                #         "..pre = 1\n"
                #         "}\n"
                #         "ps2 = {\n"
                #         "..minus = -10.24\n"
                #         "..plus = 10.24\n"
                #         "}\n"
                #         "ps3 = {\n"
                #         "..sub = {\n"
                #         "....subsub = \"foo\"\n"
                #         "..}\n"
                #         "}\n"
                #         "short = 42\n"
                #         "string = \"bar\"\n"
                #         "v = [ 10, 9, 8 ]\n"
                #         );
                #     BOOST_CHECK_EQUAL(ps.toString(true),
                #         "bool = 1\n"
                #         "char = '*'\n"
                #         "char* = \"foo\"\n"
                #         "char*2 = \"foo2\"\n"
                #         "double = 2.71828\n"
                #         "float = 3.14159\n"
                #         "int = 2008\n"
                #         "int64_t = 280297596632815\n"
                #         "ps1 = { ... }\n"
                #         "ps2 = { ... }\n"
                #         "ps3 = { ... }\n"
                #         "short = 42\n"
                #         "string = \"bar\"\n"
                #         "v = [ 10, 9, 8 ]\n"
                #         );
                # }
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="5684f115"/></a>5684f115</h3>

<pre>
commit 5684f1152b34043b04aa78a9a22e2040d334aea0
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Nov 27 00:55:47 2008 +0000

    Merged revisions 6456-6607 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/base/tickets/480
    
    ........
      r6456 | ktlim | 2008-11-22 19:10:27 -0800 (Sat, 22 Nov 2008) | 2 lines
    
      Create new ticket branch for PropertySet addition.
    ........
      r6486 | ktlim | 2008-11-24 21:51:45 -0800 (Mon, 24 Nov 2008) | 1 line
    
      Initial checkin of PropertySet skeleton.
    ........
      r6487 | ktlim | 2008-11-24 23:39:09 -0800 (Mon, 24 Nov 2008) | 1 line
    
      Begin implementing get() and set() methods.
    ........
      r6555 | ktlim | 2008-11-25 21:12:26 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Remove old DataProperty.i.
    ........
      r6556 | ktlim | 2008-11-25 21:13:21 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Add many, many test cases for PropertySet.
    ........
      r6557 | ktlim | 2008-11-25 21:14:03 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Only boost headers are needed now.  TR1 is tested for in sconsUtils.
    ........
      r6558 | ktlim | 2008-11-25 21:17:59 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Major implementation change: use a vector<boost::any> instead of a boost::any containing a vector<T>.  Simplifies the normal cases substantially.  getArray() now has to return a vector instead of a reference.  Added convenience methods to allow set() and add() with char const* (still retrieved as std::string).  Added private methods for recursive descent with multipart names.
    ........
      r6559 | ktlim | 2008-11-25 21:18:30 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Implement all PropertySet functionality.
    ........
      r6564 | ktlim | 2008-11-25 23:53:45 -0800 (Tue, 25 Nov 2008) | 1 line
    
      remove() doesn't throw, even if the name doesn't or can't exist.  Test for various exceptions.
    ........
      r6565 | ktlim | 2008-11-26 01:51:28 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Add char test cases.  Change type of exception returned by bad combine.
    ........
      r6566 | ktlim | 2008-11-26 01:57:08 -0800 (Wed, 26 Nov 2008) | 2 lines
    
      Improve exception safety for private findOrInsert() method.  Add handling for signed char.  Instantiate templates for char/signed char/unsigned char.  Improve toString() output for char types.  Change exception type returned for mismatches in combine().  Standardize on back() for type checking rather than at(0).  Add lots of doxygen comments.
    ........
      r6580 | ktlim | 2008-11-26 09:10:10 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Exclude python (for now) and tests directories from docs.  Set (a slightly more meaningful) version number.
    ........
      r6581 | ktlim | 2008-11-26 09:10:33 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Fix comment for getAsInt64().
    ........
      r6582 | ktlim | 2008-11-26 09:12:37 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Enable use of vectors, set(), add(), and getArray() from Python.  Types must be specified explicitly except for set(string) and add(string).  Only bool, int, double, string are supported for now.
    ........
      r6583 | ktlim | 2008-11-26 11:55:45 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Use pex_exceptions instead of std::runtime_error.
    ........
      r6584 | ktlim | 2008-11-26 12:36:51 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Improve PropertySet Python interface.
    ........
      r6602 | ktlim | 2008-11-26 14:56:42 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Handle topLevelOnly better.
    ........
      r6603 | ktlim | 2008-11-26 14:58:49 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Add a test for toString(true).
    ........
      r6606 | ktlim | 2008-11-26 16:53:12 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Initial Python tests.
    ........
</pre>
<h3><a name="32535046"/></a>32535046</h3>

<pre>
commit 325350464b599ff27a1b9149ca58f969508c9188
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Wed Apr 7 23:50:43 2010 +0000

    Fix test case.
</pre>
<h3><a name="ab5b2c4c"/></a>ab5b2c4c</h3>

<pre>
commit ab5b2c4cf63fa69eb918b4fe9a95ee8b51558763
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Tue Dec 11 12:00:05 2012 -0800

    Enable flattened PropertySets.  Make PropertyLists default to flat.  Add PropertySets/Lists to flattened PropertySets by using dotted names.  Refactor common code into _add().
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="bb936e92"/></a>bb936e92</h3>

<pre>
commit bb936e9230d470ba6cfc08d8407d9afcd46a827e
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Wed Apr 8 16:20:54 2015 -0400

    Use new numeric typemaps to support NumPy scalar arguments.
</pre>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
<h3><a name="ee7c5445"/></a>ee7c5445</h3>

<pre>
commit ee7c544513b5a8ce704733c028019930be619168
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 14:22:00 2014 -0400

    Adapt to changes in Python Swig interface (DM-827)
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_18"><a name="examples/citizen.cc"/></a>examples/citizen.cc</h1>

<h3 id="toc_19">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                #include <iostream>
                #include <stdexcept>
                
                #include <boost/format.hpp>
                #include <boost/shared_ptr.hpp>
                #include <boost/scoped_ptr.hpp>
                #include "lsst/pex/exceptions.h"
                #include "lsst/daf/base/Citizen.h"
                
                //
                // We'll fully qualify LsstBase here in the class definitions;
                // when we come to exercise the classes we'll use lsst::fw
                
                namespace rhl {
                
                class Shoe : public lsst::daf::base::Citizen {
                public:
                    explicit Shoe(int i = 0) : Citizen(typeid(this)), _i(i) { };
                    ~Shoe() { };
                private:
                    int _i;
                };
                
                }
                
                using namespace rhl;
                
                class MyClass : public lsst::daf::base::Citizen {
                public:
                    explicit MyClass(char const* typeName = 0);
                    int addOne();
                private:
                    boost::scoped_ptr<int> _ptr;         // no need to track this alloc
                };
                
                MyClass::MyClass(char const* /* typeName */) :
                    lsst::daf::base::Citizen(typeid(this)),
                    _ptr(new int) {
                    *_ptr = 0;
                }
                
                int MyClass::addOne() {
                    return ++*_ptr;
                }
                
                using namespace lsst::daf::base;
                
                MyClass *foo() {
                    boost::scoped_ptr<Shoe> x(new Shoe(1));
                    MyClass *myInstance = new MyClass();
                
                    std::cout << "In foo\n";
                    Citizen::census(std::cout);
                
                    return myInstance;
                }
                
                Citizen::memId newCallback(Citizen::memId const cid) {
                    std::cout << boost::format("\tRHL Allocating memId %d\n") % cid;
                
                    return 2;                           // trace every other subsequent allocs
                }
                
                Citizen::memId deleteCallback(Citizen const* ptr) {
                    std::cout << boost::format("\tRHL deleting memId %s\n") % ptr->repr();
                
                    return 0;
                }
                
                int main() {
                #if 1
                    (void)Citizen::setNewCallbackId(2);
                    (void)Citizen::setDeleteCallbackId(3);
                    (void)Citizen::setNewCallback(newCallback);
                    (void)Citizen::setDeleteCallback(deleteCallback);
                #endif
                    Citizen::memId const firstId = Citizen::getNextMemId();
                    Shoe x;
                
                    // x isn't going to be deleted until main exists, so don't list as a leak
                    x.markPersistent();
                    
                    boost::scoped_ptr<Shoe> y(new Shoe);
                    boost::scoped_ptr<Shoe> z(new Shoe(10));
                    
                    MyClass *mine = ::foo();
                
                    std::cout << boost::format("In main (%d objects)\n") % Citizen::census(0);
                
                    boost::scoped_ptr<std::vector<Citizen const*> const> leaks(Citizen::census());
                    for (std::vector<Citizen const*>::const_iterator cur = leaks->begin();
                         cur != leaks->end(); cur++) {
                        std::cerr << boost::format("    %s\n") % (*cur)->repr();
                    }
                
                    z.reset();                          // i.e. delete pointed-to object
                    delete mine;
                
                    ((int *)y.get())[0] = 0;            // deliberately corrupt the block
                    try {
                        std::cerr << "Checking corruption\n";
                        (void)Citizen::hasBeenCorrupted();
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
125  <a href="#e214190f">e214190f</a> -     } catch(lsst::pex::exceptions::MemoryException& e) {</div>
              ?                                           ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
125  <a href="#25738fd8">25738fd8</a> +     } catch(lsst::pex::exceptions::MemoryError& e) {</div>
              ?                                           ^^ ^
                        std::cerr << "Memory check: " << e <<
                            "Proceeding with trepidation\n";
                        ((int *)y.get())[0] = 0xdeadbeef; // uncorrupt the block
                    }
                
                    y.reset();
                
                    std::cout << boost::format("In main (%d objects)\n") % Citizen::census(0, firstId);
                    Citizen::census(std::cout, firstId);
                    
                    return 0;
                }
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="e214190f"/></a>e214190f</h3>

<pre>
commit e214190feeafcb50bb8a36a5f83f8ffba13ec6e4
Author: rhl <rhl@git.lsstcorp.org>
Date:   Fri Jan 9 21:34:48 2009 +0000

    1/ Reinstate throw in case of memory corruption
    2/ Copy citizen.cc from examples to tests and fix -- the original test
    case was correct; it only seemed to start failing as Jeff Bartels
    had removed the throw (see 1)
    3/ Don't run the examples as part of the build
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_20"><a name="include/lsst/daf/base/PropertySet.h"/></a>include/lsst/daf/base/PropertySet.h</h1>

<h3 id="toc_21">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                #ifndef LSST_DAF_BASE_PROPERTYSET
                #define LSST_DAF_BASE_PROPERTYSET
                
                /** @file
                  * @ingroup daf_base
                  *
                  * @brief Interface for PropertySet class
                  *
                  * @version $Revision$
                  * @date $Date$
                  */
                
                /** @class lsst::daf::base::PropertySet
                  * @brief Class for storing generic metadata.
                  *
                  * This class stores key/value pairs, like a Python dictionary but in C++.
                  * Keys are always C++ strings.  Values can be C++ primitive data types,
                  * strings, lsst::daf::base::DateTime objects, and lsst::daf::base::Persistable
                  * subclasses (although the latter is currently discouraged).  Values can also
                  * be vectors of these items.
                  *
                  * PropertySets are hierarchical; values within a PropertySet that is contained
                  * within another PropertySet can be addressed using dotted paths ("a.b.c").
                  * If "flat=true" is specified to the constructor, the PropertySet still takes
                  * dotted paths but is not actually hierarchical in structure.  This is used to
                  * support PropertyList.
                  *
                  * @ingroup daf_base
                  */
                
                #include <lsst/tr1/unordered_map.h>
                #include <string>
                #include <typeinfo>
                #include <vector>
                
                #include "boost/any.hpp"
                #include "boost/noncopyable.hpp"
                #include "boost/shared_ptr.hpp"
                #include "lsst/daf/base/Citizen.h"
                #include "lsst/daf/base/Persistable.h"
                #include "lsst/pex/exceptions.h"
                
                namespace lsst {
                namespace daf {
                
                namespace persistence {
                    class PropertySetFormatter;
                } // namespace lsst::daf::persistence
                
                
                namespace base {
                
                #if defined(__ICC)
                #pragma warning (push)
                #pragma warning (disable: 444)
                #endif
                
                class PropertySet :
                    public Persistable, public Citizen
                #ifndef SWIG
                    , public boost::noncopyable
                #endif
                    {
                public:
                // Typedefs
                    typedef boost::shared_ptr<PropertySet> Ptr;
                    typedef boost::shared_ptr<PropertySet const> ConstPtr;
                
                // Constructors
                    explicit PropertySet(bool flat=false);
                    virtual ~PropertySet(void);
                
                // Accessors
                    virtual Ptr deepCopy(void) const;
                    // Returns a PropertySet::Ptr pointing to a new deep copy.
                
                    size_t nameCount(bool topLevelOnly = true) const;
                    std::vector<std::string> names(bool topLevelOnly = true) const;
                    std::vector<std::string> paramNames(bool topLevelOnly = true) const;
                    std::vector<std::string> propertySetNames(bool topLevelOnly = true) const;
                
                    bool exists(std::string const& name) const;
                    bool isArray(std::string const& name) const;
                    bool isPropertySetPtr(std::string const& name) const;
                
                    size_t valueCount(std::string const& name) const;
                    std::type_info const& typeOf(std::string const& name) const;
                        // This returns typeof(vector::value_type), not the type of the value
                        // vector itself.
                
                    // The following throw an exception if the type does not match exactly.
                    template <typename T> T get(std::string const& name) const;
                        // Note that the type must be explicitly specified for this template:
                        // int i = propertySet.get<int>("foo");
                    template <typename T>
                        T get(std::string const& name, T const& defaultValue) const;
                        // Returns the provided default value if the name does not exist.
                    template <typename T>
                        std::vector<T> getArray(std::string const& name) const;
                
                    // The following throw an exception if the conversion is inappropriate.
                    bool getAsBool(std::string const& name) const;      // for bools only
                    int getAsInt(std::string const& name) const;        // bool/char/short/int
                    int64_t getAsInt64(std::string const& name) const;  // above + int64_t
                    double getAsDouble(std::string const& name) const;  // + float, double
                    std::string getAsString(std::string const& name) const; // for strings only
                    PropertySet::Ptr getAsPropertySetPtr(std::string const& name) const;
                    Persistable::Ptr getAsPersistablePtr(std::string const& name) const;
                
                    // Use this for debugging, not for serialization/persistence.
                    virtual std::string toString(bool topLevelOnly = false,
                                    std::string const& indent = "") const;
                
                // Modifiers
                    template <typename T> void set(std::string const& name, T const& value);
                    template <typename T> void set(std::string const& name,
                                                   std::vector<T> const& value);
                    void set(std::string const& name, char const* value);
                    template <typename T> void add(std::string const& name, T const& value);
                    template <typename T> void add(std::string const& name,
                                                   std::vector<T> const& value);
                    void add(std::string const& name, char const* value);
                
                    virtual void copy(std::string const& dest, ConstPtr source,
                                      std::string const& name);
                    virtual void combine(ConstPtr source);
                        // All vectors from the source are add()ed to the destination with the
                        // same names.  Types must match.
                
                    virtual void remove(std::string const& name);
                
                protected:
                    virtual void _set(std::string const& name,
                                      boost::shared_ptr< std::vector<boost::any> > vp);
                    virtual void _add(std::string const& name,
                                      boost::shared_ptr< std::vector<boost::any> > vp);
                    virtual std::string _format(std::string const& name) const;
                
                private:
                    LSST_PERSIST_FORMATTER(lsst::daf::persistence::PropertySetFormatter)
                
                    typedef std::tr1::unordered_map<std::string,
                            boost::shared_ptr< std::vector<boost::any> > > AnyMap;
                
                    AnyMap::iterator _find(std::string const& name);
                    AnyMap::const_iterator _find(std::string const& name) const;
                    virtual void _findOrInsert(std::string const& name,
                                      boost::shared_ptr< std::vector<boost::any> > vp);
                    void _cycleCheckPtrVec(std::vector<Ptr> const& v, std::string const& name);
                    void _cycleCheckAnyVec(std::vector<boost::any> const& v,
                                          std::string const& name);
                    void _cycleCheckPtr(Ptr const& v, std::string const& name);
                
                    AnyMap _map;
                    bool _flat;
                };
                
                #if defined(__ICC)
                #pragma warning (pop)
                #endif    
                
                template<> void PropertySet::add<PropertySet::Ptr>(
                    std::string const& name, Ptr const& value);
                template<> void PropertySet::add<PropertySet::Ptr>(
                    std::string const& name, std::vector<Ptr> const& value);
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
191  <a href="#a494ae4a">a494ae4a</a> - LSST_EXCEPTION_TYPE(TypeMismatchException,</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
192  <a href="#a494ae4a">a494ae4a</a> -                     lsst::pex::exceptions::LogicErrorException,</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
193  <a href="#a494ae4a">a494ae4a</a> -                     lsst::daf::base::TypeMismatchException)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
194  <a href="#a494ae4a">a494ae4a</a> - </div>
                }}} // namespace lsst::daf::base
                
                #endif
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="a494ae4a"/></a>a494ae4a</h3>

<pre>
commit a494ae4ac055a8632a6688d128c0e3a100122ff6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Jan 13 00:15:19 2009 +0000

    Throw dafBase::TypeMismatchException instead of boost::bad_any_cast.  #564
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_22"><a name="src/PropertyList.cc"/></a>src/PropertyList.cc</h1>

<h3 id="toc_23">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** @file
                  * @ingroup daf_base
                  *
                  * @brief Implementation for PropertyList class
                  *
                  * @version $Revision$
                  * @date $Date$
                  *
                  * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                  */
                
                #include "lsst/daf/base/PropertyList.h"
                
                #include <algorithm>
                #include <iomanip>
                #include <sstream>
                #include <stdexcept>
                
                #include "lsst/pex/exceptions/Runtime.h"
                #include "lsst/daf/base/DateTime.h"
                
                namespace pexExcept = lsst::pex::exceptions;
                
                using namespace std;
                
                namespace lsst {
                namespace daf {
                namespace base {
                
                /** Constructor.
                  */
                PropertyList::PropertyList(void) : PropertySet(true) {
                }
                
                /** Destructor.
                  */
                PropertyList::~PropertyList(void) {
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // Accessors
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Copy the PropertyList and all of its contents.
                  * @return PropertySet::Ptr pointing to the new copy.
                  */
                PropertySet::Ptr PropertyList::deepCopy(void) const {
                    Ptr n(new PropertyList);
                    n->PropertySet::combine(this->PropertySet::deepCopy());
                    n->_order = _order;
                    n->_comments = _comments;
                    return n;
                }
                
                // The following throw an exception if the type does not match exactly.
                
                /** Get the last value for a property name (possibly hierarchical).
                  * Note that the type must be explicitly specified for this template:
                  * @code int i = propertyList.get<int>("foo") @endcode
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Last value set or added.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#ee2a91c6">ee2a91c6</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
88   <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Value does not match desired type.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
88   <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value does not match desired type.</div>
                  */
                template <typename T>
                T PropertyList::get(string const& name) const { /* parasoft-suppress LsstDm-3-4a LsstDm-4-6 "allow template over bool" */
                    return PropertySet::get<T>(name);
                }
                
                /** Get the last value for a property name (possibly hierarchical).
                  * Returns the provided @a defaultValue if the property does not exist.
                  * Note that the type must be explicitly specified for this template:
                  * @code int i = propertyList.get<int>("foo", 42) @endcode
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @param[in] defaultValue Default value to return if property does not exist.
                  * @return Last value set or added.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
102  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Value does not match desired type.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
102  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value does not match desired type.</div>
                  */
                template <typename T>
                T PropertyList::get(string const& name, T const& defaultValue) const { /* parasoft-suppress LsstDm-3-4a LsstDm-4-6 "allow template over bool" */
                    return PropertySet::get<T>(name, defaultValue);
                }
                
                /** Get the vector of values for a property name (possibly hierarchical).
                  * Note that the type must be explicitly specified for this template:
                  * @code vector<int> v = propertyList.getArray<int>("foo") @endcode
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Vector of values.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Value does not match desired type.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Value does not match desired type.</div>
                  */
                template <typename T>
                vector<T> PropertyList::getArray(string const& name) const {
                    return PropertySet::getArray<T>(name);
                }
                
                
                /** Get the comment for a string property name (possibly hierarchical).
                  * @param[in] name Property name to examine, possibly hierarchical.
                  * @return Comment string.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
126  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws NotFoundException Property does not exist.</div>
              ?                      ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
126  <a href="#25738fd8">25738fd8</a> +   * @throws NotFoundError Property does not exist.</div>
              ?                      ^^ ^
                  */
                std::string const& PropertyList::getComment(
                    std::string const& name) const {
                    return _comments.find(name)->second;
                }
                
                std::vector<std::string> PropertyList::getOrderedNames(void) const {
                    std::vector<std::string> v;
                    for (std::list<std::string>::const_iterator i = _order.begin();
                         i != _order.end(); ++i) {
                        v.push_back(*i);
                    }
                    return v;
                }
                
                std::list<std::string>::const_iterator
                PropertyList::begin(void) const {
                    return _order.begin();
                }
                
                std::list<std::string>::const_iterator
                PropertyList::end(void) const {
                    return _order.end();
                }
                
                /** Generate a string representation of the PropertyList.
                  * Use this for debugging, not for serialization/persistence.
                  * @param[in] topLevelOnly false (default) = do include subproperties.
                  * @param[in] indent String to indent lines by (default none).
                  * @return String representation of the PropertyList.
                  */
                std::string PropertyList::toString(bool topLevelOnly,
                                                           std::string const& indent) const {
                    ostringstream s;
                    for (std::list<std::string>::const_iterator i = _order.begin();
                         i != _order.end(); ++i) {
                        s << _format(*i);
                        std::string const& comment = _comments.find(*i)->second;
                        if (comment.size()) {
                            s << "// " << comment << std::endl;
                        }
                    }
                    return s.str();
                }
                
                
                ///////////////////////////////////////////////////////////////////////////////
                // Modifiers
                ///////////////////////////////////////////////////////////////////////////////
                
                ///////////////////////////////////////////////////////////////////////////////
                // Normal versions of set/add with placement control
                
                /** Replace all values for a property name (possibly hierarchical) with a new
                  * value.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Value to set.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
185  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
185  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void PropertyList::set(
                    std::string const& name, T const& value, bool inPlace) {
                    PropertySet::set(name, value);
                    if (!inPlace) {
                        _moveToEnd(name);
                    }
                }
                
                void PropertyList::set(
                    std::string const& name, PropertySet::Ptr const& value,
                    bool inPlace) {
                    Ptr pl = boost::dynamic_pointer_cast<PropertyList, PropertySet>(value);
                    PropertySet::set(name, value);
                    _comments.erase(name);
                    _order.remove(name);
                    vector<string> names = value->paramNames(false);
                    for (vector<string>::const_iterator i = names.begin();
                         i != names.end(); ++i) {
                        if (pl) {
                            _commentOrderFix(name + "." + *i, pl->getComment(*i), inPlace);
                        }
                        else if (inPlace) {
                            _moveToEnd(name + "." + *i);
                        }
                    }
                }
                
                /** Replace all values for a property name (possibly hierarchical) with a
                  * string value.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Character string (converted to \c std::string ).
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
220  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
220  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void PropertyList::set(
                    std::string const& name, char const* value, bool inPlace) {
                    set(name, string(value), inPlace);
                    if (!inPlace) {
                        _moveToEnd(name);
                    }
                }
                
                /** Replace all values for a property name (possibly hierarchical) with a
                  * vector of new values.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Vector of values to set.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
235  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
235  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void PropertyList::set(
                    std::string const& name, vector<T> const& value, bool inPlace) {
                    PropertySet::set(name, value);
                    if (!inPlace) {
                        _moveToEnd(name);
                    }
                }
                
                /** Appends a single value to the vector of values for a property name
                  * (possibly hierarchical).  Sets the value if the property does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value Value to append.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
251  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
251  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
252  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
252  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void PropertyList::add(
                    std::string const& name, T const& value, bool inPlace) {
                    PropertySet::add(name, value);
                    if (!inPlace) {
                        _moveToEnd(name);
                    }
                }
                
                /** Appends a <tt>char const*</tt> value to the vector of values for a
                  * property name (possibly hierarchical).  Sets the value if the property
                  * does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value Value to append.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
269  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
269  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
270  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
270  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void PropertyList::add(
                    std::string const& name, char const* value, bool inPlace) {
                    add(name, string(value), inPlace);
                }
                
                /** Appends a vector of values to the vector of values for a property name
                  * (possibly hierarchical).  Sets the values if the property does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value Vector of values to append.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
282  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
282  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
283  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
283  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  * @note
                  * May only partially add the vector if an exception occurs.
                  */
                template <typename T>
                void PropertyList::add(
                    std::string const& name, vector<T> const& value, bool inPlace) {
                    PropertySet::add(name, value);
                    if (!inPlace) {
                        _moveToEnd(name);
                    }
                }
                
                
                ///////////////////////////////////////////////////////////////////////////////
                // Commented versions of set/add
                
                /** Replace all values for a property name (possibly hierarchical) with a new
                  * value.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Value to set.
                  * @param[in] comment Comment to set.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
306  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
306  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void PropertyList::set(
                    std::string const& name, T const& value,
                    std::string const& comment, bool inPlace) {
                    PropertySet::set(name, value);
                    _commentOrderFix(name, comment, inPlace);
                }
                
                /** Replace all values for a property name (possibly hierarchical) with a
                  * string value.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Character string value to set.
                  * @param[in] comment Comment to set.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
322  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
322  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void PropertyList::set(
                    std::string const& name, char const* value,
                    std::string const& comment, bool inPlace) {
                    set(name, string(value), comment, inPlace);
                }
                
                /** Replace all values for a property name (possibly hierarchical) with a
                  * vector of new values.
                  * @param[in] name Property name to set, possibly hierarchical.
                  * @param[in] value Vector of values to set.
                  * @param[in] comment Comment to set.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
336  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
336  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void PropertyList::set(
                    std::string const& name, vector<T> const& value,
                    std::string const& comment, bool inPlace) {
                    PropertySet::set(name, value);
                    _commentOrderFix(name, comment, inPlace);
                }
                
                /** Appends a single value to the vector of values for a property name
                  * (possibly hierarchical).  Sets the value if the property does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value Value to append.
                  * @param[in] comment Comment to set.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
352  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
352  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
353  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
353  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                template <typename T>
                void PropertyList::add(
                    std::string const& name, T const& value,
                    std::string const& comment, bool inPlace) {
                    PropertySet::add(name, value);
                    _commentOrderFix(name, comment, inPlace);
                }
                
                /** Appends a <tt>char const*</tt> value to the vector of values for a
                  * property name (possibly hierarchical).  Sets the value if the property
                  * does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value String value to append.
                  * @param[in] comment Comment to set.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
370  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
370  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
371  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
371  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                
                void PropertyList::add(
                    std::string const& name, char const* value,
                    std::string const& comment, bool inPlace) {
                    add(name, string(value), comment, inPlace);
                }
                
                /** Appends a vector of values to the vector of values for a property name
                  * (possibly hierarchical).  Sets the values if the property does not exist.
                  * @param[in] name Property name to append to, possibly hierarchical.
                  * @param[in] value Vector of values to append.
                  * @param[in] comment Comment to set.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
386  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
386  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
387  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
387  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  * @note
                  * May only partially add the vector if an exception occurs.
                  */
                template <typename T>
                void PropertyList::add(
                    std::string const& name, vector<T> const& value,
                    std::string const& comment, bool inPlace) {
                    PropertySet::add(name, value);
                    _commentOrderFix(name, comment, inPlace);
                }
                
                
                ///////////////////////////////////////////////////////////////////////////////
                // Other modifiers
                
                /** Replaces a single value vector in the destination with one from the
                  * \a source.
                  * @param[in] dest Destination property name.
                  * @param[in] source PropertySet::Ptr for the source PropertySet.
                  * @param[in] name Property name to extract.
                  * @param[in] inPlace If false, property is moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
409  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
409  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
410  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Name does not exist in source.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
410  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Name does not exist in source.</div>
              ?                              ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
411  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
411  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  */
                void PropertyList::copy(
                    std::string const& dest, PropertySet::ConstPtr source,
                    std::string const& name, bool inPlace) {
                    PropertySet::copy(dest, source, name);
                    ConstPtr pl =
                        boost::dynamic_pointer_cast<PropertyList const, PropertySet const>(
                            source);
                    if (pl) {
                        _comments[name] = pl->_comments.find(name)->second;
                        if (!inPlace) {
                            _moveToEnd(name);
                        }
                    }
                }
                
                /** Appends all value vectors from the \a source to their corresponding
                  * properties.  Sets values if a property does not exist.
                  * @param[in] source PropertySet::Ptr for the source PropertySet.
                  * @param[in] inPlace If false, existing properties are moved to end of list.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
432  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws TypeMismatchException Type does not match existing values.</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
432  <a href="#25738fd8">25738fd8</a> +   * @throws TypeError Type does not match existing values.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
433  <a href="#ee2a91c6">ee2a91c6</a> -   * @throws InvalidParameterException Hierarchical name uses non-PropertySet.</div>
              ?                              ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
433  <a href="#25738fd8">25738fd8</a> +   * @throws InvalidParameterError Hierarchical name uses non-PropertySet.</div>
              ?                              ^^ ^
                  * @note
                  * May only partially combine the PropertySets if an exception occurs.
                  */
                void PropertyList::combine(PropertySet::ConstPtr source,
                                                    bool inPlace) {
                    ConstPtr pl =
                        boost::dynamic_pointer_cast<PropertyList const, PropertySet const>(
                            source);
                    std::list<std::string> newOrder;
                    if (pl) {
                        newOrder = _order;
                        for (std::list<std::string>::const_iterator i = pl->begin();
                             i != pl->end(); ++i) {
                            bool present = _comments.find(*i) != _comments.end();
                            if (!present) {
                                newOrder.push_back(*i);
                            }
                            else if (!inPlace) {
                                newOrder.remove(*i);
                                newOrder.push_back(*i);
                            }
                        }
                    }
                    PropertySet::combine(source);
                    if (pl) {
                        _order = newOrder;
                        for (std::list<std::string>::const_iterator i = pl->begin();
                             i != pl->end(); ++i) {
                            _comments[*i] = pl->_comments.find(*i)->second;
                        }
                    }
                }
                
                /** Removes all values for a property name (possibly hierarchical).  Does
                  * nothing if the property does not exist.
                  * @param[in] name Property name to remove, possibly hierarchical.
                  */
                void PropertyList::remove(std::string const& name) {
                    PropertySet::remove(name);
                    _comments.erase(name);
                    _order.remove(name);
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // Private member functions
                ///////////////////////////////////////////////////////////////////////////////
                
                void PropertyList::_set(std::string const& name,
                          boost::shared_ptr< std::vector<boost::any> > vp) {
                    PropertySet::_set(name, vp);
                    if (_comments.find(name) == _comments.end()) {
                        _comments.insert(std::make_pair(name, std::string()));
                        _order.push_back(name);
                    }
                }
                
                void PropertyList::_moveToEnd(std::string const& name) {
                    _order.remove(name);
                    _order.push_back(name);
                }
                
                void PropertyList::_commentOrderFix(
                    std::string const& name, std::string const& comment, bool inPlace) {
                    _comments[name] = comment;
                    if (!inPlace) {
                        _moveToEnd(name);
                    }
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // Explicit template instantiations
                ///////////////////////////////////////////////////////////////////////////////
                
                /// @cond
                // Explicit template instantiations are not well understood by doxygen.
                
                #define INSTANTIATE(t) \
                    template t PropertyList::get<t>(string const& name) const; \
                    template t PropertyList::get<t>(string const& name, t const& defaultValue) const; \
                    template vector<t> PropertyList::getArray<t>(string const& name) const; \
                    template void PropertyList::set<t>(string const& name, t const& value, bool inPlace); \
                    template void PropertyList::set<t>(string const& name, vector<t> const& value, bool inPlace); \
                    template void PropertyList::add<t>(string const& name, t const& value, bool inPlace); \
                    template void PropertyList::add<t>(string const& name, vector<t> const& value, bool inPlace); \
                    template void PropertyList::set<t>(string const& name, t const& value, string const& comment, bool inPlace); \
                    template void PropertyList::set<t>(string const& name, vector<t> const& value, string const& comment, bool inPlace); \
                    template void PropertyList::add<t>(string const& name, t const& value, string const& comment, bool inPlace); \
                    template void PropertyList::add<t>(string const& name, vector<t> const& value, string const& comment, bool inPlace); \
                    template void PropertyList::set<t>(string const& name, t const& value, char const* comment, bool inPlace); \
                    template void PropertyList::set<t>(string const& name, vector<t> const& value, char const* comment, bool inPlace); \
                    template void PropertyList::add<t>(string const& name, t const& value, char const* comment, bool inPlace); \
                    template void PropertyList::add<t>(string const& name, vector<t> const& value, char const* comment, bool inPlace);
                
                INSTANTIATE(bool)
                INSTANTIATE(char)
                INSTANTIATE(signed char)
                INSTANTIATE(unsigned char)
                INSTANTIATE(short)
                INSTANTIATE(unsigned short)
                INSTANTIATE(int)
                INSTANTIATE(unsigned int)
                INSTANTIATE(long)
                INSTANTIATE(unsigned long)
                INSTANTIATE(long long)
                INSTANTIATE(unsigned long long)
                INSTANTIATE(float)
                INSTANTIATE(double)
                INSTANTIATE(string)
                INSTANTIATE(Persistable::Ptr)
                INSTANTIATE(DateTime)
                
                /// @endcond
                
                } } } // namespace lsst::daf::base
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="ee2a91c6"/></a>ee2a91c6</h3>

<pre>
commit ee2a91c67a4aa6484cd323b788fc7813615051a6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Sat Nov 6 15:19:51 2010 +0000

    Merge from ticket #676 (order and comments for properties).
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_24"><a name="tests/citizen.cc"/></a>tests/citizen.cc</h1>

<h3 id="toc_25">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                #include <iostream>
                #include <stdexcept>
                
                #include <boost/format.hpp>
                #include <boost/shared_ptr.hpp>
                #include <boost/scoped_ptr.hpp>
                #include "lsst/pex/exceptions.h"
                #include "lsst/daf/base/Citizen.h"
                
                class Shoe : public lsst::daf::base::Citizen {
                public:
                    Shoe(int i = 0) : Citizen(typeid(this)), _i(i) { }
                    ~Shoe() { }
                private:
                    int _i;
                };
                
                class MyClass : public lsst::daf::base::Citizen {
                  public:
                    MyClass(const char * = 0) :
                        Citizen(typeid(this)),
                        ptr(new int) {
                        *ptr = 0;
                    }
                    int add_one() { return ++*ptr; }
                private:
                    boost::scoped_ptr<int> ptr;         // no need to track this alloc
                };
                
                using namespace lsst::daf::base;
                
                /************************************************************************************************************/
                
                #define BOOST_TEST_MODULE Citizen
                #define BOOST_TEST_DYN_LINK
                #pragma clang diagnostic push
                #pragma clang diagnostic ignored "-Wunused-variable"
                #include "boost/test/unit_test.hpp"
                #pragma clang diagnostic pop
                
                BOOST_AUTO_TEST_SUITE(CitizenSuite)
                
                MyClass *foo() {
                    boost::scoped_ptr<Shoe> x(new Shoe(1));
                    MyClass *my_instance = new MyClass();
                
                    BOOST_CHECK_EQUAL(Citizen::census(0), 5);
                
                    return my_instance;
                }
                
                BOOST_AUTO_TEST_CASE(all) {
                    Citizen::setNewCallbackId(2);
                    Citizen::setDeleteCallbackId(2);
                
                    Shoe x;
                    const Citizen::memId firstId = Citizen::getNextMemId(); // after allocating x
                    
                    boost::scoped_ptr<Shoe> y(new Shoe);
                    boost::scoped_ptr<Shoe> z(new Shoe(10));
                    
                    MyClass *mine = foo();
                
                    boost::scoped_ptr<const std::vector<const Citizen *> > leaks(Citizen::census());
                    BOOST_CHECK_EQUAL(leaks->end() - leaks->begin(), 4);
                    BOOST_CHECK_EQUAL(Citizen::census(0), 4);
                    BOOST_CHECK_EQUAL(Citizen::census(0, firstId), 3);
                
                    x.markPersistent();                 // x isn't going to be deleted until main exists, so don't list as a leak
                    BOOST_CHECK_EQUAL(Citizen::census(0, firstId), 3);
                
                    z.reset();                          // i.e. delete pointed-to object
                    delete mine;
                
                #if 0                                   // can crash the program.  Drat.
                    ((int *)y.get())[0] = 0;            // deliberately corrupt the block
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
99   <a href="#e214190f">e214190f</a> -     BOOST_CHECK_THROW((void)Citizen::checkCorruption(), lsst::pex::exceptions::MemoryException);</div>
              ?                                                                                       ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
99   <a href="#25738fd8">25738fd8</a> +     BOOST_CHECK_THROW((void)Citizen::checkCorruption(), lsst::pex::exceptions::MemoryError);</div>
              ?                                                                                       ^^ ^
                    ((int *)y.get())[0] = 0xdeadbeef;   // uncorrupt the block
                #endif
                
                    y.reset();
                    Citizen::census(std::cout, firstId);
                    BOOST_CHECK_EQUAL(Citizen::census(0, firstId), 0);
                }
                
                BOOST_AUTO_TEST_SUITE_END()
                
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="e214190f"/></a>e214190f</h3>

<pre>
commit e214190feeafcb50bb8a36a5f83f8ffba13ec6e4
Author: rhl <rhl@git.lsstcorp.org>
Date:   Fri Jan 9 21:34:48 2009 +0000

    1/ Reinstate throw in case of memory corruption
    2/ Copy citizen.cc from examples to tests and fix -- the original test
    case was correct; it only seemed to start failing as Jeff Bartels
    had removed the throw (see 1)
    3/ Don't run the examples as part of the build
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_26"><a name="tests/dateTime_1.cc"/></a>tests/dateTime_1.cc</h1>

<h3 id="toc_27">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                #include "lsst/daf/base/DateTime.h"
                
                #define BOOST_TEST_MODULE DateTime_1
                #define BOOST_TEST_DYN_LINK
                #pragma clang diagnostic push
                #pragma clang diagnostic ignored "-Wunused-variable"
                #include "boost/test/unit_test.hpp"
                #pragma clang diagnostic pop
                
                #include "lsst/pex/exceptions.h"
                
                namespace test = boost::test_tools;
                using lsst::daf::base::DateTime;
                
                BOOST_AUTO_TEST_SUITE(DateTimeSuite)
                
                BOOST_AUTO_TEST_CASE(Gmtime) {
                    DateTime dt("20090402T072639.314159265Z");
                    struct tm t(dt.gmtime());
                    BOOST_CHECK_EQUAL(t.tm_sec, 39);
                    BOOST_CHECK_EQUAL(t.tm_min, 26);
                    BOOST_CHECK_EQUAL(t.tm_hour, 7);
                    BOOST_CHECK_EQUAL(t.tm_mday, 2);
                    BOOST_CHECK_EQUAL(t.tm_mon, 4 - 1);
                    BOOST_CHECK_EQUAL(t.tm_year, 2009 - 1900);
                    BOOST_CHECK_EQUAL(t.tm_wday, 4);
                    BOOST_CHECK_EQUAL(t.tm_yday, 31 + 28 + 31 + 2 - 1);
                    BOOST_CHECK_EQUAL(t.tm_isdst, 0);
                }
                
                BOOST_AUTO_TEST_CASE(Timespec) {
                    DateTime dt("20090402T072639.314159265Z");
                    struct timespec ts(dt.timespec());
                    BOOST_CHECK_EQUAL(ts.tv_sec, 1238657199);
                    BOOST_CHECK_EQUAL(ts.tv_nsec, 314159265);
                }
                
                BOOST_AUTO_TEST_CASE(Timeval) {
                    DateTime dt("20090402T072639.314159265Z");
                    struct timeval tv(dt.timeval());
                    BOOST_CHECK_EQUAL(tv.tv_sec, 1238657199);
                    BOOST_CHECK_EQUAL(tv.tv_usec, 314159);
                }
                
                BOOST_AUTO_TEST_CASE(Throw) {
                    // 
                #if 0
                    // Date too far in the future
                    BOOST_CHECK_THROW(DateTime(40587.0 + 106752.0),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
72   <a href="#cff8d7ad">cff8d7ad</a> -                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                         ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
72   <a href="#25738fd8">25738fd8</a> +                       lsst::pex::exceptions::DomainError);</div>
                    // Date too far in the past
                    BOOST_CHECK_THROW(DateTime(40587.0 - 106752.0),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
75   <a href="#cff8d7ad">cff8d7ad</a> -                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                         ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
75   <a href="#25738fd8">25738fd8</a> +                       lsst::pex::exceptions::DomainError);</div>
                #endif
                    // Date before UTC->TAI conversion is valid
                    BOOST_CHECK_THROW(DateTime(-500000000 * 1000000000LL, DateTime::UTC),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
79   <a href="#cff8d7ad">cff8d7ad</a> -                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                         ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
79   <a href="#25738fd8">25738fd8</a> +                       lsst::pex::exceptions::DomainError);</div>
                    // Date before UTC->TAI conversion is valid and too far in the past for
                    // 32-bit Unix mktime()
                    BOOST_CHECK_THROW(DateTime("1901-01-01T12:34:56Z"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
83   <a href="#cff8d7ad">cff8d7ad</a> -                       lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                         ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
83   <a href="#25738fd8">25738fd8</a> +                       lsst::pex::exceptions::DomainError);</div>
                    if (sizeof(time_t) == 4) {
                        // Date too far in the past for Unix mktime()
                        BOOST_CHECK_THROW(DateTime(1901, 1, 1, 12, 34, 56),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#5f9b5132">5f9b5132</a> -                           lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#25738fd8">25738fd8</a> +                           lsst::pex::exceptions::DomainError);</div>
                        // Date too far in the future for Unix mktime()
                        BOOST_CHECK_THROW(DateTime(2039, 1, 1, 12, 34, 56),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#5f9b5132">5f9b5132</a> -                           lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#25738fd8">25738fd8</a> +                           lsst::pex::exceptions::DomainError);</div>
                        BOOST_CHECK_THROW(DateTime("2039-01-01T12:34:56Z"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
92   <a href="#5f9b5132">5f9b5132</a> -                           lsst::pex::exceptions::DomainErrorException);</div>
              ?                                                             ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
92   <a href="#25738fd8">25738fd8</a> +                           lsst::pex::exceptions::DomainError);</div>
                    }
                
                }
                
                BOOST_AUTO_TEST_SUITE_END()
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="cff8d7ad"/></a>cff8d7ad</h3>

<pre>
commit cff8d7ad5c5444d2e169e0bd01f821093447042c
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu May 7 00:48:05 2009 +0000

    Throw exceptions if parameters to DateTime constructors are out of valid ranges.  #800
</pre>
<h3><a name="5f9b5132"/></a>5f9b5132</h3>

<pre>
commit 5f9b513226e7b857dc709316ead9bb29bec8d3c5
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Mon May 18 18:30:56 2009 +0000

    64-bit machines can process wild dates that 32-bit machines cannot.
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_28"><a name="tests/PropertySet_1.cc"/></a>tests/PropertySet_1.cc</h1>

<h3 id="toc_29">Diff:</h3>

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                #include "lsst/daf/base/PropertySet.h"
                
                #define BOOST_TEST_MODULE PropertySet_1
                #define BOOST_TEST_DYN_LINK
                #pragma clang diagnostic push
                #pragma clang diagnostic ignored "-Wunused-variable"
                #include "boost/test/unit_test.hpp"
                #pragma clang diagnostic pop
                
                #include <algorithm>
                
                #include "lsst/pex/exceptions/Runtime.h"
                
                #define INT64CONST(x) static_cast<int64_t>(x ## LL)
                
                namespace test = boost::test_tools;
                namespace dafBase = lsst::daf::base;
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
40   <a href="#86425aff">86425aff</a> + namespace pexExcept = lsst::pex::exceptions;</div>
                
                BOOST_AUTO_TEST_SUITE(PropertySetSuite) /* parasoft-suppress LsstDm-3-2a LsstDm-3-6a LsstDm-4-6 "Boost test harness macros" */
                
                BOOST_AUTO_TEST_CASE(construct) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    BOOST_CHECK_EQUAL(!psp, false);
                }
                
                BOOST_AUTO_TEST_CASE(bases) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    boost::shared_ptr<dafBase::Persistable> pp =
                        boost::dynamic_pointer_cast<dafBase::Persistable, dafBase::PropertySet>(psp);
                    BOOST_CHECK_EQUAL(!pp, false);
                    boost::shared_ptr<dafBase::Citizen> cp =
                        boost::dynamic_pointer_cast<dafBase::Citizen, dafBase::PropertySet>(psp);
                    BOOST_CHECK_EQUAL(!cp, false);
                }
                
                BOOST_AUTO_TEST_CASE(getScalar) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("bool", true);
                    ps.set("char", '*');
                    short s = 42;
                    ps.set("short", s);
                    ps.set("int", 2008);
                    ps.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    ps.set("float", f);
                    double d = 2.718281828459045;
                    ps.set("double", d);
                    ps.set<std::string>("char*", "foo");
                    ps.set("char*2", "foo2");
                    ps.set("string", std::string("bar"));
                
                    BOOST_CHECK_EQUAL(ps.get<bool>("bool"), true);
                    BOOST_CHECK_EQUAL(ps.get<char>("char"), '*');
                    BOOST_CHECK_EQUAL(ps.get<short>("short"), 42);
                    BOOST_CHECK_EQUAL(ps.get<int>("int"), 2008);
                    BOOST_CHECK_EQUAL(ps.get<int64_t>("int64_t"), INT64CONST(0xfeeddeadbeef));
                    BOOST_CHECK_EQUAL(ps.get<float>("float"), 3.14159f);
                    BOOST_CHECK_EQUAL(ps.get<double>("double"), 2.718281828459045);
                    BOOST_CHECK_EQUAL(ps.get<std::string>("char*"), "foo");
                    BOOST_CHECK_EQUAL(ps.get<std::string>("char*2"), "foo2");
                    BOOST_CHECK_EQUAL(ps.get<std::string>("string"), "bar");
                }
                
                BOOST_AUTO_TEST_CASE(resetScalar) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("bool", true);
                    ps.set("char", '*');
                    short s = 42;
                    ps.set("short", s);
                    ps.set("int", 2008);
                    ps.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    ps.set("float", f);
                    double d = 2.718281828459045;
                    ps.set("double", d);
                    ps.set<std::string>("char*", "foo");
                    ps.set("char*2", "foo2");
                    ps.set("string", std::string("bar"));
                
                    BOOST_CHECK_EQUAL(ps.get<bool>("bool"), true);
                    BOOST_CHECK_EQUAL(ps.get<char>("char"), '*');
                    BOOST_CHECK_EQUAL(ps.get<short>("short"), 42);
                    BOOST_CHECK_EQUAL(ps.get<int>("int"), 2008);
                    BOOST_CHECK_EQUAL(ps.get<int64_t>("int64_t"), INT64CONST(0xfeeddeadbeef));
                    BOOST_CHECK_EQUAL(ps.get<float>("float"), 3.14159f);
                    BOOST_CHECK_EQUAL(ps.get<double>("double"), 2.718281828459045);
                    BOOST_CHECK_EQUAL(ps.get<std::string>("char*"), "foo");
                    BOOST_CHECK_EQUAL(ps.get<std::string>("char*2"), "foo2");
                    BOOST_CHECK_EQUAL(ps.get<std::string>("string"), "bar");
                
                    ps.set("bool", false);
                    ps.set("char", '%');
                    s = 2008;
                    ps.set("short", s);
                    ps.set("int", 42);
                    ps.set("int64_t", INT64CONST(0xcafefacade));
                    f = 2.71828;
                    ps.set("float", f);
                    d = 3.1415926535897932;
                    ps.set("double", d);
                    ps.set<std::string>("char*", "baz");
                    ps.set("char*2", "random2");
                    ps.set("string", std::string("xyzzy"));
                
                    BOOST_CHECK_EQUAL(ps.get<bool>("bool"), false);
                    BOOST_CHECK_EQUAL(ps.get<char>("char"), '%');
                    BOOST_CHECK_EQUAL(ps.get<short>("short"), 2008);
                    BOOST_CHECK_EQUAL(ps.get<int>("int"), 42);
                    BOOST_CHECK_EQUAL(ps.get<int64_t>("int64_t"), INT64CONST(0xcafefacade));
                    BOOST_CHECK_EQUAL(ps.get<float>("float"), 2.71828f);
                    BOOST_CHECK_EQUAL(ps.get<double>("double"), 3.1415926535897932);
                    BOOST_CHECK_EQUAL(ps.get<std::string>("char*"), "baz");
                    BOOST_CHECK_EQUAL(ps.get<std::string>("char*2"), "random2");
                    BOOST_CHECK_EQUAL(ps.get<std::string>("string"), "xyzzy");
                }
                
                BOOST_AUTO_TEST_CASE(getDefault) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("int", 42);
                
                    BOOST_CHECK_EQUAL(ps.get<int>("int"), 42);
                    BOOST_CHECK_EQUAL(ps.get<int>("int", 2008), 42);
                    BOOST_CHECK_EQUAL(ps.get<int>("foo", 2008), 2008);
                }
                
                BOOST_AUTO_TEST_CASE(exists) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("int", 42);
                    BOOST_CHECK_EQUAL(ps.exists("int"), true);
                    BOOST_CHECK_EQUAL(ps.exists("foo"), false);
                }
                
                BOOST_AUTO_TEST_CASE(getScalarThrow) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("bool", true);
                    short s = 42;
                    ps.set("short", s);
                    ps.set("int", 2008);
                    ps.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    ps.set("float", f);
                    double d = 2.718281828459045;
                    ps.set("double", d);
                    ps.set<std::string>("char*", "foo");
                    ps.set("char*2", "foo2");
                    ps.set("string", std::string("bar"));
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
171  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<bool>("short"), dafBase::TypeMismatchException);</div>
              ?                                              ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
172  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<bool>("short"), pexExcept::TypeError);</div>
              ?                                              ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
172  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<bool>("int"), dafBase::TypeMismatchException);</div>
              ?                                            ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
173  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<bool>("int"), pexExcept::TypeError);</div>
              ?                                            ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
173  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<short>("int"), dafBase::TypeMismatchException);</div>
              ?                                             ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
174  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<short>("int"), pexExcept::TypeError);</div>
              ?                                             ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
174  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<int>("short"), dafBase::TypeMismatchException);</div>
              ?                                             ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
175  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<int>("short"), pexExcept::TypeError);</div>
              ?                                             ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
175  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<int>("bool"), dafBase::TypeMismatchException);</div>
              ?                                            ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
176  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<int>("bool"), pexExcept::TypeError);</div>
              ?                                            ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
176  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<unsigned int>("int"), dafBase::TypeMismatchException);</div>
              ?                                                    ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
177  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<unsigned int>("int"), pexExcept::TypeError);</div>
              ?                                                    ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
177  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<double>("float"), dafBase::TypeMismatchException);</div>
              ?                                                ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
178  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<double>("float"), pexExcept::TypeError);</div>
              ?                                                ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
178  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<float>("double"), dafBase::TypeMismatchException);</div>
              ?                                                ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
179  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<float>("double"), pexExcept::TypeError);</div>
              ?                                                ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
179  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<std::string>("int"), dafBase::TypeMismatchException);</div>
              ?                                                   ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
180  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<std::string>("int"), pexExcept::TypeError);</div>
              ?                                                   ^ +++++++       ^^ ^
                }
                
                BOOST_AUTO_TEST_CASE(getVector) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    std::vector<int> v;
                    v.push_back(42);
                    v.push_back(2008);
                    v.push_back(1);
                    ps.set("ints", v);
                
                    std::vector<int> w = ps.getArray<int>("ints");
                    BOOST_CHECK_EQUAL(w.size(), 3U);
                    for (int i = 0; i < 3; ++i) {
                        BOOST_CHECK_EQUAL(v[i], w[i]);
                    }
                }
                
                BOOST_AUTO_TEST_CASE(addScalar) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    std::vector<int> v;
                    v.push_back(42);
                    v.push_back(2008);
                    v.push_back(1);
                    ps.set("ints", v);
                    ps.add("ints", -999);
                    ps.add("other", "foo");
                
                    std::vector<int> w = ps.getArray<int>("ints");
                    BOOST_CHECK_EQUAL(w.size(), 4U);
                    for (int i = 0; i < 3; ++i) {
                        BOOST_CHECK_EQUAL(v[i], w[i]);
                    }
                    BOOST_CHECK_EQUAL(w[3], -999);
                    BOOST_CHECK_EQUAL(ps.get<std::string>("other"), "foo");
                }
                
                BOOST_AUTO_TEST_CASE(addVector) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    std::vector<int> v;
                    v.push_back(42);
                    v.push_back(2008);
                    v.push_back(1);
                    ps.set("ints", v);
                
                    std::vector<int> vv;
                    vv.push_back(-42);
                    vv.push_back(-2008);
                    vv.push_back(-1);
                    ps.add("ints", vv);
                
                    std::vector<int> w = ps.getArray<int>("ints");
                    BOOST_CHECK_EQUAL(w.size(), 6U);
                    for (int i = 0; i < 3; ++i) {
                        BOOST_CHECK_EQUAL(v[i], w[i]);
                        BOOST_CHECK_EQUAL(vv[i], w[i + 3]);
                    }
                }
                
                BOOST_AUTO_TEST_CASE(typeOf) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("bool", true);
                    ps.set("char", '*');
                    short s = 42;
                    ps.set("short", s);
                    ps.set("int", 2008);
                    ps.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    ps.set("float", f);
                    double d = 2.718281828459045;
                    ps.set("double", d);
                    ps.set("char*", "foo");
                    ps.set("string", std::string("bar"));
                
                    BOOST_CHECK(ps.typeOf("bool") == typeid(bool));
                    BOOST_CHECK(ps.typeOf("char") == typeid(char));
                    BOOST_CHECK(ps.typeOf("short") == typeid(short));
                    BOOST_CHECK(ps.typeOf("int") == typeid(int));
                    BOOST_CHECK(ps.typeOf("int64_t") == typeid(int64_t));
                    BOOST_CHECK(ps.typeOf("float") == typeid(float));
                    BOOST_CHECK(ps.typeOf("double") == typeid(double));
                    BOOST_CHECK(ps.typeOf("char*") == typeid(std::string));
                    BOOST_CHECK(ps.typeOf("string") == typeid(std::string));
                }
                
                BOOST_AUTO_TEST_CASE(arrayProperties) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    std::vector<int> v;
                    v.push_back(42);
                    v.push_back(2008);
                    v.push_back(1);
                    ps.set("ints", v);
                    ps.set("int", 365);
                    ps.set("ints2", -42);
                    ps.add("ints2", -2008);
                
                    BOOST_CHECK_EQUAL(ps.isArray("ints"), true);
                    BOOST_CHECK_EQUAL(ps.isArray("int"), false);
                    BOOST_CHECK_EQUAL(ps.isArray("ints2"), true);
                    BOOST_CHECK_EQUAL(ps.valueCount("ints"), 3U);
                    BOOST_CHECK_EQUAL(ps.valueCount("int"), 1U);
                    BOOST_CHECK_EQUAL(ps.valueCount("ints2"), 2U);
                    BOOST_CHECK(ps.typeOf("ints") == typeid(int));
                    BOOST_CHECK(ps.typeOf("int") == typeid(int));
                    BOOST_CHECK(ps.typeOf("ints2") == typeid(int));
                }
                
                BOOST_AUTO_TEST_CASE(hierarchy) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                
                    psp->set("pre", 1);
                    ps.set("ps1", psp);
                    psp->set("post", 2);
                    ps.set("int", 42);
                    ps.set("ps2", dafBase::PropertySet::Ptr(new dafBase::PropertySet));
                    ps.get<dafBase::PropertySet::Ptr>("ps2")->set("plus", 10.24);
                    ps.set("ps2.minus", -10.24);
                    ps.set("ps3.sub1", "foo");
                    ps.set("ps3.sub2", "bar");
                
                    BOOST_CHECK(ps.exists("ps1"));
                    BOOST_CHECK(ps.exists("ps2"));
                    BOOST_CHECK(ps.exists("ps3"));
                    BOOST_CHECK(ps.exists("ps1.pre"));
                    BOOST_CHECK(ps.exists("ps1.post"));
                    BOOST_CHECK(ps.exists("ps2.plus"));
                    BOOST_CHECK(ps.exists("ps2.minus"));
                    BOOST_CHECK(ps.exists("ps3.sub1"));
                    BOOST_CHECK(ps.exists("ps3.sub2"));
                
                    BOOST_CHECK(ps.isPropertySetPtr("ps1"));
                    BOOST_CHECK(ps.isPropertySetPtr("ps2"));
                    BOOST_CHECK(ps.isPropertySetPtr("ps3"));
                    BOOST_CHECK(!ps.isPropertySetPtr("int"));
                    BOOST_CHECK(!ps.isPropertySetPtr("ps1.pre"));
                    BOOST_CHECK(!ps.isPropertySetPtr("ps1.post"));
                    BOOST_CHECK(!ps.isPropertySetPtr("ps2.plus"));
                    BOOST_CHECK(!ps.isPropertySetPtr("ps2.minus"));
                    BOOST_CHECK(!ps.isPropertySetPtr("ps3.sub1"));
                    BOOST_CHECK(!ps.isPropertySetPtr("ps3.sub2"));
                
                    dafBase::PropertySet::Ptr psp1 = ps.get<dafBase::PropertySet::Ptr>("ps1");
                    dafBase::PropertySet::Ptr psp2 = ps.get<dafBase::PropertySet::Ptr>("ps2");
                    dafBase::PropertySet::Ptr psp3 = ps.get<dafBase::PropertySet::Ptr>("ps3");
                    BOOST_CHECK(psp1);
                    BOOST_CHECK(psp2);
                    BOOST_CHECK(psp3);
                    BOOST_CHECK(psp1 == psp);
                    BOOST_CHECK(psp1->exists("pre"));
                    BOOST_CHECK(psp1->exists("post"));
                    BOOST_CHECK(psp2->exists("plus"));
                    BOOST_CHECK(psp2->exists("minus"));
                    BOOST_CHECK(psp3->exists("sub1"));
                    BOOST_CHECK(psp3->exists("sub2"));
                    BOOST_CHECK_EQUAL(psp1->get<int>("pre"), 1);
                    BOOST_CHECK_EQUAL(psp1->get<int>("post"), 2);
                    BOOST_CHECK_EQUAL(psp2->get<double>("plus"), 10.24);
                    BOOST_CHECK_EQUAL(psp2->get<double>("minus"), -10.24);
                    BOOST_CHECK_EQUAL(psp3->get<std::string>("sub1"), "foo");
                    BOOST_CHECK_EQUAL(psp3->get<std::string>("sub2"), "bar");
                
                    // Make sure checking a subproperty doesn't create it.
                    BOOST_CHECK(!ps.exists("ps2.pre"));
                    BOOST_CHECK(!ps.exists("ps2.pre"));
                    // Make sure checking an element doesn't create it.
                    BOOST_CHECK(!ps.exists("ps4"));
                    BOOST_CHECK(!ps.exists("ps4"));
                    // Make sure checking a subproperty with a nonexistent parent doesn't
                    // create it.
                    BOOST_CHECK(!ps.exists("ps4.sub"));
                    BOOST_CHECK(!ps.exists("ps4.sub"));
                    // Make sure checking a subproperty doesn't create its parent.
                    BOOST_CHECK(!ps.exists("ps4"));
                }
                
                BOOST_AUTO_TEST_CASE(variousThrows) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("int", 42);
                    BOOST_CHECK_THROW(ps.set("int.sub", "foo"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
359  <a href="#5684f115">5684f115</a> -                       lsst::pex::exceptions::InvalidParameterException);</div>
              ?                       ------   ^^^     ----                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
360  <a href="#86425aff">86425aff</a> +                       pexExcept::InvalidParameterError);</div>
              ?                          ^                        ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
360  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.get<double>("int"), dafBase::TypeMismatchException);</div>
              ?                                              ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
361  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.get<double>("int"), pexExcept::TypeError);</div>
              ?                                              ^ +++++++       ^^ ^
                    BOOST_CHECK_THROW(ps.get<double>("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
362  <a href="#5684f115">5684f115</a> -                       lsst::pex::exceptions::NotFoundException);</div>
              ?                       ------   ^^^     ----           ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
363  <a href="#86425aff">86425aff</a> +                       pexExcept::NotFoundError);</div>
              ?                          ^                ^^ ^
                    BOOST_CHECK_THROW(ps.getArray<double>("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
364  <a href="#5684f115">5684f115</a> -                       lsst::pex::exceptions::NotFoundException);</div>
              ?                       ------   ^^^     ----           ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
365  <a href="#86425aff">86425aff</a> +                       pexExcept::NotFoundError);</div>
              ?                          ^                ^^ ^
                    BOOST_CHECK_THROW(ps.typeOf("double"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
366  <a href="#5684f115">5684f115</a> -                       lsst::pex::exceptions::NotFoundException);</div>
              ?                       ------   ^^^     ----           ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
367  <a href="#86425aff">86425aff</a> +                       pexExcept::NotFoundError);</div>
              ?                          ^                ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
367  <a href="#2715d452">2715d452</a> -     BOOST_CHECK_THROW(ps.add("int", 4.2), dafBase::TypeMismatchException);</div>
              ?                                           ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
368  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.add("int", 4.2), pexExcept::TypeError);</div>
              ?                                           ^ +++++++       ^^ ^
                    std::vector<double> v;
                    v.push_back(3.14159);
                    v.push_back(2.71828);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
371  <a href="#2715d452">2715d452</a> -     BOOST_CHECK_THROW(ps.add("int", v), dafBase::TypeMismatchException);</div>
              ?                                         ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
372  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.add("int", v), pexExcept::TypeError);</div>
              ?                                         ^ +++++++       ^^ ^
                    BOOST_CHECK_NO_THROW(ps.remove("foo.bar"));
                    BOOST_CHECK_NO_THROW(ps.remove("int.sub"));
                }
                
                BOOST_AUTO_TEST_CASE(names) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("ps1.pre", 1);
                    ps.set("ps1.post", 2);
                    ps.set("int", 42);
                    ps.set("double", 3.14);
                    ps.set("ps2.plus", 10.24);
                    ps.set("ps2.minus", -10.24);
                
                    BOOST_CHECK_EQUAL(ps.nameCount(), 4U);
                    BOOST_CHECK_EQUAL(ps.nameCount(false), 8U);
                
                    std::vector<std::string> v = ps.names();
                    BOOST_CHECK_EQUAL(v.size(), 4U);
                    std::sort(v.begin(), v.end());
                    BOOST_CHECK_EQUAL(v[0], "double");
                    BOOST_CHECK_EQUAL(v[1], "int");
                    BOOST_CHECK_EQUAL(v[2], "ps1");
                    BOOST_CHECK_EQUAL(v[3], "ps2");
                    v = ps.names(false);
                    BOOST_CHECK_EQUAL(v.size(), 8U);
                    std::sort(v.begin(), v.end());
                    BOOST_CHECK_EQUAL(v[0], "double");
                    BOOST_CHECK_EQUAL(v[1], "int");
                    BOOST_CHECK_EQUAL(v[2], "ps1");
                    BOOST_CHECK_EQUAL(v[3], "ps1.post");
                    BOOST_CHECK_EQUAL(v[4], "ps1.pre");
                    BOOST_CHECK_EQUAL(v[5], "ps2");
                    BOOST_CHECK_EQUAL(v[6], "ps2.minus");
                    BOOST_CHECK_EQUAL(v[7], "ps2.plus");
                }
                
                BOOST_AUTO_TEST_CASE(paramNames) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("ps1.pre", 1);
                    ps.set("ps1.post", 2);
                    ps.set("int", 42);
                    ps.set("double", 3.14);
                    ps.set("ps2.plus", 10.24);
                    ps.set("ps2.minus", -10.24);
                
                    std::vector<std::string> v = ps.paramNames();
                    BOOST_CHECK_EQUAL(v.size(), 2U);
                    std::sort(v.begin(), v.end());
                    BOOST_CHECK_EQUAL(v[0], "double");
                    BOOST_CHECK_EQUAL(v[1], "int");
                    v = ps.paramNames(false);
                    BOOST_CHECK_EQUAL(v.size(), 6U);
                    std::sort(v.begin(), v.end());
                    BOOST_CHECK_EQUAL(v[0], "double");
                    BOOST_CHECK_EQUAL(v[1], "int");
                    BOOST_CHECK_EQUAL(v[2], "ps1.post");
                    BOOST_CHECK_EQUAL(v[3], "ps1.pre");
                    BOOST_CHECK_EQUAL(v[4], "ps2.minus");
                    BOOST_CHECK_EQUAL(v[5], "ps2.plus");
                }
                
                BOOST_AUTO_TEST_CASE(propertySetNames) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("ps1.pre", 1);
                    ps.set("ps1.post", 2);
                    ps.set("int", 42);
                    ps.set("double", 3.14);
                    ps.set("ps2.plus", 10.24);
                    ps.set("ps2.minus", -10.24);
                    ps.set("ps3.sub.subsub", "foo");
                
                    std::vector<std::string> v = ps.propertySetNames();
                    BOOST_CHECK_EQUAL(v.size(), 3U);
                    std::sort(v.begin(), v.end());
                    BOOST_CHECK_EQUAL(v[0], "ps1");
                    BOOST_CHECK_EQUAL(v[1], "ps2");
                    BOOST_CHECK_EQUAL(v[2], "ps3");
                    v = ps.propertySetNames(false);
                    BOOST_CHECK_EQUAL(v.size(), 4U);
                    std::sort(v.begin(), v.end());
                    BOOST_CHECK_EQUAL(v[0], "ps1");
                    BOOST_CHECK_EQUAL(v[1], "ps2");
                    BOOST_CHECK_EQUAL(v[2], "ps3");
                    BOOST_CHECK_EQUAL(v[3], "ps3.sub");
                }
                
                BOOST_AUTO_TEST_CASE(getAs) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("bool", true);
                    ps.set("char", 'A');
                    short s = 42;
                    ps.set("short", s);
                    ps.set("int", 2008);
                    ps.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    ps.set("float", f);
                    double d = 2.718281828459045;
                    ps.set("double", d);
                    ps.set<std::string>("char*", "foo");
                    ps.set("char*2", "foo2");
                    ps.set("string", std::string("bar"));
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    psp->set("bottom", "x");
                    ps.set("top", psp);
                
                    BOOST_CHECK_EQUAL(ps.getAsBool("bool"), true);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
478  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.getAsBool("char"), dafBase::TypeMismatchException);</div>
              ?                                             ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
479  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.getAsBool("char"), pexExcept::TypeError);</div>
              ?                                             ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(ps.getAsInt("bool"), 1);
                    BOOST_CHECK_EQUAL(ps.getAsInt("char"), static_cast<int>('A'));
                    BOOST_CHECK_EQUAL(ps.getAsInt("short"), 42);
                    BOOST_CHECK_EQUAL(ps.getAsInt("int"), 2008);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
483  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.getAsInt("int64_t"), dafBase::TypeMismatchException);</div>
              ?                                               ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
484  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.getAsInt("int64_t"), pexExcept::TypeError);</div>
              ?                                               ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(ps.getAsInt64("bool"), INT64CONST(1));
                    BOOST_CHECK_EQUAL(ps.getAsInt64("char"), static_cast<int64_t>('A'));
                    BOOST_CHECK_EQUAL(ps.getAsInt64("short"), INT64CONST(42));
                    BOOST_CHECK_EQUAL(ps.getAsInt64("int"), INT64CONST(2008));
                    BOOST_CHECK_EQUAL(ps.getAsInt64("int64_t"), INT64CONST(0xfeeddeadbeef));
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
489  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.getAsInt64("float"), dafBase::TypeMismatchException);</div>
              ?                                               ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
490  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.getAsInt64("float"), pexExcept::TypeError);</div>
              ?                                               ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(ps.getAsDouble("bool"), 1.0);
                    BOOST_CHECK_EQUAL(ps.getAsDouble("char"), static_cast<double>('A'));
                    BOOST_CHECK_EQUAL(ps.getAsDouble("short"), 42.0);
                    BOOST_CHECK_EQUAL(ps.getAsDouble("int"), 2008.0);
                    BOOST_CHECK_EQUAL(ps.getAsDouble("int64_t"),
                                      static_cast<double>(INT64CONST(0xfeeddeadbeef)));
                    BOOST_CHECK_EQUAL(ps.getAsDouble("float"), 3.14159f);
                    BOOST_CHECK_EQUAL(ps.getAsDouble("double"), 2.718281828459045);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
498  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.getAsDouble("char*"), dafBase::TypeMismatchException);</div>
              ?                                                ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
499  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.getAsDouble("char*"), pexExcept::TypeError);</div>
              ?                                                ^ +++++++       ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
499  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.getAsString("char"), dafBase::TypeMismatchException);</div>
              ?                                               ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
500  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.getAsString("char"), pexExcept::TypeError);</div>
              ?                                               ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(ps.getAsString("char*"), "foo");
                    BOOST_CHECK_EQUAL(ps.getAsString("char*2"), "foo2");
                    BOOST_CHECK_EQUAL(ps.getAsString("string"), "bar");
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
503  <a href="#a494ae4a">a494ae4a</a> -     BOOST_CHECK_THROW(ps.getAsString("int"), dafBase::TypeMismatchException);</div>
              ?                                              ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
504  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.getAsString("int"), pexExcept::TypeError);</div>
              ?                                              ^ +++++++       ^^ ^
                    BOOST_CHECK_EQUAL(ps.getAsString("top.bottom"), "x");
                    BOOST_CHECK_EQUAL(ps.getAsPropertySetPtr("top"), psp);
                    BOOST_CHECK_THROW(ps.getAsPropertySetPtr("top.bottom"),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
507  <a href="#a494ae4a">a494ae4a</a> -                       dafBase::TypeMismatchException);</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
508  <a href="#86425aff">86425aff</a> +                       pexExcept::TypeError);</div>
                }
                
                BOOST_AUTO_TEST_CASE(combine) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("ps1.pre", 1);
                    ps.set("ps1.post", 2);
                    ps.set("int", 42);
                    ps.set("double", 3.14);
                    ps.set("ps2.plus", 10.24);
                    ps.set("ps2.minus", -10.24);
                    ps.set("ps3.sub.subsub", "foo");
                
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    psp->set("ps1.pre", 3);
                    psp->add("ps1.pre", 4);
                    psp->set("int", 2008);
                    psp->set("ps2.foo", "bar");
                    psp->set("ps4.top", "bottom");
                
                    ps.combine(psp);
                
                    BOOST_CHECK(ps.isPropertySetPtr("ps1"));
                    BOOST_CHECK(ps.isPropertySetPtr("ps2"));
                    BOOST_CHECK(ps.isPropertySetPtr("ps3"));
                    BOOST_CHECK(ps.isPropertySetPtr("ps3.sub"));
                    BOOST_CHECK(ps.isPropertySetPtr("ps4"));
                    BOOST_CHECK(!ps.isArray("ps1"));
                    BOOST_CHECK(ps.isArray("ps1.pre"));
                    BOOST_CHECK(!ps.isArray("ps1.post"));
                    BOOST_CHECK(!ps.isArray("ps2"));
                    BOOST_CHECK(!ps.isArray("ps2.plus"));
                    BOOST_CHECK(!ps.isArray("ps2.minus"));
                    BOOST_CHECK(!ps.isArray("ps2.foo"));
                    BOOST_CHECK(!ps.isArray("ps3"));
                    BOOST_CHECK(!ps.isArray("ps3.sub"));
                    BOOST_CHECK(!ps.isArray("ps3.subsub"));
                    BOOST_CHECK(!ps.isArray("ps4"));
                    BOOST_CHECK(!ps.isArray("ps4.top"));
                    BOOST_CHECK(ps.isArray("int"));
                    BOOST_CHECK(!ps.isArray("double"));
                    BOOST_CHECK_EQUAL(ps.valueCount("ps1.pre"), 3U);
                    BOOST_CHECK_EQUAL(ps.valueCount("int"), 2U);
                    std::vector<int> v = ps.getArray<int>("ps1.pre");
                    BOOST_CHECK_EQUAL(v[0], 1);
                    BOOST_CHECK_EQUAL(v[1], 3);
                    BOOST_CHECK_EQUAL(v[2], 4);
                    v = ps.getArray<int>("int");
                    BOOST_CHECK_EQUAL(v[0], 42);
                    BOOST_CHECK_EQUAL(v[1], 2008);
                }
                
                BOOST_AUTO_TEST_CASE(combineThrow) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("int", 42);
                
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    psp->set("int", 3.14159);
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
566  <a href="#2715d452">2715d452</a> -     BOOST_CHECK_THROW(ps.combine(psp), dafBase::TypeMismatchException);</div>
              ?                                        ^^^^^^       -------- ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
567  <a href="#86425aff">86425aff</a> +     BOOST_CHECK_THROW(ps.combine(psp), pexExcept::TypeError);</div>
              ?                                        ^ +++++++       ^^ ^
                }
                
                BOOST_AUTO_TEST_CASE(copy) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("ps1.pre", 1);
                    ps.set("ps1.post", 2);
                    ps.set("int", 42);
                    ps.set("double", 3.14);
                    ps.set("ps2.plus", 10.24);
                    ps.set("ps2.minus", -10.24);
                    ps.set("ps3.sub.subsub", "foo");
                
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    psp->set("ps1.pre", 3);
                    psp->add("ps1.pre", 4);
                    psp->set("int", 2008);
                    psp->set("ps2.foo", "bar");
                    psp->set("ps4.top", "bottom");
                
                    ps.copy("ps1", psp, "ps1");
                
                    BOOST_CHECK(ps.isPropertySetPtr("ps1"));
                    BOOST_CHECK(!ps.isArray("ps1"));
                    BOOST_CHECK(ps.isArray("ps1.pre"));
                    BOOST_CHECK(!ps.isArray("ps1.post"));
                    BOOST_CHECK_EQUAL(ps.valueCount("ps1.pre"), 2U);
                    std::vector<int> v = ps.getArray<int>("ps1.pre");
                    BOOST_CHECK_EQUAL(v[0], 3);
                    BOOST_CHECK_EQUAL(v[1], 4);
                
                    ps.copy("ps5", psp, "ps4");
                
                    BOOST_CHECK(ps.isPropertySetPtr("ps5"));
                    BOOST_CHECK(!ps.isArray("ps5"));
                    BOOST_CHECK(!ps.isArray("ps5.top"));
                }
                
                BOOST_AUTO_TEST_CASE(remove) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("int", 42);
                    ps.set("double", 3.14159);
                    ps.set("ps1.plus", 1);
                    ps.set("ps1.minus", -1);
                    ps.set("ps1.zero", 0);
                    BOOST_CHECK_EQUAL(ps.nameCount(false), 6U);
                
                    ps.remove("int");
                    BOOST_CHECK(!ps.exists("int"));
                    BOOST_CHECK_EQUAL(ps.getAsDouble("double"), 3.14159);
                    BOOST_CHECK_EQUAL(ps.getAsInt("ps1.plus"), 1);
                    BOOST_CHECK_EQUAL(ps.getAsInt("ps1.minus"), -1);
                    BOOST_CHECK_EQUAL(ps.getAsInt("ps1.zero"), 0);
                    BOOST_CHECK_EQUAL(ps.nameCount(false), 5U);
                
                    ps.remove("ps1.zero");
                    BOOST_CHECK(!ps.exists("int"));
                    BOOST_CHECK_EQUAL(ps.getAsDouble("double"), 3.14159);
                    BOOST_CHECK(!ps.exists("ps1.zero"));
                    BOOST_CHECK_EQUAL(ps.getAsInt("ps1.plus"), 1);
                    BOOST_CHECK_EQUAL(ps.getAsInt("ps1.minus"), -1);
                    BOOST_CHECK_EQUAL(ps.nameCount(false), 4U);
                
                    ps.remove("ps1");
                    BOOST_CHECK(!ps.exists("int"));
                    BOOST_CHECK_EQUAL(ps.getAsDouble("double"), 3.14159);
                    BOOST_CHECK(!ps.exists("ps1"));
                    BOOST_CHECK(!ps.exists("ps1.plus"));
                    BOOST_CHECK(!ps.exists("ps1.minus"));
                    BOOST_CHECK(!ps.exists("ps1.zero"));
                    BOOST_CHECK_EQUAL(ps.nameCount(false), 1U);
                
                    ps.remove("double");
                    BOOST_CHECK(!ps.exists("int"));
                    BOOST_CHECK(!ps.exists("double"));
                    BOOST_CHECK(!ps.exists("ps1"));
                    BOOST_CHECK(!ps.exists("ps1.plus"));
                    BOOST_CHECK(!ps.exists("ps1.minus"));
                    BOOST_CHECK(!ps.exists("ps1.zero"));
                    BOOST_CHECK_EQUAL(ps.nameCount(false), 0U);
                }
                
                BOOST_AUTO_TEST_CASE(deepCopy) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("int", 42);
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    psp->set("bottom", "x");
                    ps.set("top", psp);
                
                    dafBase::PropertySet::Ptr psp2 = ps.deepCopy();
                    BOOST_CHECK(psp2->exists("int"));
                    BOOST_CHECK(psp2->exists("top.bottom"));
                    BOOST_CHECK_EQUAL(psp2->getAsInt("int"), 42);
                    BOOST_CHECK_EQUAL(psp2->getAsString("top.bottom"), "x");
                    // Make sure it was indeed a deep copy.
                    BOOST_CHECK(psp2->getAsPropertySetPtr("top") != psp);
                    ps.set("int", 2008);
                    ps.set("top.bottom", "y");
                    BOOST_CHECK_EQUAL(ps.getAsInt("int"), 2008);
                    BOOST_CHECK_EQUAL(ps.getAsString("top.bottom"), "y");
                    BOOST_CHECK_EQUAL(psp->getAsString("bottom"), "y");
                    BOOST_CHECK_EQUAL(psp2->getAsInt("int"), 42);
                    BOOST_CHECK_EQUAL(psp2->getAsString("top.bottom"), "x");
                }
                
                BOOST_AUTO_TEST_CASE(toString) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet ps;
                    ps.set("bool", true);
                    ps.set("char", '*');
                    short s = 42;
                    ps.set("short", s);
                    ps.set("int", 2008);
                    ps.set("int64_t", INT64CONST(0xfeeddeadbeef));
                    float f = 3.14159;
                    ps.set("float", f);
                    double d = 2.718281828459045;
                    ps.set("double", d);
                    ps.set<std::string>("char*", "foo");
                    ps.set("char*2", "foo2");
                    ps.set("string", std::string("bar"));
                    ps.set("ps1.pre", 1);
                    ps.set("ps1.post", 2);
                    ps.set("ps2.plus", 10.24);
                    ps.set("ps2.minus", -10.24);
                    ps.set("ps3.sub.subsub", "foo");
                    ps.add("v", 10);
                    ps.add("v", 9);
                    ps.add("v", 8);
                
                    BOOST_CHECK_EQUAL(ps.toString(),
                        "bool = 1\n"
                        "char = '*'\n"
                        "char* = \"foo\"\n"
                        "char*2 = \"foo2\"\n"
                        "double = 2.7182818284590\n"
                        "float = 3.141590\n"
                        "int = 2008\n"
                        "int64_t = 280297596632815\n"
                        "ps1 = {\n"
                        "..post = 2\n"
                        "..pre = 1\n"
                        "}\n"
                        "ps2 = {\n"
                        "..minus = -10.240000000000\n"
                        "..plus = 10.240000000000\n"
                        "}\n"
                        "ps3 = {\n"
                        "..sub = {\n"
                        "....subsub = \"foo\"\n"
                        "..}\n"
                        "}\n"
                        "short = 42\n"
                        "string = \"bar\"\n"
                        "v = [ 10, 9, 8 ]\n"
                        );
                    BOOST_CHECK_EQUAL(ps.toString(true),
                        "bool = 1\n"
                        "char = '*'\n"
                        "char* = \"foo\"\n"
                        "char*2 = \"foo2\"\n"
                        "double = 2.7182818284590\n"
                        "float = 3.141590\n"
                        "int = 2008\n"
                        "int64_t = 280297596632815\n"
                        "ps1 = { ... }\n"
                        "ps2 = { ... }\n"
                        "ps3 = { ... }\n"
                        "short = 42\n"
                        "string = \"bar\"\n"
                        "v = [ 10, 9, 8 ]\n"
                        );
                }
                
                BOOST_AUTO_TEST_CASE(cycle) { /* parasoft-suppress LsstDm-3-1 LsstDm-3-4a LsstDm-5-25 LsstDm-4-6 "Boost test harness macros" */
                    dafBase::PropertySet::Ptr psp(new dafBase::PropertySet);
                    psp->set("int", 42);
                    psp->set("a.double", 3.14159);
                    psp->set("b.c.d", 2008);
                    dafBase::PropertySet::Ptr a = psp->getAsPropertySetPtr("a");
                    dafBase::PropertySet::Ptr b = psp->getAsPropertySetPtr("b");
                    dafBase::PropertySet::Ptr c = psp->getAsPropertySetPtr("b.c");
                    BOOST_CHECK_THROW(psp->set("t", psp),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
748  <a href="#14b5a130">14b5a130</a> -                       pexExcept::InvalidParameterException);</div>
              ?                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
749  <a href="#25738fd8">25738fd8</a> +                       pexExcept::InvalidParameterError);</div>
              ?                                                   ^^ ^
                    BOOST_CHECK_THROW(psp->set("a.t", psp),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
750  <a href="#14b5a130">14b5a130</a> -                       pexExcept::InvalidParameterException);</div>
              ?                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
751  <a href="#25738fd8">25738fd8</a> +                       pexExcept::InvalidParameterError);</div>
              ?                                                   ^^ ^
                    BOOST_CHECK_THROW(psp->set("a.t", a),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
752  <a href="#14b5a130">14b5a130</a> -                       pexExcept::InvalidParameterException);</div>
              ?                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
753  <a href="#25738fd8">25738fd8</a> +                       pexExcept::InvalidParameterError);</div>
              ?                                                   ^^ ^
                    psp->set("b.t", psp->getAsPropertySetPtr("a"));
                    BOOST_CHECK_EQUAL(a, psp->getAsPropertySetPtr("b.t"));
                    BOOST_CHECK_THROW(psp->set("b.c.t", b),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
756  <a href="#14b5a130">14b5a130</a> -                       pexExcept::InvalidParameterException);</div>
              ?                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
757  <a href="#25738fd8">25738fd8</a> +                       pexExcept::InvalidParameterError);</div>
              ?                                                   ^^ ^
                    BOOST_CHECK_THROW(psp->set("b.c.t", c),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
758  <a href="#14b5a130">14b5a130</a> -                       pexExcept::InvalidParameterException);</div>
              ?                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
759  <a href="#25738fd8">25738fd8</a> +                       pexExcept::InvalidParameterError);</div>
              ?                                                   ^^ ^
                    BOOST_CHECK_THROW(a->set("t", psp),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
760  <a href="#2715d452">2715d452</a> -                       pexExcept::InvalidParameterException);</div>
              ?                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
761  <a href="#25738fd8">25738fd8</a> +                       pexExcept::InvalidParameterError);</div>
              ?                                                   ^^ ^
                }
                
                BOOST_AUTO_TEST_SUITE_END()
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="5684f115"/></a>5684f115</h3>

<pre>
commit 5684f1152b34043b04aa78a9a22e2040d334aea0
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Nov 27 00:55:47 2008 +0000

    Merged revisions 6456-6607 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/base/tickets/480
    
    ........
      r6456 | ktlim | 2008-11-22 19:10:27 -0800 (Sat, 22 Nov 2008) | 2 lines
    
      Create new ticket branch for PropertySet addition.
    ........
      r6486 | ktlim | 2008-11-24 21:51:45 -0800 (Mon, 24 Nov 2008) | 1 line
    
      Initial checkin of PropertySet skeleton.
    ........
      r6487 | ktlim | 2008-11-24 23:39:09 -0800 (Mon, 24 Nov 2008) | 1 line
    
      Begin implementing get() and set() methods.
    ........
      r6555 | ktlim | 2008-11-25 21:12:26 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Remove old DataProperty.i.
    ........
      r6556 | ktlim | 2008-11-25 21:13:21 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Add many, many test cases for PropertySet.
    ........
      r6557 | ktlim | 2008-11-25 21:14:03 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Only boost headers are needed now.  TR1 is tested for in sconsUtils.
    ........
      r6558 | ktlim | 2008-11-25 21:17:59 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Major implementation change: use a vector<boost::any> instead of a boost::any containing a vector<T>.  Simplifies the normal cases substantially.  getArray() now has to return a vector instead of a reference.  Added convenience methods to allow set() and add() with char const* (still retrieved as std::string).  Added private methods for recursive descent with multipart names.
    ........
      r6559 | ktlim | 2008-11-25 21:18:30 -0800 (Tue, 25 Nov 2008) | 1 line
    
      Implement all PropertySet functionality.
    ........
      r6564 | ktlim | 2008-11-25 23:53:45 -0800 (Tue, 25 Nov 2008) | 1 line
    
      remove() doesn't throw, even if the name doesn't or can't exist.  Test for various exceptions.
    ........
      r6565 | ktlim | 2008-11-26 01:51:28 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Add char test cases.  Change type of exception returned by bad combine.
    ........
      r6566 | ktlim | 2008-11-26 01:57:08 -0800 (Wed, 26 Nov 2008) | 2 lines
    
      Improve exception safety for private findOrInsert() method.  Add handling for signed char.  Instantiate templates for char/signed char/unsigned char.  Improve toString() output for char types.  Change exception type returned for mismatches in combine().  Standardize on back() for type checking rather than at(0).  Add lots of doxygen comments.
    ........
      r6580 | ktlim | 2008-11-26 09:10:10 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Exclude python (for now) and tests directories from docs.  Set (a slightly more meaningful) version number.
    ........
      r6581 | ktlim | 2008-11-26 09:10:33 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Fix comment for getAsInt64().
    ........
      r6582 | ktlim | 2008-11-26 09:12:37 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Enable use of vectors, set(), add(), and getArray() from Python.  Types must be specified explicitly except for set(string) and add(string).  Only bool, int, double, string are supported for now.
    ........
      r6583 | ktlim | 2008-11-26 11:55:45 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Use pex_exceptions instead of std::runtime_error.
    ........
      r6584 | ktlim | 2008-11-26 12:36:51 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Improve PropertySet Python interface.
    ........
      r6602 | ktlim | 2008-11-26 14:56:42 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Handle topLevelOnly better.
    ........
      r6603 | ktlim | 2008-11-26 14:58:49 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Add a test for toString(true).
    ........
      r6606 | ktlim | 2008-11-26 16:53:12 -0800 (Wed, 26 Nov 2008) | 1 line
    
      Initial Python tests.
    ........
</pre>
<h3><a name="a494ae4a"/></a>a494ae4a</h3>

<pre>
commit a494ae4ac055a8632a6688d128c0e3a100122ff6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Jan 13 00:15:19 2009 +0000

    Throw dafBase::TypeMismatchException instead of boost::bad_any_cast.  #564
</pre>
<h3><a name="2715d452"/></a>2715d452</h3>

<pre>
commit 2715d4523b801e729a8fd055f79b6b2949e58544
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Jan 13 02:38:34 2009 +0000

    Check for adding parents directly to child PropertySets.  #561
</pre>
<h3><a name="14b5a130"/></a>14b5a130</h3>

<pre>
commit 14b5a1306ff7a4216b36b75a66217ee98c7e96a9
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Mon Jan 12 23:08:24 2009 +0000

    Add pointer cycle checking.  #561
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="86425aff"/></a>86425aff</h3>

<pre>
commit 86425aff3c781e9a2d98ad5fb3fee804928b2878
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 25 15:52:17 2014 -0700

    Respond to K-T's review by unifying the namespace usage for exceptions in two files.
</pre>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_30"><a name="src/Citizen.cc"/></a>src/Citizen.cc</h1>

<h3 id="toc_31">Diff:</h3>

<pre>
                // -*- LSST-C++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                //! \file
                //! \brief Implementation of Citizen
                
                #include <iostream>
                #include <boost/shared_ptr.hpp>
                #include <boost/scoped_ptr.hpp>         // should use std::unique_ptr from C++11 when available
                #include <boost/format.hpp>
                #include <ctype.h>
                #include <cerrno>
                
                #include "lsst/daf/base/Citizen.h"
                #include "lsst/pex/exceptions.h"
                #include "lsst/utils/Demangle.h"
                
                namespace dafBase = lsst::daf::base;
                
                namespace {
                
                template <typename T>
                class ThreadPrivate {
                public:
                    ThreadPrivate(T const& t) : _init(t) {
                        int ret = pthread_key_create(&_key, del);
                        if (ret != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
49   <a href="#ed95ace3">ed95ace3</a> -             throw LSST_EXCEPT(lsst::pex::exceptions::MemoryException,</div>
              ?                                                             ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
49   <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(lsst::pex::exceptions::MemoryError,</div>
              ?                                                             ^^ ^
                                              "Could not create key");
                        }
                    };
                    T& getRef(void) {
                        T* d = reinterpret_cast<T*>(pthread_getspecific(_key));
                        if (d == 0) {
                            d = new T(_init);
                            pthread_setspecific(_key, d);
                        }
                        return *d;
                    };
                
                private:
                    pthread_key_t _key;
                    T _init;
                
                    static void del(void* data) {
                        T* d = reinterpret_cast<T*>(data);
                        delete d;
                    };
                };
                
                static ThreadPrivate<dafBase::Citizen::memId> perThreadId(1);
                static ThreadPrivate<bool> perThreadPersistFlag(false);
                
                class RwLock {
                public:
                    RwLock(void) {
                        int ret = pthread_rwlock_init(&_lock, 0);
                        if (ret != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
80   <a href="#1265aa78">1265aa78</a> -             throw LSST_EXCEPT(lsst::pex::exceptions::MemoryException,</div>
              ?                                                             ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
80   <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(lsst::pex::exceptions::MemoryError,</div>
              ?                                                             ^^ ^
                                              "Could not create Citizen lock");
                        }
                    };
                    void lock(void) {
                        int ret = pthread_rwlock_wrlock(&_lock);
                        if (ret != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#43766280">43766280</a> -             throw LSST_EXCEPT(lsst::pex::exceptions::MemoryException,</div>
              ?                                                             ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(lsst::pex::exceptions::MemoryError,</div>
              ?                                                             ^^ ^
                                              "Could not acquire Citizen write lock");
                        }
                    };
                    bool rdlock(void) {
                        int ret = pthread_rwlock_rdlock(&_lock);
                        if (ret == 0) return true;
                        if (ret == EDEADLK) return false;
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
95   <a href="#1d2ec99c">1d2ec99c</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::MemoryException,</div>
              ?                                                         ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
95   <a href="#25738fd8">25738fd8</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::MemoryError,</div>
              ?                                                         ^^ ^
                                          "Could not acquire Citizen read lock");
                    };
                    void unlock(void) {
                        int ret = pthread_rwlock_unlock(&_lock);
                        if (ret != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
101  <a href="#43766280">43766280</a> -             throw LSST_EXCEPT(lsst::pex::exceptions::MemoryException,</div>
              ?                                                             ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
101  <a href="#25738fd8">25738fd8</a> +             throw LSST_EXCEPT(lsst::pex::exceptions::MemoryError,</div>
              ?                                                             ^^ ^
                                              "Could not release Citizen lock");
                        }
                    };
                
                private:
                    pthread_rwlock_t _lock;
                };
                
                static RwLock citizenLock;
                
                class ReadGuard {
                public:
                    ReadGuard(RwLock& lock) : _lock(lock) {
                        _mustUnlock = _lock.rdlock();
                    };
                    ~ReadGuard(void) {
                        if (_mustUnlock) _lock.unlock();
                    };
                
                private:
                    RwLock& _lock;
                    bool _mustUnlock;
                };
                
                class WriteGuard {
                public:
                    WriteGuard(RwLock& lock) : _lock(lock) {
                        _lock.lock();
                    };
                    ~WriteGuard(void) {
                        _lock.unlock();
                    };
                
                private:
                    RwLock& _lock;
                };
                
                } // anonymous namespace
                
                //! Called once when the memory system is being initialised
                //
                // \brief A class that is instantiated once during startup
                //
                // The main purpose of CitizenInit is to provide a place to set
                // breakpoints to setup memory debugging; see discussion on trac
                //
                class CitizenInit {
                public:
                    CitizenInit() : _dummy(1) { }
                private:
                    volatile int _dummy;
                };
                 
                CitizenInit one;
                //
                // Con/Destructors
                //
                dafBase::Citizen::memId dafBase::Citizen::_addCitizen(Citizen const* c) {
                    memId cid = _nextMemIdAndIncrement();
                    WriteGuard guard(citizenLock);
                    if (_shouldPersistCitizens()) {
                        _persistentCitizens[c] = std::make_pair(cid, pthread_self());
                    } else {
                        _activeCitizens[c] = std::make_pair(cid, pthread_self());
                    }
                    if (cid == _newId) {
                        _newId += _newCallback(cid);
                    }
                    return cid;
                }
                
                dafBase::Citizen::Citizen(std::type_info const& type) :
                    _sentinel(magicSentinel),
                    _CitizenId(_addCitizen(this)),
                    _typeName(type.name()) {
                }
                
                dafBase::Citizen::Citizen(Citizen const& citizen) :
                    _sentinel(magicSentinel),
                    _CitizenId(_addCitizen(this)),
                    _typeName(citizen._typeName) {
                }
                
                dafBase::Citizen::~Citizen() {
                    {
                        WriteGuard guard(citizenLock);
                        if (_CitizenId == _deleteId) {
                            _deleteId += _deleteCallback(this);
                        }
                    }
                
                    (void)_hasBeenCorrupted();  // may execute callback
                    _sentinel = 0x0000dead;     // In case we have a dangling pointer
                
                    bool corrupt = false;
                    {
                        WriteGuard guard(citizenLock);
                        size_t nActive = _activeCitizens.erase(this);
                        corrupt = nActive > 1 ||
                            (nActive == 0 && _persistentCitizens.erase(this) != 1);
                    }
                    if (corrupt) {
                        (void)_corruptionCallback(this);
                    }
                }
                
                //! Called once when the memory system is being initialised
                //
                // The main purpose of this routine is as a place to set
                // breakpoints to setup memory debugging; see discussion on trac
                //
                int dafBase::Citizen::init() {
                    volatile int dummy = 1;
                    return dummy;
                }
                
                /******************************************************************************/
                //
                // Return (some) private state
                //
                //! Return the Citizen's ID
                dafBase::Citizen::memId dafBase::Citizen::getId() const {
                    return _CitizenId;
                }
                
                //! Return the memId of the next object to be allocated
                dafBase::Citizen::memId dafBase::Citizen::getNextMemId() {
                    return _nextMemId();
                }
                
                //! Return the memId of the next object to be allocated
                dafBase::Citizen::memId dafBase::Citizen::_nextMemId() {
                    return perThreadId.getRef();
                }
                
                //! Return the memId and prepare for the next object to be allocated
                dafBase::Citizen::memId dafBase::Citizen::_nextMemIdAndIncrement() {
                    return perThreadId.getRef()++;
                }
                
                //! Return a string representation of a Citizen
                //
                std::string dafBase::Citizen::repr() const {
                    return boost::str(boost::format("%d: %08x %s")
                                      % _CitizenId
                                      % this
                                      % lsst::utils::demangleType(_typeName)
                                     );
                }
                
                //! Mark a Citizen as persistent and not destroyed until process end.
                void dafBase::Citizen::markPersistent(void) {
                    WriteGuard guard(citizenLock);
                    _persistentCitizens[this] = _activeCitizens[this];
                    _activeCitizens.erase(this);
                }
                
                //! \name Census
                //! Provide a list of current Citizens
                //@{
                //
                //
                //! How many active Citizens are there?
                //
                int dafBase::Citizen::census(
                    int,                                //<! the int argument allows overloading
                    memId startingMemId                 //!< Don't print Citizens with lower IDs
                    ) {
                    if (startingMemId == 0) {              // easy
                        ReadGuard guard(citizenLock);
                        return _activeCitizens.size();
                    }
                
                    int n = 0;
                    ReadGuard guard(citizenLock);
                    for (table::iterator cur = _activeCitizens.begin();
                         cur != _activeCitizens.end(); cur++) {
                        if (cur->first->_CitizenId >= startingMemId) {
                            n++;
                        }
                    }
                
                    return n;    
                }
                //
                //! Print a list of all active Citizens to stream, sorted by ID
                //
                void dafBase::Citizen::census(
                    std::ostream &stream,               //!< stream to print to
                    memId startingMemId                 //!< Don't print Citizens with lower IDs
                    ) {
                    ReadGuard guard(citizenLock);
                
                    boost::scoped_ptr<std::vector<Citizen const*> const> leaks(Citizen::census());
                
                    for (std::vector<Citizen const *>::const_iterator citizen = leaks->begin(), end = leaks->end();
                         citizen != end; ++citizen) {
                        if ((*citizen)->getId() >= startingMemId) {
                            stream << (*citizen)->repr() << "\n";
                        }
                    }
                }
                
                /************************************************************************************************************/
                namespace {
                bool cmpId(dafBase::Citizen const *a, dafBase::Citizen const *b)
                {
                    return a->getId() < b->getId();
                }
                } 
                
                //
                //! Return a (newly allocated) std::vector of active Citizens sorted by ID
                //
                //! You are responsible for deleting it; or you can say
                //!    boost::scoped_ptr<std::vector<Citizen const*> const>
                //!        leaks(Citizen::census());
                //! and not bother (that becomes std::unique_ptr in C++11)
                //
                std::vector<dafBase::Citizen const*> const* dafBase::Citizen::census() {
                    std::vector<Citizen const*>* vec =
                        new std::vector<Citizen const*>(0);
                    ReadGuard guard(citizenLock);
                    vec->reserve(_activeCitizens.size());
                
                    for (table::iterator cur = _activeCitizens.begin();
                         cur != _activeCitizens.end(); cur++) {
                        vec->push_back(dynamic_cast<Citizen const*>(cur->first));
                    }
                        
                    std::sort(vec->begin(), vec->end(), cmpId);
                
                    return vec;
                }
                
                //@}
                
                //! Check for corruption
                //! Return true if the block is corrupted, but
                //! only after calling the corruptionCallback
                bool dafBase::Citizen::_hasBeenCorrupted() const {
                    if (_sentinel == static_cast<int>(magicSentinel)) {
                        return false;
                    }
                
                    (void)_corruptionCallback(this);
                    return true;
                }
                
                //! Check all allocated blocks for corruption
                bool dafBase::Citizen::hasBeenCorrupted() {
                    ReadGuard guard(citizenLock);
                    for (table::iterator cur = _activeCitizens.begin();
                         cur != _activeCitizens.end(); cur++) {
                        if (cur->first->_hasBeenCorrupted()) {
                            return true;
                        }
                    }
                    for (table::iterator cur = _persistentCitizens.begin();
                         cur != _persistentCitizens.end(); cur++) {
                        if (cur->first->_hasBeenCorrupted()) {
                            return true;
                        }
                    }
                
                    return false;
                }
                
                //! \name callbackIDs
                //! Set callback Ids. The old Id is returned
                //@{
                //
                //! Call the NewCallback when block is allocated
                dafBase::Citizen::memId dafBase::Citizen::setNewCallbackId(
                    Citizen::memId id                   //!< Desired ID
                    ) {
                    WriteGuard guard(citizenLock);
                    Citizen::memId oldId = _newId;
                    _newId = id;
                
                    return oldId;
                }
                
                //! Call the current DeleteCallback when block is deleted
                dafBase::Citizen::memId dafBase::Citizen::setDeleteCallbackId(
                    Citizen::memId id                   //!< Desired ID
                    ) {
                    WriteGuard guard(citizenLock);
                    Citizen::memId oldId = _deleteId;
                    _deleteId = id;
                
                    return oldId;
                }
                //@}
                
                //! \name callbacks
                //! Set the New/Delete callback functions; in each case
                //! the previously installed callback is returned. These
                //! callback functions return a value which is Added to
                //! the previously registered id.
                //!
                //! The default callback functions are called
                //! default{New,Delete}Callback; you may want to set a break
                //! point in these callbacks from your favourite debugger
                //
                
                //@{
                //! Set the NewCallback function
                
                dafBase::Citizen::memNewCallback dafBase::Citizen::setNewCallback(
                    Citizen::memNewCallback func //! The new function to be called when a designated block is allocated
                    ) {
                    Citizen::memNewCallback old = _newCallback;
                    _newCallback = func;
                
                    return old;
                }
                
                //! Set the DeleteCallback function
                dafBase::Citizen::memCallback dafBase::Citizen::setDeleteCallback(
                    Citizen::memCallback func           //!< function be called when desired block is deleted
                    ) {
                    Citizen::memCallback old = _deleteCallback;
                    _deleteCallback = func;
                
                    return old;
                }
                    
                //! Set the CorruptionCallback function
                dafBase::Citizen::memCallback dafBase::Citizen::setCorruptionCallback(
                    Citizen::memCallback func //!< function be called when block is found to be corrupted
                                                                   ) {
                    Citizen::memCallback old = _corruptionCallback;
                    _corruptionCallback = func;
                
                    return old;
                }
                    
                //! Default callbacks.
                //!
                //! Note that these may well be the target of debugger breakpoints, so e.g. dId
                //! may well be changed behind our back
                //@{
                //! Default NewCallback
                dafBase::Citizen::memId defaultNewCallback(
                                                           dafBase::Citizen::memId const cid //!< ID for just-allocated Citizen
                                                 ) {
                    static int dId = 0;             // how much to incr memId
                    std::cerr << boost::format("Allocating memId %d\n") % cid;
                
                    return dId;
                }
                
                //! Default DeleteCallback
                dafBase::Citizen::memId defaultDeleteCallback(dafBase::Citizen const* ptr //!< About-to-be deleted Citizen
                                                    ) {
                    static int dId = 0;             // how much to incr memId
                    std::cerr << boost::format("Deleting memId %s\n") % ptr->repr();
                
                    return dId;
                }
                
                //! Default CorruptionCallback
                dafBase::Citizen::memId defaultCorruptionCallback(dafBase::Citizen const* ptr //!< About-to-be deleted Citizen
                                              ) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
467  <a href="#e214190f">e214190f</a> -     throw LSST_EXCEPT(lsst::pex::exceptions::MemoryException,</div>
              ?                                                     ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
467  <a href="#25738fd8">25738fd8</a> +     throw LSST_EXCEPT(lsst::pex::exceptions::MemoryError,</div>
              ?                                                     ^^ ^
                                      str(boost::format("Citizen \"%s\" is corrupted") % ptr->repr()));
                
                    return ptr->getId();                // NOTREACHED
                }
                
                bool& dafBase::Citizen::_shouldPersistCitizens(void) {
                    return perThreadPersistFlag.getRef();
                }
                
                //@}
                //
                // Initialise static members
                //
                dafBase::Citizen::memId dafBase::Citizen::_newId = 0;
                dafBase::Citizen::memId dafBase::Citizen::_deleteId = 0;
                dafBase::Citizen::table dafBase::Citizen::_activeCitizens;
                dafBase::Citizen::table dafBase::Citizen::_persistentCitizens;
                
                dafBase::Citizen::memNewCallback dafBase::Citizen::_newCallback = defaultNewCallback;
                dafBase::Citizen::memCallback dafBase::Citizen::_deleteCallback = defaultDeleteCallback;
                dafBase::Citizen::memCallback dafBase::Citizen::_corruptionCallback = defaultCorruptionCallback;
                
                
                dafBase::PersistentCitizenScope::PersistentCitizenScope() {
                    Citizen::_shouldPersistCitizens() = true;
                }
                
                dafBase::PersistentCitizenScope::~PersistentCitizenScope() {
                    Citizen::_shouldPersistCitizens() = false;
                }
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="43766280"/></a>43766280</h3>

<pre>
commit 43766280a903c2404a029a5cb61047d97986891d
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Wed May 25 17:06:36 2011 +0000

    RAII goodness.
</pre>
<h3><a name="ed95ace3"/></a>ed95ace3</h3>

<pre>
commit ed95ace3490ac062edfd4813dae0e5292518d131
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Wed May 25 07:11:30 2011 +0000

    Reimplement Citizen in thread-safe manner without changing ABI.
</pre>
<h3><a name="e214190f"/></a>e214190f</h3>

<pre>
commit e214190feeafcb50bb8a36a5f83f8ffba13ec6e4
Author: rhl <rhl@git.lsstcorp.org>
Date:   Fri Jan 9 21:34:48 2009 +0000

    1/ Reinstate throw in case of memory corruption
    2/ Copy citizen.cc from examples to tests and fix -- the original test
    case was correct; it only seemed to start failing as Jeff Bartels
    had removed the throw (see 1)
    3/ Don't run the examples as part of the build
</pre>
<h3><a name="1d2ec99c"/></a>1d2ec99c</h3>

<pre>
commit 1d2ec99c57d9a66a562f33409c293333aa5c8a24
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Jun 3 20:24:50 2011 +0000

    Allow read locks when write lock is already held (permits census() in callbacks).
</pre>
<h3><a name="1265aa78"/></a>1265aa78</h3>

<pre>
commit 1265aa780515cb377cc27e7f8635107590e5c7f2
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri May 27 03:40:00 2011 +0000

    Make locking more like boost::thread (without actually using it).
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="25738fd8"/></a>25738fd8</h3>

<pre>
commit 25738fd87761235a6db5928eaac489b75c5ecff2
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:07:33 2014 -0700

    Renamed exceptions and removed TypeMismatchException: use the new pex::exceptions::TypeError instead
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<h1 id="toc_32"><a name="python/lsst/daf/base/baseLib.i"/></a>python/lsst/daf/base/baseLib.i</h1>

<h3 id="toc_33">Diff:</h3>

<pre>
                // -*- lsst-c++ -*-
                
                /*
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 *
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 *
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 *
                 * You should have received a copy of the LSST License Statement and
                 * the GNU General Public License along with this program.  If not,
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                
                %define daf_base_DOCSTRING
                "
                Access to the classes from the daf_base library
                "
                %enddef
                
                %feature("autodoc", "1");
                %module(package="lsst.daf.base", docstring=daf_base_DOCSTRING) baseLib
                
                %{
                #include "lsst/daf/base/Citizen.h"
                #include "lsst/daf/base/DateTime.h"
                #include "lsst/daf/base/Persistable.h"
                #include "lsst/daf/base/PropertySet.h"
                #include "lsst/daf/base/PropertyList.h"
                %}
                
                %include "lsst/p_lsstSwig.i"
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
44   <a href="#bb936e92">bb936e92</a> + %initializeNumPy(daf_base)</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
45   <a href="#bb936e92">bb936e92</a> + </div>
                %lsst_exceptions()
                %import "lsst/pex/exceptions/exceptionsLib.i"
                
                %shared_ptr(lsst::daf::base::Persistable);
                %shared_ptr(lsst::daf::base::PropertySet);
                %shared_ptr(lsst::daf::base::PropertyList);
                
                %castShared(lsst::daf::base::PropertyList, lsst::daf::base::PropertySet);
                
                %include "persistenceMacros.i"
                %lsst_persistable(lsst::daf::base::PropertySet);
                %lsst_persistable(lsst::daf::base::PropertyList);
                
                // This has to come before PropertySet.h
                %define VectorAddType(type, typeName)
                    %template(Vector ## typeName) std::vector<type>;
                %enddef
                
                %ignore lsst::daf::base::PropertySet::set(std::string const&, char const*);
                %ignore lsst::daf::base::PropertySet::add(std::string const&, char const*);
                %ignore lsst::daf::base::PropertySet::getAsInt64(std::string const&) const;
                %ignore lsst::daf::base::PropertyList::set(std::string const&, char const*);
                %ignore lsst::daf::base::PropertyList::add(std::string const&, char const*);
                %ignore lsst::daf::base::PropertyList::getAsInt64(std::string const&) const;
                
                VectorAddType(bool, Bool)
                VectorAddType(short, Short)
                VectorAddType(int, Int)
                VectorAddType(long, Long)
                VectorAddType(long long, LongLong)
                VectorAddType(float, Float)
                VectorAddType(double, Double)
                VectorAddType(std::string, String)
                VectorAddType(lsst::daf::base::DateTime, DateTime)
                
                %shared_ptr(lsst::daf::base::Citizen);
                %ignore lsst::daf::base::Citizen::operator=;
                
                %include "lsst/daf/base/Citizen.h"
                %include "lsst/daf/base/DateTime.h"
                %include "lsst/daf/base/Persistable.h"
                %include "lsst/daf/base/PropertySet.h"
                %include "lsst/daf/base/PropertyList.h"
                
                %extend lsst::daf::base::DateTime {
                    %pythoncode %{
                        def toPython(self, timescale=None):
                            """Convert a DateTime to Python's datetime
                
                            @param timescale  Timescale for resultant datetime
                            """
                            import datetime
                            nsecs = self.nsecs(timescale) if timescale is not None else self.nsecs()
                            return datetime.datetime.utcfromtimestamp(nsecs/10**9)
                        def __reduce__(self):
                            return self.__class__, (self.nsecs(),)
                        def __str__(self):
                            return self.toString()
                        def __repr__(self):
                            return 'lsst.daf.base.DateTime("' + self.toString() + '")'
                    %}
                }
                
                %template(vectorCitizen) std::vector<lsst::daf::base::Citizen const *>;
                
                // This has to come after PropertySet.h
                %define PropertySetAddType(type, typeName)
                    %template(set ## typeName) lsst::daf::base::PropertySet::set<type >;
                    %template(add ## typeName) lsst::daf::base::PropertySet::add<type >;
                    %template(get ## typeName) lsst::daf::base::PropertySet::get<type >;
                    %template(getArray ## typeName) lsst::daf::base::PropertySet::getArray<type >;
                    %extend lsst::daf::base::PropertySet {
                        static std::type_info const TYPE_ ## typeName = typeid(type);
                    }
                %enddef
                
                PropertySetAddType(bool, Bool)
                PropertySetAddType(short, Short)
                PropertySetAddType(int, Int)
                PropertySetAddType(long, Long)
                PropertySetAddType(long long, LongLong)
                PropertySetAddType(float, Float)
                PropertySetAddType(double, Double)
                PropertySetAddType(std::string, String)
                PropertySetAddType(lsst::daf::base::DateTime, DateTime)
                PropertySetAddType(boost::shared_ptr<lsst::daf::base::PropertySet>, PropertySet)
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
131  <a href="#1db85923">1db85923</a> - %pythoncode {</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
133  <a href="#105cd382">105cd382</a> + %pythoncode %{</div>
              ?             +
                def _propertyContainerElementTypeName(container, name):
                    """Return name of the type of a particular element"""
                    t = container.typeOf(name)
                    for checkType in ("Bool", "Short", "Int", "Long", "LongLong", "Float", "Double", "String", "DateTime"):
                        if t == getattr(container, "TYPE_" + checkType):
                            return checkType
                    return None
                
                def _propertyContainerGet(container, name, asArray=False):
                    """Extract a single Python value of unknown type"""
                    if not container.exists(name):
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
143  <a href="#ee2a91c6">ee2a91c6</a> -         raise lsst.pex.exceptions.LsstException, name + " not found"</div>
              ?                                   ^^^  ^^^^^^ ^^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
145  <a href="#ee7c5445">ee7c5445</a> +         raise lsst.pex.exceptions.NotFoundError(name + " not found")</div>
              ?                                   ^^ +++++ ^^ ^^                   +
                
                    elemType = _propertyContainerElementTypeName(container, name)
                    if elemType:
                        value = getattr(container, "getArray" + elemType)(name)
                        return value[0] if len(value) == 1 and not asArray else value
                
                    try:
                        return container.getAsPropertyListPtr(name)
                    except:
                        pass
                    if container.typeOf(name) == container.TYPE_PropertySet:
                        return container.getAsPropertySetPtr(name)
                    try:
                        return container.getAsPersistablePtr(name)
                    except:
                        pass
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
160  <a href="#5ae86461">5ae86461</a> -     raise lsst.pex.exceptions.LsstException('Unknown PropertySet value type for ' + name)</div>
              ?                               ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
162  <a href="#ee7c5445">ee7c5445</a> +     raise lsst.pex.exceptions.TypeError('Unknown PropertySet value type for ' + name)</div>
              ?                               ^^^^ ^^ ^
                
                def _propertyContainerSet(container, name, value, typeMenu, *args):
                    """Set a single Python value of unknown type"""
                    if hasattr(value, "__iter__"):
                        exemplar = value[0]
                    else:
                        exemplar = value
                
                    t = type(exemplar)
                    if t in typeMenu:
                        return getattr(container, "set" + typeMenu[t])(name, value, *args)
                    # Allow for subclasses
                    for checkType in typeMenu:
                        if isinstance(exemplar, checkType):
                            return getattr(container, "set" + typeMenu[checkType])(name, value, *args)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
176  <a href="#5ae86461">5ae86461</a> -     raise lsst.pex.exceptions.LsstException("Unknown value type for %s: %s" % (name, t))</div>
              ?                               ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
178  <a href="#ee7c5445">ee7c5445</a> +     raise lsst.pex.exceptions.TypeError("Unknown value type for %s: %s" % (name, t))</div>
              ?                               ^^^^ ^^ ^
                
                def _propertyContainerAdd(container, name, value, typeMenu, *args):
                    """Add a single Python value of unknown type"""
                    if hasattr(value, "__iter__"):
                        exemplar = value[0]
                    else:
                        exemplar = value
                
                    t = type(exemplar)
                    if t in typeMenu:
                        return getattr(container, "add" + typeMenu[t])(name, value, *args)
                    # Allow for subclasses
                    for checkType in typeMenu:
                        if isinstance(exemplar, checkType):
                            return getattr(container, "add" + typeMenu[checkType])(name, value, *args)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
192  <a href="#5ae86461">5ae86461</a> -     raise lsst.pex.exceptions.LsstException("Unknown value type for %s: %s" % (name, t))</div>
              ?                               ^^^^ ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
194  <a href="#ee7c5445">ee7c5445</a> +     raise lsst.pex.exceptions.TypeError("Unknown value type for %s: %s" % (name, t))</div>
              ?                               ^^^^ ^^ ^
                
                
                # Mapping of type to method names
                _PS_typeMenu = {bool: "Bool",
                                int: "Int",
                                long: "LongLong",
                                float: "Double",
                                str: "String",
                                DateTime: "DateTime",
                                PropertySet: "PropertySet",
                                PropertyList: "PropertySet",
                                }
                
                def _PS_getValue(self, name, asArray=False):
                    return _propertyContainerGet(self, name, asArray)
                def _PS_setValue(self, name, value):
                    return _propertyContainerSet(self, name, value, _PS_typeMenu)
                def _PS_addValue(self, name, value):
                    return _propertyContainerAdd(self, name, value, _PS_typeMenu)
                
                PropertySet.get = _PS_getValue
                PropertySet.set = _PS_setValue
                PropertySet.add = _PS_addValue
                del _PS_getValue
                del _PS_setValue
                del _PS_addValue
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
219  <a href="#ee2a91c6">ee2a91c6</a> - }</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
221  <a href="#105cd382">105cd382</a> + %}</div>
              ? +
                
                // This has to come after PropertyList.h
                %define PropertyListAddType(type, typeName)
                    %template(set ## typeName) lsst::daf::base::PropertyList::set<type>;
                    %template(add ## typeName) lsst::daf::base::PropertyList::add<type>;
                    %template(get ## typeName) lsst::daf::base::PropertyList::get<type>;
                    %template(getArray ## typeName) lsst::daf::base::PropertyList::getArray<type>;
                    %extend lsst::daf::base::PropertyList {
                static std::type_info const TYPE_ ## typeName = typeid(type);
                void setPropertySet(
                    std::string const& name, PropertySet::Ptr const& value,
                    bool inPlace=true) {
                    $self->set(name, value, inPlace);
                }
                }
                %enddef
                
                PropertyListAddType(bool, Bool)
                PropertyListAddType(short, Short)
                PropertyListAddType(int, Int)
                PropertyListAddType(long, Long)
                PropertyListAddType(long long, LongLong)
                PropertyListAddType(float, Float)
                PropertyListAddType(double, Double)
                PropertyListAddType(std::string, String)
                PropertyListAddType(lsst::daf::base::DateTime, DateTime)
                
                %extend lsst::daf::base::PropertyList {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
248  <a href="#281f5479">281f5479</a> -     %pythoncode {</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
250  <a href="#105cd382">105cd382</a> +     %pythoncode %{</div>
              ?                 +
                        def __len__(self):
                            return self.size()
                        def __getstate__(self):
                            return [(name, _propertyContainerElementTypeName(self, name), self.get(name),
                                     self.getComment(name)) for name in self.getOrderedNames()]
                        def __setstate__(self, state):
                            self.__init__()
                            for name, elemType, value, comment in state:
                                getattr(self, "set" + elemType)(name, value, comment)
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
260  <a href="#105cd382">105cd382</a> +     %}</div>
                }
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
259  <a href="#281f5479">281f5479</a> - }</div>
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
261  <a href="#ee2a91c6">ee2a91c6</a> - %pythoncode {</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
263  <a href="#105cd382">105cd382</a> + %pythoncode %{</div>
              ?             +
                # Mapping of type to method names
                _PL_typeMenu = {bool: "Bool",
                                int: "Int",
                                long: "LongLong",
                                float: "Double",
                                str: "String",
                                DateTime: "DateTime",
                                PropertySet: "PropertySet",
                                PropertyList: "PropertySet",
                                }
                
                def _PL_getValue(self, name, asArray=False):
                    return _propertyContainerGet(self, name, asArray)
                def _PL_setValue(self, name, value, comment=None, inPlace=True):
                    args = []
                    if comment is not None:
                        args.append(comment)
                    args.append(inPlace)
                    return _propertyContainerSet(self, name, value, _PL_typeMenu, *args)
                def _PL_addValue(self, name, value, comment=None, inPlace=True):
                    args = []
                    if comment is not None:
                        args.append(comment)
                    args.append(inPlace)
                    return _propertyContainerAdd(self, name, value, _PL_typeMenu, *args)
                
                PropertyList.get = _PL_getValue
                PropertyList.set = _PL_setValue
                PropertyList.add = _PL_addValue
                del _PL_getValue
                del _PL_setValue
                del _PL_addValue
                
                def _PL_toList(self):
                    orderedNames = self.getOrderedNames()
                    ret = []
                    for name in orderedNames:
                        if self.isArray(name):
                            values = self.get(name)
                            for v in values:
                                ret.append((name, v, self.getComment(name)))
                        else:
                            ret.append((name, self.get(name), self.getComment(name)))
                    return ret
                
                PropertyList.toList = _PL_toList
                del _PL_toList
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
309  <a href="#1db85923">1db85923</a> - }</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
311  <a href="#105cd382">105cd382</a> + %}</div>
              ? +
                
                
</pre>

<p><a href="#homelist">Return to list</a></p>

<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_base/</h2>
<h3><a name="ee2a91c6"/></a>ee2a91c6</h3>

<pre>
commit ee2a91c67a4aa6484cd323b788fc7813615051a6
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Sat Nov 6 15:19:51 2010 +0000

    Merge from ticket #676 (order and comments for properties).
</pre>
<h3><a name="5ae86461"/></a>5ae86461</h3>

<pre>
commit 5ae86461094afe677ac0daacff208e3e2bee8fa2
Author: Paul Price <price@astro.princeton.edu>
Date:   Tue Nov 12 17:13:07 2013 -0500

    PropertySet,PropertyList: address review comments (#3048)
    
    * Removed even more code duplication between PropertySet and
      PropertyList by using common functions, _propertyContainer*
    * Remove special case for int; KTL notes this may not be safe.
      Deferred to new ticket: #3051.
    * That means that pickling requires saving the type.
    * Cleaned up type menu, per request.
    * In addition to checking type equality, follow up with
      isinstance() checks as last resort (for subclasses).
</pre>
<h3><a name="281f5479"/></a>281f5479</h3>

<pre>
commit 281f54798212ecd81d36efc9b5b337d942157911
Author: Paul Price <price@astro.princeton.edu>
Date:   Tue Nov 5 23:56:18 2013 -0500

    make PropertyList and DateTime picklable
    
    Making DateTime picklable was required in order to test pickling
    of PropertyList.
    
    In the process (as part of making tests pass):
    * Cleaned up a bunch of code duplication (_PS_*Value, _PL_*Value)
    * Fixed bugs in Property{List,Set}.get: a python int can be larger
      than SWIG will recognise as an int (so use LongLong).
    * Added memory test to PropertySet_2.py and PropertyList.py
</pre>
<h3><a name="1db85923"/></a>1db85923</h3>

<pre>
commit 1db859237656ee77dd64212eb3579c29fe577c9c
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Jan 13 20:21:30 2009 +0000

    Add generic get() to Python interface.  #562
</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_base/</h2>
<h3><a name="bb936e92"/></a>bb936e92</h3>

<pre>
commit bb936e9230d470ba6cfc08d8407d9afcd46a827e
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Wed Apr 8 16:20:54 2015 -0400

    Use new numeric typemaps to support NumPy scalar arguments.
</pre>
<h3><a name="ee7c5445"/></a>ee7c5445</h3>

<pre>
commit ee7c544513b5a8ce704733c028019930be619168
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Jul 17 14:22:00 2014 -0400

    Adapt to changes in Python Swig interface (DM-827)
</pre>
<h3><a name="105cd382"/></a>105cd382</h3>

<pre>
commit 105cd382a88643e6adf457bbb4c4612b623d4018
Author: Russell Owen <rowen@uw.edu>
Date:   Fri Mar 13 10:47:42 2015 -0700

    Change %python { to %python %{ in a .i file
</pre>
</div>

<p><a href="#homelist">Return to list</a></p>

<script type="text/javascript">
self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{};var Prism=function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):"Array"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case"Array":return e.map(function(e){return t.util.clone(e)})}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var i=r[e];if(2==arguments.length){a=arguments[1];for(var l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);return i}var s={};for(var o in i)if(i.hasOwnProperty(o)){if(o==n)for(var l in a)a.hasOwnProperty(l)&&(s[l]=a[l]);s[o]=i[o]}return t.languages.DFS(t.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=s)}),r[e]=s},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),"Object"===t.util.type(e[r])?t.languages.DFS(e[r],n):"Array"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'),i=0;a=r[i++];)t.highlightElement(a,e===!0,n)},highlightElement:function(a,r,i){for(var l,s,o=a;o&&!e.test(o.className);)o=o.parentNode;if(o&&(l=(o.className.match(e)||[,""])[1],s=t.languages[l]),s){a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=a.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var u=a.textContent;if(u){u=u.replace(/^(?:\r?\n|\r)/,"");var g={element:a,language:l,grammar:s,code:u};if(t.hooks.run("before-highlight",g),r&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){g.highlightedCode=n.stringify(JSON.parse(e.data),l),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(g.element),t.hooks.run("after-highlight",g)},c.postMessage(JSON.stringify({language:g.language,code:g.code}))}else g.highlightedCode=t.highlight(g.code,g.grammar,g.language),t.hooks.run("before-insert",g),g.element.innerHTML=g.highlightedCode,i&&i.call(a),t.hooks.run("after-highlight",g)}}},highlight:function(e,a,r){var i=t.tokenize(e,a);return n.stringify(t.util.encode(i),r)},tokenize:function(e,n){var a=t.Token,r=[e],i=n.rest;if(i){for(var l in i)n[l]=i[l];delete n.rest}e:for(var l in n)if(n.hasOwnProperty(l)&&n[l]){var s=n[l];s="Array"===t.util.type(s)?s:[s];for(var o=0;o<s.length;++o){var u=s[o],g=u.inside,c=!!u.lookbehind,f=0,h=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){u.lastIndex=0;var m=u.exec(d);if(m){c&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),N=[p,1];b&&N.push(b);var O=new a(l,g?t.tokenize(m,g):m,h);N.push(O),w&&N.push(w),Array.prototype.splice.apply(r,N)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,i=0;r=a[i++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if("string"==typeof e)return e;if("Array"===t.util.type(e))return e.map(function(t){return n.stringify(t,a,e)}).join("");var i={type:e.type,content:n.stringify(e.content,a,r),tag:"span",classes:["token",e.type],attributes:{},language:a,parent:r};if("comment"==i.type&&(i.attributes.spellcheck="true"),e.alias){var l="Array"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(i.classes,l)}t.hooks.run("wrap",i);var s="";for(var o in i.attributes)s+=o+'="'+(i.attributes[o]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'" '+s+">"+i.content+"</"+i.tag+">"},!self.document)return self.addEventListener?(self.addEventListener("message",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code;self.postMessage(JSON.stringify(t.util.encode(t.tokenize(r,t.languages[a])))),self.close()},!1),self.Prism):self.Prism;var a=document.getElementsByTagName("script");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)),self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism);
</script>
</body>

</html>
