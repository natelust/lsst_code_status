# Comparison of the daf_persistence repository


<div style="background-color:Aquamarine; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Summary of Repositories</h1>
<p>
Comparison run at 11:49AM on June 09, 2015<br>
There are <b>407</b> differences between the two repositories<br><br>
Repository <b>/Users/nate/repos_hsc/daf_persistence/</b> <br> Revision <b>fa7cdce648c3dfb07a2a44d60c06a945a2e66fe6</b><br> Branch <b>master</b><br>Last commit was on <b>2015-04-17 14:04:59 +0900</b><br><br>
Repository <b>/Users/nate/repos_lsst/daf_persistence/</b> <br> Revision <b>6edbc004764d503e362ca1e2f5bedb41f9508e1c</b><br> Branch <b>master</b><br>Last commit was on <b>2015-05-11 10:42:26 -0700</b><br><br>
</p>
</div>



___
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Files only in /Users/nate/repos_hsc/daf_persistence/</h1>
<h2>python/lsst/daf/persistence/eupsVersions.py</h2>
<pre>
commit fa7cdce648c3dfb07a2a44d60c06a945a2e66fe6
Merge: ca4e8df f9540de
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Fri Apr 17 14:04:59 2015 +0900

    Merge branch 'u/bick/HSC-1106'</pre>
</div>

<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
<h1>Files only in /Users/nate/repos_lsst/daf_persistence/</h1>
<h2>tests/FitsStorage_1.cc</h2>
<pre>
commit 6edbc004764d503e362ca1e2f5bedb41f9508e1c
Merge: 3391ba5 615041f
Author: danielsf <scott.f.daniel@gmail.com>
Date:   Mon May 11 10:42:26 2015 -0700

    Merge branch 'tickets/DM-2701'</pre>
</div>




# List of the files in common<a name="homelist"></a>
Files without links do not differ

* ```include/lsst/daf/persistence/Formatter.h```
* ```doc/doxygen.conf.in```
* ```tests/LogicalLocation.py```
* [```src/DbAuth.cc```](#src/DbAuth.cc)
* ```tests/root/_parent/_mapper```
* [```tests/Persistence_2.cc```](#tests/Persistence_2.cc)
* ```python/lsst/daf/persistence/butlerFactory.py```
* [```src/Storage.cc```](#src/Storage.cc)
* ```SConstruct```
* [```tests/SConscript```](#tests/SConscript)
* ```include/lsst/daf/persistence/FormatterRegistry.h```
* ```include/lsst/daf/persistence/FormatterImpl.h```
* ```include/lsst/daf/persistence/DbStorage.h```
* ```python/lsst/daf/persistence/persistenceLib.i```
* ```include/lsst/daf/persistence/XmlStorage.h```
* [```.gitignore```](#.gitignore)
* [```src/PropertySetFormatter.cc```](#src/PropertySetFormatter.cc)
* [```src/FormatterRegistry.cc```](#src/FormatterRegistry.cc)
* ```ups/daf_persistence.cfg```
* [```tests/FormatterRegistry_1.cc```](#tests/FormatterRegistry_1.cc)
* ```README```
* ```src/Formatter.cc```
* ```include/lsst/daf/persistence/FitsStorage.h```
* ```include/lsst/daf/persistence/StorageRegistry.h```
* ```python/lsst/daf/persistence/SConscript```
* ```include/lsst/daf/persistence.h```
* ```tests/DbStorage_2.py```
* [```tests/DbStorage_1.cc```](#tests/DbStorage_1.cc)
* ```include/lsst/daf/persistence/Persistence.h```
* ```tests/mapperImport.py```
* ```tests/testDbAuth.paf```
* ```tests/mapper.py```
* [```src/DbStorageImpl.cc```](#src/DbStorageImpl.cc)
* [```include/lsst/daf/persistence/PropertySetFormatter.cc```](#include/lsst/daf/persistence/PropertySetFormatter.cc)
* ```policy/ButlerFactoryDictionary.paf```
* ```doc/SConscript```
* ```python/lsst/daf/persistence/readProxy.py```
* ```src/XmlStorage.cc```
* ```src/DbStorage.cc```
* ```include/lsst/daf/persistence/DbAuth.h```
* ```include/lsst/daf/persistence/PropertySetFormatter.h```
* ```tests/PropertySetPersist.cc```
* [```python/lsst/daf/persistence/butler.py```](#python/lsst/daf/persistence/butler.py)
* [```src/DbStorageLocation.cc```](#src/DbStorageLocation.cc)
* [```src/DbTsvStorage.cc```](#src/DbTsvStorage.cc)
* ```include/lsst/daf/persistence/LogicalLocation.h```
* ```src/StorageRegistry.cc```
* ```tests/cameraMapper.py```
* ```include/lsst/daf/persistence/Storage.h```
* [```python/lsst/daf/persistence/__init__.py```](#python/lsst/daf/persistence/__init__.py)
* ```include/lsst/daf/persistence/DbStorageImpl.h```
* [```src/FitsStorage.cc```](#src/FitsStorage.cc)
* [```src/BoostStorage.cc```](#src/BoostStorage.cc)
* [```tests/Persistence_3.cc```](#tests/Persistence_3.cc)
* ```python/lsst/daf/persistence/butlerSubset.py```
* ```tests/butlerSubset.py```
* ```include/lsst/daf/persistence/BoostStorage.h```
* ```ups/daf_persistence.build```
* ```tests/DbStorage_1.py```
* ```python/lsst/__init__.py```
* [```tests/Persistence_1.cc```](#tests/Persistence_1.cc)
* ```tests/butlerPickle.py```
* ```lib/SConscript```
* ```tests/testDb.sql```
* ```src/Persistence.cc```
* ```python/lsst/daf/persistence/butlerLocation.py```
* ```tests/PropertySet_2.cc```
* ```include/lsst/daf/persistence/DbStorageLocation.h```
* ```tests/pickleMapper.py```
* ```python/lsst/daf/__init__.py```
* [```ups/daf_persistence.table```](#ups/daf_persistence.table)
* ```tests/DbAuth.py```
* ```include/lsst/daf/persistence/DbTsvStorage.h```
* [```src/LogicalLocation.cc```](#src/LogicalLocation.cc)
* ```tests/Persistence_1.py```
* [```tests/Persistence_2.py```](#tests/Persistence_2.py)
* [```python/lsst/daf/persistence/mapper.py```](#python/lsst/daf/persistence/mapper.py)

# <a name="src/DbAuth.cc"/></a>src/DbAuth.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** \file
                 * \brief Implementation of DbAuth class
                 *
                 * \author $Author: ktlim $
                 * \version $Revision: 2673 $
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/base/Citizen.h"
                #include "lsst/daf/persistence/DbAuth.h"
                
                #include "boost/scoped_array.hpp"
                #include <cstdlib>
                #include <fstream>
                
                extern "C" {
                    #include <pwd.h>
                    #include <sys/types.h>
                    #include <sys/stat.h>
                    #include <unistd.h>
                }
                
                #include "lsst/pex/exceptions.h"
                
                namespace dafBase = lsst::daf::base;
                namespace dafPersist = lsst::daf::persistence;
                namespace pexPolicy = lsst::pex::policy;
                
                static pexPolicy::Policy::Ptr authPolicy(static_cast<pexPolicy::Policy*>(0));
                
                static std::pair<std::string, std::string>
                search(std::string const& host, std::string const& port) {
                    if (authPolicy == 0) {
                        passwd pwd;
                        passwd *pw;
                        long maxbuf = sysconf(_SC_GETPW_R_SIZE_MAX);
                        boost::scoped_array<char> buffer(new char[maxbuf]);
                        int ret = getpwuid_r(geteuid(), &pwd, buffer.get(), maxbuf, &pw);
                        if (ret != 0 || pw->pw_dir == 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
74   <a href="#8bd6ded2">8bd6ded2</a> -             throw LSST_EXCEPT(pexExcept::RuntimeErrorException,</div>
              ?                                                      ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
74   <a href="#0c1dd2d0">0c1dd2d0</a> +             throw LSST_EXCEPT(pexExcept::RuntimeError,</div>
                                    "Could not get home directory");
                        }
                        std::string dir = std::string(pw->pw_dir) + "/.lsst";
                        std::string filename = dir + "/db-auth.paf";
                        struct stat st;
                        ret = stat(dir.c_str(), &st);
                        if (ret != 0 || (st.st_mode & (S_IRWXG | S_IRWXO)) != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
82   <a href="#8bd6ded2">8bd6ded2</a> -             throw LSST_EXCEPT(pexExcept::RuntimeErrorException,</div>
              ?                                                      ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
82   <a href="#0c1dd2d0">0c1dd2d0</a> +             throw LSST_EXCEPT(pexExcept::RuntimeError,</div>
                                    dir + " directory is missing or accessible by others");
                        }
                        ret = stat(filename.c_str(), &st);
                        if (ret != 0 || (st.st_mode & (S_IRWXG | S_IRWXO)) != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#8bd6ded2">8bd6ded2</a> -             throw LSST_EXCEPT(pexExcept::RuntimeErrorException,</div>
              ?                                                      ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#0c1dd2d0">0c1dd2d0</a> +             throw LSST_EXCEPT(pexExcept::RuntimeError,</div>
                                    filename + " is missing or accessible by others");
                        }
                        {
                            dafBase::PersistentCitizenScope scopeGuard;
                            authPolicy = pexPolicy::Policy::Ptr(new pexPolicy::Policy(filename));
                        }
                    }
                    int portNum = atoi(port.c_str());
                    pexPolicy::Policy::PolicyPtrArray authArray =
                        authPolicy->getPolicyArray("database.authInfo");
                    for (pexPolicy::Policy::PolicyPtrArray::const_iterator i =
                         authArray.begin(); i != authArray.end(); ++i) {
                        if ((*i)->getString("host") == host &&
                            (*i)->getInt("port") == portNum) {
                            std::string username = (*i)->getString("user");
                            std::string password = (*i)->getString("password");
                            if (username.empty()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
105  <a href="#8bd6ded2">8bd6ded2</a> -                 throw LSST_EXCEPT(pexExcept::RuntimeErrorException,</div>
              ?                                                          ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
105  <a href="#0c1dd2d0">0c1dd2d0</a> +                 throw LSST_EXCEPT(pexExcept::RuntimeError,</div>
                                        "Empty username for host/port: " + host + ":" + port);
                            }
                            return std::pair<std::string, std::string>(username, password);
                        }
                    }
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#8bd6ded2">8bd6ded2</a> -     throw LSST_EXCEPT(pexExcept::RuntimeErrorException,</div>
              ?                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#0c1dd2d0">0c1dd2d0</a> +     throw LSST_EXCEPT(pexExcept::RuntimeError,</div>
                            "No credentials found for host/port: " + host + ":" + port);
                    return std::pair<std::string, std::string>("", ""); // not reached
                }
                
                /** Set the authenticator Policy.
                 * \param[in] policy Pointer to a Policy
                 */
                void dafPersist::DbAuth::setPolicy(pexPolicy::Policy::Ptr policy) {
                    dafBase::PersistentCitizenScope scopeGuard;
                    authPolicy = pexPolicy::Policy::Ptr(new pexPolicy::Policy(*policy, true));
                }
                
                /** Determine whether an authenticator string is available for database
                 * access.
                 * \param[in] host Name of the host to connect to.
                 * \param[in] port Port number to connect to (as string).
                 * \return True if authenticator is available
                 */
                bool dafPersist::DbAuth::available(std::string const& host,
                                                   std::string const& port) {
                    try {
                        std::pair<std::string, std::string> result = search(host, port);
                        return true;
                    }
                    catch (...) {
                        return false;
                    }
                    return false; // not reached
                }
                
                /** Get the authenticator string for a database.
                 * \param[in] host Name of the host to connect to.
                 * \param[in] port Port number to connect to (as string).
                 * \return String with username:password
                 */
                std::string dafPersist::DbAuth::authString(std::string const& host,
                                                           std::string const& port) {
                    std::pair<std::string, std::string> result = search(host, port);
                    return result.first + ":" + result.second;
                }
                
                /** Get the username to use to authenticate to a database.
                 * \param[in] host Name of the host to connect to.
                 * \param[in] port Port number to connect to (as string).
                 * \return Username string
                 */
                std::string dafPersist::DbAuth::username(std::string const& host,
                                                         std::string const& port) {
                    std::pair<std::string, std::string> result = search(host, port);
                    return result.first;
                }
                
                /** Get the password to use to authenticate to a database.
                 * \param[in] host Name of the host to connect to.
                 * \param[in] port Port number to connect to (as string).
                 * \return Password string
                 */
                std::string dafPersist::DbAuth::password(std::string const& host,
                                                         std::string const& port) {
                    std::pair<std::string, std::string> result = search(host, port);
                    return result.second;
                }
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="8bd6ded2"/></a>8bd6ded2</h3>

<pre>
commit 8bd6ded20030cdb40ed5410b7e711c110e3c7b45
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Mar 10 08:12:28 2009 +0000

    Implement new DbAuth PAF format.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="tests/Persistence_2.cc"/></a>tests/Persistence_2.cc
### Diff:

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * \file Persistence_2.cc
                 *
                 * This test checks that objects can be persisted and retrieved from multiple
                 * Storages.
                 */
                
                #include <sstream>
                #include <sys/time.h>
                #include "lsst/daf/persistence/BoostStorage.h"
                #include "lsst/daf/persistence/DbStorage.h"
                #include "lsst/daf/persistence/Formatter.h"
                #include "lsst/daf/persistence/LogicalLocation.h"
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
36   <a href="#615041f9">615041f9</a> + #include "lsst/daf/persistence/DbAuth.h"</div>
                #include "lsst/daf/persistence/Persistence.h"
                
                #define BOOST_TEST_MODULE Persistence_2
                #define BOOST_TEST_DYN_LINK
                #include "boost/test/unit_test.hpp"
                
                namespace test = boost::test_tools;
                namespace dafBase = lsst::daf::base;
                namespace dafPersist = lsst::daf::persistence;
                
                // A small Persistable.
                
                // Forward declaration may be needed with gcc 4+.
                class MyFormatter;
                
                class MyPersistable : public dafBase::Persistable {
                public:
                    typedef boost::shared_ptr<MyPersistable> Ptr;
                    MyPersistable(double ra = 0.0, double decl = 0.0) : _ra(ra), _decl(decl) { };
                    double getRa(void) const { return _ra; };
                    double getDecl(void) const { return _decl; };
                private:
                    LSST_PERSIST_FORMATTER(MyFormatter);
                    double _ra;
                    double _decl;
                };
                
                // A small Formatter.
                class MyFormatter : public dafPersist::Formatter {
                public:
                    MyFormatter(void) : dafPersist::Formatter(typeid(*this)) { };
                    virtual void write(dafBase::Persistable const* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    virtual dafBase::Persistable* read(dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    virtual void update(dafBase::Persistable* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    template <class Archive> static void delegateSerialize(Archive& ar, unsigned int const version, dafBase::Persistable* persistable);
                private:
                    static dafPersist::Formatter::Ptr createInstance(lsst::pex::policy::Policy::Ptr policy);
                    static dafPersist::FormatterRegistration registration;
                };
                
                // Include this file when implementing a Formatter.
                #include "lsst/daf/persistence/FormatterImpl.h"
                
                // Register the formatter factory function.
                dafPersist::FormatterRegistration MyFormatter::registration("MyPersistable", typeid(MyPersistable), createInstance);
                
                // The definition of the factory function.
                dafPersist::Formatter::Ptr MyFormatter::createInstance(lsst::pex::policy::Policy::Ptr policy) {
                    return dafPersist::Formatter::Ptr(new MyFormatter);
                }
                
                // Persistence for MyPersistables.
                // Supports BoostStorage and DbStorage.
                void MyFormatter::write(dafBase::Persistable const* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    BOOST_CHECK_MESSAGE(persistable != 0, "Persisting null");
                    BOOST_CHECK_MESSAGE(storage, "No Storage provided");
                    long long testId = additionalData->get<long long>("visitId");
                    MyPersistable const* mp = dynamic_cast<MyPersistable const*>(persistable);
                    BOOST_CHECK_MESSAGE(mp != 0, "Persisting non-MyPersistable");
                    if (typeid(*storage) == typeid(dafPersist::BoostStorage)) {
                        dafPersist::BoostStorage* boost = dynamic_cast<dafPersist::BoostStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(boost != 0, "Didn't get BoostStorage");
                        boost->getOArchive() & mp->_ra;
                        return;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::DbStorage)) {
                        dafPersist::DbStorage* db = dynamic_cast<dafPersist::DbStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(db != 0, "Didn't get DbStorage");
                        db->setTableForInsert("DbStorage_Test_2");
                        db->setColumn<long long>("id", testId);
                        db->setColumn<double>("decl", mp->_decl);
                        db->insertRow();
                        return;
                    }
                    BOOST_FAIL("Didn't recognize Storage type");
                
                }
                
                // Retrieval for MyPersistables.
                // Supports BoostStorage, DbStorage, and DbTsvStorage.
                dafBase::Persistable* MyFormatter::read(dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    MyPersistable* mp = new MyPersistable;
                
                    long long testId = additionalData->get<long long>("visitId");
                    if (typeid(*storage) == typeid(dafPersist::BoostStorage)) {
                        dafPersist::BoostStorage* boost = dynamic_cast<dafPersist::BoostStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(boost != 0, "Didn't get BoostStorage");
                        boost->getIArchive() & mp->_ra;
                        return mp;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::DbStorage)) {
                        dafPersist::DbStorage* db = dynamic_cast<dafPersist::DbStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(db != 0, "Didn't get DbStorage");
                        db->setTableForQuery("DbStorage_Test_2");
                        db->condParam<long long>("id", testId);
                        db->setQueryWhere("id = :id");
                        db->outParam("decl", &(mp->_decl));
                
                        db->query();
                
                        BOOST_CHECK_MESSAGE(db->next() == true, "Failed to get row");
                        BOOST_CHECK_MESSAGE(db->columnIsNull(0) == false, "Null column 0");
                        BOOST_CHECK_MESSAGE(db->next() == false, "Got more than one row");
                
                        db->finishQuery();
                        return mp;
                    }
                    BOOST_FAIL("Didn't recognize Storage type");
                    return mp;
                }
                
                void MyFormatter::update(dafBase::Persistable* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    MyPersistable* mp = dynamic_cast<MyPersistable*>(persistable);
                    long long testId = additionalData->get<long long>("visitId");
                    if (typeid(*storage) == typeid(dafPersist::BoostStorage)) {
                        // BoostStorage replaces ra only
                        dafPersist::BoostStorage* boost = dynamic_cast<dafPersist::BoostStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(boost != 0, "Didn't get BoostStorage");
                        boost->getIArchive() & mp->_ra;
                        return;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::DbStorage)) {
                        // DbStorage replaces decl only
                        dafPersist::DbStorage* db = dynamic_cast<dafPersist::DbStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(db != 0, "Didn't get DbStorage");
                        db->setTableForQuery("DbStorage_Test_2");
                        db->condParam<long long>("id", testId);
                        db->setQueryWhere("id = :id");
                        db->outParam("decl", &(mp->_decl));
                
                        db->query();
                
                        BOOST_CHECK_MESSAGE(db->next() == true, "Failed to get row");
                        BOOST_CHECK_MESSAGE(db->columnIsNull(0) == false, "Null column 0");
                        BOOST_CHECK_MESSAGE(db->next() == false, "Got more than one row");
                
                        db->finishQuery();
                        return;
                    }
                    BOOST_FAIL("Didn't recognize Storage type");
                }
                
                // Actually serialize the MyPersistable.
                // Send/get the RA and declination to/from the archive.
                template <class Archive> void MyFormatter::delegateSerialize(Archive& ar, unsigned int const version, dafBase::Persistable* persistable) {
                    MyPersistable* mp = dynamic_cast<MyPersistable*>(persistable);
                    ar & boost::serialization::base_object<dafBase::Persistable>(*mp);
                    ar & mp->_ra;
                    ar & mp->_decl;
                };
                
                ///////////////////////////////////////////////////////////////////////////////
                
                BOOST_AUTO_TEST_SUITE(Persistence2Suite)
                
                BOOST_AUTO_TEST_CASE(Persistence2Test) {
                    // Define a blank Policy.
                    lsst::pex::policy::Policy::Ptr policy(new lsst::pex::policy::Policy);
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
195  <a href="#f69b65eb">f69b65eb</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
196  <a href="#615041f9">615041f9</a> +     //If the user cannot access the test database, exit</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
197  <a href="#615041f9">615041f9</a> +     //without failing</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
198  <a href="#615041f9">615041f9</a> +     dafPersist::DbAuth testAuth;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
199  <a href="#615041f9">615041f9</a> +     testAuth.setPolicy(policy);</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
200  <a href="#615041f9">615041f9</a> +     if(!testAuth.available("lsst10.ncsa.uiuc.edu","3306")){</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
201  <a href="#615041f9">615041f9</a> +         return;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
202  <a href="#615041f9">615041f9</a> +     }</div>
                
                    // Get a unique id for this test.
                    struct timeval tv;
                    gettimeofday(&tv, 0);      
                    long long testId = tv.tv_sec * 1000000LL + tv.tv_usec;
                
                    std::ostringstream os;
                    os << testId;
                    std::string testIdString = os.str();
                
                    dafBase::PropertySet::Ptr additionalData(new dafBase::PropertySet);
                    additionalData->add("visitId", testId);
                    additionalData->add("sliceId", 0);
                
                
                    MyPersistable mp(1.73205, 1.61803);
                
                    dafPersist::LogicalLocation pathLoc("tests/data/MyPersistable.boost." + testIdString);
                    dafPersist::LogicalLocation dbLoc("mysql://lsst10.ncsa.uiuc.edu:3306/test");
                
                    {
                        dafPersist::Persistence::Ptr persist = dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getPersistStorage("BoostStorage", pathLoc));
                        storageList.push_back(persist->getPersistStorage("DbStorage", dbLoc));
                        persist->persist(mp, storageList, additionalData);
                    }
                
                    {
                        dafPersist::Persistence::Ptr persist = dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getRetrieveStorage("BoostStorage", pathLoc));
                        storageList.push_back(persist->getRetrieveStorage("DbStorage", dbLoc));
                        dafBase::Persistable::Ptr pp = persist->retrieve("MyPersistable", storageList, additionalData);
                        BOOST_CHECK_MESSAGE(pp != 0, "Didn't get a Persistable");
                        BOOST_CHECK_MESSAGE(typeid(*pp) == typeid(MyPersistable), "Didn't get MyPersistable");
                        MyPersistable::Ptr mp1 = boost::dynamic_pointer_cast<MyPersistable, dafBase::Persistable>(pp);
                        BOOST_CHECK_MESSAGE(mp1, "Couldn't cast to MyPersistable");
                        BOOST_CHECK_MESSAGE(mp1.get() != &mp, "Got same MyPersistable");
                        BOOST_CHECK_MESSAGE(mp1->getRa() == 1.73205, "RA is incorrect");
                        BOOST_CHECK_MESSAGE(mp1->getDecl() == 1.61803, "Decl is incorrect");
                    }
                }
                
                BOOST_AUTO_TEST_SUITE_END()
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="615041f9"/></a>615041f9</h3>

<pre>
commit 615041f9996a0243e2ea3dec88dc42f64d9545d2
Author: danielsf <scott.f.daniel@gmail.com>
Date:   Fri May 8 10:17:06 2015 -0700

    removed the code that skips unit tests from the tests/SConscript
    
    added code to Persistence_2.py in tests/ that will simply exit
    without running any tests if the user does not have credentials
    for the necessary database
    
    added code to the C++ unit tests to exit without failing
    if the user does not have credentials to access the
    test database
    
    added comments explaining changes to unit test
</pre>
<h3><a name="f69b65eb"/></a>f69b65eb</h3>

<pre>
commit f69b65ebab9e2c985d935e21ee205bcf0b953a00
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Mar 28 01:07:49 2008 +0000

    Initial move of mwi/persistence to daf/persistence.
</pre>
</div>


[Return to list](#homelist)
# <a name="src/Storage.cc"/></a>src/Storage.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** \file
                 * \brief Implementation of Storage abstract base class
                 *
                 * \author $Author$
                 * \version $Revision$
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/Storage.h"
                
                #include <cerrno>
                #include <cstring>
                #include <sys/stat.h>
                #include <unistd.h>
                
                #include "lsst/pex/exceptions.h"
                #include "lsst/daf/persistence/StorageRegistry.h"
                
                namespace lsst {
                namespace daf {
                namespace persistence {
                
                /** Constructor.
                 * \param[in] type typeid() of subclass
                 */
                Storage::Storage(std::type_info const& type) : lsst::daf::base::Citizen(type) {
                }
                
                /** Minimal destructor
                  */
                Storage::~Storage(void) {
                }
                
                /** Create and configure a Storage subclass instance.
                 * \param[in] name Name of subclass
                 * \param[in] location Location to persist to or retrieve from
                 * \param[in] persist True if persisting, false if retrieving
                 * \param[in] policy Policy used to configure the Storage
                 * \return Shared pointer to Storage subclass instance
                 */
                Storage::Ptr Storage::createInstance(
                    std::string const& name, LogicalLocation const& location, bool persist,
                    lsst::pex::policy::Policy::Ptr policy) {
                    Storage::Ptr storage = StorageRegistry::getRegistry().createInstance(name);
                    storage->setPolicy(policy);
                    if (persist) {
                        storage->setPersistLocation(location);
                    }
                    else {
                        storage->setRetrieveLocation(location);
                    }
                    return storage;
                }
                
                /** Ensure that all directories along a path exist, creating them if
                 * necessary.
                 * \param[in] name Pathname to file to be created
                 */
                void Storage::verifyPathName(std::string const& name) {
                    // Get the directory by stripping off anything after the last slash.
                    std::string::size_type pos = name.find_last_of('/');
                    if (pos == std::string::npos) return;
                    std::string dirName = name.substr(0, pos);
                
                    // Check to see if the directory exists.
                    struct stat buf;
                    int ret = ::stat(dirName.c_str(), &buf);
                
                    if (ret == -1 && errno == ENOENT) {
                        // It doesn't; check its parent and then create it.
                        verifyPathName(dirName);
                
                        ret = ::mkdir(dirName.c_str(), 0777);
                
                        // If it already exists, we're OK; otherwise, throw an exception.
                        if (ret == -1 && errno != EEXIST) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#9966404e">9966404e</a> -             throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException,</div>
              ?                                                                  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#0c1dd2d0">0c1dd2d0</a> +             throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                                dirName + ": Error creating directory = " + std::strerror(errno));
                        }
                    }
                    else if (ret == -1) {
                        // We couldn't read the (existing) directory for some reason.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
117  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException,</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
117  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                            dirName + ": Error searching for directory = " + std::strerror(errno));
                    }
                    else if (!S_ISDIR(buf.st_mode)) {
                        // It's not a directory.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
122  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException,</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
122  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                            dirName + ": Non-directory in path");
                    }
                }
                
                }}} // namespace lsst::daf::persistence
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="9966404e"/></a>9966404e</h3>

<pre>
commit 9966404e8df345526d211ae57b1dc976149a8efd
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Dec 18 22:56:53 2008 +0000

    Merged revisions 6561-6817 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/persistence/tickets/492
    
    ........
      r6561 | ktlim | 2008-11-25 21:59:52 -0800 (Tue, 25 Nov 2008) | 2 lines
    
      Create branch for #492 (add PropertySetFormatter).
    ........
      r6712 | ktlim | 2008-12-09 19:35:00 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Replace DataPropertyFormatter with PropertySetFormatter.
    ........
      r6713 | ktlim | 2008-12-09 19:36:51 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change DataProperty to PropertySet.
    ........
      r6714 | ktlim | 2008-12-09 19:37:09 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change to new exceptions.
    ........
      r6715 | ktlim | 2008-12-09 19:37:25 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Add needed packages to table.
    ........
      r6732 | ktlim | 2008-12-13 15:31:12 -0800 (Sat, 13 Dec 2008) | 1 line
    
      Update tests to use PropertySet instead of DataProperty.
    ........
      r6739 | ktlim | 2008-12-14 15:00:54 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update build files to more modern structures.
    ........
      r6740 | ktlim | 2008-12-14 15:01:59 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update to more modern .i structure.
    ........
      r6763 | ktlim | 2008-12-15 15:53:26 -0800 (Mon, 15 Dec 2008) | 1 line
    
      Fix standards incompatibility detected by gcc4.
    ........
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="tests/SConscript"/></a>tests/SConscript
### Diff:

<pre>
                # -*- python -*-
                from lsst.sconsUtils import scripts
                import os
                
                ignoreList = ["cameraMapper.py", "pickleMapper.py"]
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#0d6e751f">0d6e751f</a> - if not os.path.exists(os.path.join(os.environ['HOME'], ".lsst/db-auth.paf")):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
7    <a href="#bc76d5ee">bc76d5ee</a> -     ignoreList.extend(["DateTime_1", "DbStorage_1", "DbStorage_1.py", "DbStorage_2.py",</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
8    <a href="#bc76d5ee">bc76d5ee</a> -                        "Persistence_1", "Persistence_2", "Persistence_2.py"])</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
9    <a href="#f69b65eb">f69b65eb</a> -     print "WARNING: No fallback database authenticator seen"</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
10   <a href="#f69b65eb">f69b65eb</a> -     print "Database tests are being skipped"</div>
                
                scripts.BasicSConscript.tests(ignoreList=ignoreList)
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="0d6e751f"/></a>0d6e751f</h3>

<pre>
commit 0d6e751f8d2378a6707fb5f33f30715e88e7b7b1
Author: jbosch <jbosch@git.lsstcorp.org>
Date:   Thu Oct 13 18:52:58 2011 +0000

    daf_persistence #1780 - added daf_persistence, fixed problems with --check
    Dependencies, cleaned up Doxygen comments a bit
</pre>
<h3><a name="bc76d5ee"/></a>bc76d5ee</h3>

<pre>
commit bc76d5ee4403dd8665879d26213c8075b3b21d47
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Oct 11 11:45:40 2012 -0400

    update SConscript to avoid running module in test dir
</pre>
<h3><a name="f69b65eb"/></a>f69b65eb</h3>

<pre>
commit f69b65ebab9e2c985d935e21ee205bcf0b953a00
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Mar 28 01:07:49 2008 +0000

    Initial move of mwi/persistence to daf/persistence.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
</div>


[Return to list](#homelist)
# <a name=".gitignore"/></a>.gitignore
### Diff:

<pre>
                .sconsign.dblite
                config.log
                .sconf_temp
                *.dylib
                *.o
                *.os
                *.so
                *.cfgc
                *.pyc
                *_wrap.cc
                *Lib.py
                doc/html
                doc/*.tag
                doc/*.inc
                doc/doxygen.conf
                tests/.tests
                version.py
                foo1.pickle
                foo3.pickle
                flat_R1,1_S2,2_C0,0_E000.pickle
                flat_R1,1_S2,2_C0,0_E001.pickle
                flat_R1,1_S2,2_C0,1_E000.pickle
                flat_R1,1_S2,2_C1,0_E001.pickle
                flat_R1,1_S2,2_C1,1_E000.pickle
                flat_R1,2_S2,1_C0,0_E001.pickle
                flat_R1,2_S2,2_C0,0_E000.pickle
                tests/DbStorage_1
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
28   <a href="#5ffdc6c3">5ffdc6c3</a> + tests/FitsStorage_1</div>
                tests/FormatterRegistry_1
                tests/Persistence_1
                tests/Persistence_2
                tests/Persistence_3
                tests/PropertySetPersist
                tests/PropertySet_2
                tests/data
                tests/root/out
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="5ffdc6c3"/></a>5ffdc6c3</h3>

<pre>
commit 5ffdc6c3579b3ba692df3aacb26b316e0fc110ce
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Thu Mar 27 04:11:13 2014 -0500

    Add a test for FitsStorage.
</pre>
</div>


[Return to list](#homelist)
# <a name="src/PropertySetFormatter.cc"/></a>src/PropertySetFormatter.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
3    <a href="#ccd7f88e">ccd7f88e</a> - /* </div>
              ?   -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
3    <a href="#c07b65e7">c07b65e7</a> + /*</div>
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#ccd7f88e">ccd7f88e</a> -  * </div>
              ?   -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#c07b65e7">c07b65e7</a> +  *</div>
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
14   <a href="#ccd7f88e">ccd7f88e</a> -  * </div>
              ?   -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
14   <a href="#c07b65e7">c07b65e7</a> +  *</div>
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
19   <a href="#ccd7f88e">ccd7f88e</a> -  * </div>
              ?   -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
19   <a href="#c07b65e7">c07b65e7</a> +  *</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
20   <a href="#ccd7f88e">ccd7f88e</a> -  * You should have received a copy of the LSST License Statement and </div>
              ?                                                                     -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
20   <a href="#c07b65e7">c07b65e7</a> +  * You should have received a copy of the LSST License Statement and</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
21   <a href="#ccd7f88e">ccd7f88e</a> -  * the GNU General Public License along with this program.  If not, </div>
              ?                                                                    -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
21   <a href="#c07b65e7">c07b65e7</a> +  * the GNU General Public License along with this program.  If not,</div>
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
24   <a href="#ccd7f88e">ccd7f88e</a> -  </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
24   <a href="#c07b65e7">c07b65e7</a> + </div>
                
                
                /** \file
                 * \brief Implementation of PropertySetFormatter class
                 *
                 * \version $Revision: 2151 $
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/PropertySetFormatter.h"
                
                #include <sstream>
                #include <stdexcept>
                #include <string>
                #include <vector>
                
                #include <boost/serialization/nvp.hpp>
                #include <boost/serialization/shared_ptr.hpp>
                #include <boost/serialization/vector.hpp>
                
                #include <lsst/daf/base/PropertySet.h>
                #include "lsst/daf/base/DateTime.h"
                #include "lsst/daf/persistence/FormatterImpl.h"
                #include "lsst/daf/persistence/LogicalLocation.h"
                #include "lsst/daf/persistence/BoostStorage.h"
                #include "lsst/daf/persistence/DbStorage.h"
                #include "lsst/daf/persistence/XmlStorage.h"
                #include <lsst/pex/exceptions.h>
                #include <lsst/pex/logging/Trace.h>
                #include <lsst/pex/policy/Policy.h>
                
                
                #define EXEC_TRACE  20
                static void execTrace(std::string s, int level = EXEC_TRACE) {
                    lsst::pex::logging::Trace("daf.persistence.PropertySetFormatter", level, s);
                }
                
                namespace dafBase = lsst::daf::base;
                namespace dafPersist = lsst::daf::persistence;
                namespace pexPolicy = lsst::pex::policy;
                
                using boost::serialization::make_nvp;
                
                /** Register this Formatter subclass through a static instance of
                 * FormatterRegistration.
                 */
                dafPersist::FormatterRegistration
                dafPersist::PropertySetFormatter::registration("PropertySet",
                                                               typeid(dafBase::PropertySet),
                                                               createInstance);
                
                /** Constructor.
                 * \param[in] policy Policy for configuring this Formatter
                 */
                dafPersist::PropertySetFormatter::PropertySetFormatter(
                    pexPolicy::Policy::Ptr policy) :
                    dafPersist::Formatter(typeid(*this)), _policy(policy) {
                }
                
                /** Minimal destructor.
                 */
                dafPersist::PropertySetFormatter::~PropertySetFormatter(void) {
                }
                
                void dafPersist::PropertySetFormatter::write(
                    dafBase::Persistable const* persistable,
                    dafPersist::Storage::Ptr storage,
                    dafBase::PropertySet::Ptr additionalData) {
                    execTrace("PropertySetFormatter write start");
                    dafBase::PropertySet const* ps =
                        dynamic_cast<dafBase::PropertySet const*>(persistable);
                    if (ps == 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
106  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, "Persisting non-PropertySet");</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
106  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError, "Persisting non-PropertySet");</div>
                    }
                    if (typeid(*storage) == typeid(dafPersist::BoostStorage)) {
                        execTrace("PropertySetFormatter write BoostStorage");
                        dafPersist::BoostStorage* boost =
                            dynamic_cast<dafPersist::BoostStorage*>(storage.get());
                        boost->getOArchive() & *ps;
                        execTrace("PropertySetFormatter write end");
                        return;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::XmlStorage)) {
                        execTrace("PropertySetFormatter write XmlStorage");
                        dafPersist::XmlStorage* xml =
                            dynamic_cast<dafPersist::XmlStorage*>(storage.get());
                        xml->getOArchive() & make_nvp("propertySet", *ps);
                        execTrace("PropertySetFormatter write end");
                        return;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::DbStorage)) {
                        execTrace("PropertySetFormatter write DbStorage");
                        dafPersist::DbStorage* db =
                            dynamic_cast<dafPersist::DbStorage*>(storage.get());
                
                        std::string itemName = additionalData->getAsString("itemName");
                        std::string tableName = itemName;
                        pexPolicy::Policy::Ptr itemPolicy;
                        if (_policy && _policy->exists(itemName)) {
                            itemPolicy = _policy->getPolicy(itemName);
                            if (itemPolicy->exists("TableName")) {
                                tableName = itemPolicy->getString("TableName");
                            }
                        }
                        db->setTableForInsert(tableName);
                
                        std::vector<std::string> list;
                        if (itemPolicy && itemPolicy->exists("KeyList")) {
                            pexPolicy::Policy::StringArray const& array(
                                itemPolicy->getStringArray("KeyList"));
                            for (pexPolicy::Policy::StringArray::const_iterator it =
                                 array.begin(); it != array.end(); ++it) {
                                list.push_back(*it);
                            }
                        }
                        else {
                            list = ps->paramNames(false);
                        }
                
                        for (std::vector<std::string>::const_iterator it = list.begin();
                             it != list.end(); ++it) {
                            std::string::size_type split = it->find('=');
                            std::string colName;
                            std::string key;
                            if (split == std::string::npos) {
                                colName = key = *it;
                            }
                            else {
                                colName = it->substr(0, split);
                                key = it->substr(split + 1);
                            }
                
                            if (!ps->exists(key)) {
                                db->setColumnToNull(colName);
                                continue;
                            }
                
                            std::type_info const& type(ps->typeOf(key));
                
                            if (type == typeid(bool)) {
                                db->setColumn<bool>(colName, ps->get<bool>(key));
                            }
                            else if (type == typeid(char)) {
                                db->setColumn<char>(colName, ps->get<char>(key));
                            }
                            else if (type == typeid(short)) {
                                db->setColumn<short>(colName, ps->get<short>(key));
                            }
                            else if (type == typeid(int)) {
                                db->setColumn<int>(colName, ps->get<int>(key));
                            }
                            else if (type == typeid(long)) {
                                db->setColumn<long>(colName, ps->get<long>(key));
                            }
                            else if (type == typeid(long long)) {
                                db->setColumn<long long>(colName, ps->get<long long>(key));
                            }
                            else if (type == typeid(float)) {
                                db->setColumn<float>(colName, ps->get<float>(key));
                            }
                            else if (type == typeid(double)) {
                                db->setColumn<double>(colName, ps->get<double>(key));
                            }
                            else if (type == typeid(std::string)) {
                                db->setColumn<std::string>(colName, ps->get<std::string>(key));
                            }
                            else if (type == typeid(dafBase::DateTime)) {
                                db->setColumn<dafBase::DateTime>(
                                    colName, ps->get<dafBase::DateTime>(key));
                            }
                            else {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
205  <a href="#9966404e">9966404e</a> -                 throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, </div>
              ?                                                                      --------- -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
205  <a href="#c07b65e7">c07b65e7</a> +                 throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                                    std::string("Unknown type ") + type.name() +
                                    " in PropertySetFormatter write");
                            }
                        }
                        db->insertRow();
                        execTrace("PropertySetFormatter write end");
                        return;
                    }
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
215  <a href="#9966404e">9966404e</a> -     throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, "Unrecognized Storage for PropertySet");</div>
              ?                                                          ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
215  <a href="#0c1dd2d0">0c1dd2d0</a> +     throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError, "Unrecognized Storage for PropertySet");</div>
                }
                
                dafBase::Persistable* dafPersist::PropertySetFormatter::read(
                    dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    execTrace("PropertySetFormatter read start");
                    dafBase::PropertySet* ps = new dafBase::PropertySet;
                    if (typeid(*storage) == typeid(dafPersist::BoostStorage)) {
                        execTrace("PropertySetFormatter read BoostStorage");
                        dafPersist::BoostStorage* boost =
                            dynamic_cast<dafPersist::BoostStorage*>(storage.get());
                        boost->getIArchive() & *ps;
                        execTrace("PropertySetFormatter read end");
                        return ps;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::XmlStorage)) {
                        execTrace("PropertySetFormatter read XmlStorage");
                        dafPersist::XmlStorage* xml =
                            dynamic_cast<dafPersist::XmlStorage*>(storage.get());
                        xml->getIArchive() & make_nvp("propertySet", *ps);
                        execTrace("PropertySetFormatter read end");
                        return ps;
                    }
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
238  <a href="#9966404e">9966404e</a> -     throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, "Unrecognized Storage for PropertySet");</div>
              ?                                                          ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
238  <a href="#0c1dd2d0">0c1dd2d0</a> +     throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError, "Unrecognized Storage for PropertySet");</div>
                }
                
                void dafPersist::PropertySetFormatter::update(dafBase::Persistable* persistable,
                                                   dafPersist::Storage::Ptr storage,
                                                   dafBase::PropertySet::Ptr additionalData) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
244  <a href="#9966404e">9966404e</a> -     throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, "Unexpected call to update for PropertySet");</div>
              ?                                                          ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
244  <a href="#0c1dd2d0">0c1dd2d0</a> +     throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError, "Unexpected call to update for PropertySet");</div>
                }
                
                /** Factory method for PropertySetFormatter.
                 * \param[in] policy Policy for configuring the PropertySetFormatter
                 * \return Shared pointer to a new instance
                 */
                dafPersist::Formatter::Ptr dafPersist::PropertySetFormatter::createInstance(
                    pexPolicy::Policy::Ptr policy) {
                    return dafPersist::Formatter::Ptr(new dafPersist::PropertySetFormatter(policy));
                }
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="ccd7f88e"/></a>ccd7f88e</h3>

<pre>
commit ccd7f88e1922d491673d3b038c9a69755691bfbe
Author: dgehrig <dgehrig@git.lsstcorp.org>
Date:   Mon Jul 12 00:06:35 2010 +0000

    adding copyright notices
</pre>
<h3><a name="9966404e"/></a>9966404e</h3>

<pre>
commit 9966404e8df345526d211ae57b1dc976149a8efd
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Dec 18 22:56:53 2008 +0000

    Merged revisions 6561-6817 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/persistence/tickets/492
    
    ........
      r6561 | ktlim | 2008-11-25 21:59:52 -0800 (Tue, 25 Nov 2008) | 2 lines
    
      Create branch for #492 (add PropertySetFormatter).
    ........
      r6712 | ktlim | 2008-12-09 19:35:00 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Replace DataPropertyFormatter with PropertySetFormatter.
    ........
      r6713 | ktlim | 2008-12-09 19:36:51 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change DataProperty to PropertySet.
    ........
      r6714 | ktlim | 2008-12-09 19:37:09 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change to new exceptions.
    ........
      r6715 | ktlim | 2008-12-09 19:37:25 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Add needed packages to table.
    ........
      r6732 | ktlim | 2008-12-13 15:31:12 -0800 (Sat, 13 Dec 2008) | 1 line
    
      Update tests to use PropertySet instead of DataProperty.
    ........
      r6739 | ktlim | 2008-12-14 15:00:54 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update build files to more modern structures.
    ........
      r6740 | ktlim | 2008-12-14 15:01:59 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update to more modern .i structure.
    ........
      r6763 | ktlim | 2008-12-15 15:53:26 -0800 (Mon, 15 Dec 2008) | 1 line
    
      Fix standards incompatibility detected by gcc4.
    ........
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="c07b65e7"/></a>c07b65e7</h3>

<pre>
commit c07b65e79d3904bc7672569d1178870c291ccf08
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 25 15:55:11 2014 -0700

    Respond to K-T's review by removing trailing whitespace in two files.
</pre>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="src/FormatterRegistry.cc"/></a>src/FormatterRegistry.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** \file
                 * \brief Implementation of FormatterRegistry class.
                 *
                 * \author $Author: ktlim $
                 * \version $Revision: 2233 $
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/FormatterRegistry.h"
                
                #include "lsst/pex/exceptions.h"
                
                namespace lsst {
                namespace daf {
                namespace persistence {
                
                /** Get a reference to the singleton instance of the FormatterRegistry.
                 * \return Reference to the singleton
                 *
                 * Uses function-scoped static to ensure proper initialization.
                 */
                FormatterRegistry& FormatterRegistry::getInstance(void) {
                    static FormatterRegistry* registry = new FormatterRegistry;
                    return *registry;
                }
                
                /** Register a factory for a Formatter subclass using the name and type of the
                 * Persistable subclass it formats.
                 * \param[in] persistableName Name of the Persistable subclass
                 * \param[in] persistableType typeid() of the Persistable subclass
                 * \param[in] factory Factory function for the Formatter, taking a Policy
                 */
                void FormatterRegistry::registerFormatter(
                    std::string const& persistableName, std::type_info const& persistableType,
                    Formatter::FactoryPtr factory) {
                    _byName.insert(FactoryMap::value_type(persistableName, factory));
                    _nameForType.insert(StringMap::value_type(persistableType.name(),
                                                              persistableName));
                }
                
                /** Create a new instance of a Formatter subclass given the typeid() of its
                 * corresponding Persistable subclass.
                 * \param[in] persistableType typeid() of the Persistable subclass
                 * \param[in] policy Policy containing all Formatter policies
                 * \return Shared pointer to an instance of the subclass
                 */
                Formatter::Ptr FormatterRegistry::lookupFormatter(
                    std::type_info const& persistableType,
                    lsst::pex::policy::Policy::Ptr policy) {
                    StringMap::const_iterator it = _nameForType.find(persistableType.name());
                    if (it == _nameForType.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
86   <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::InvalidParameterException,</div>
              ?                                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
86   <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::InvalidParameterError,</div>
              ?                                                                   ^^ ^
                            std::string("No Formatter registered for Persistable type: ") +
                            persistableType.name());
                    }
                    return lookupFormatter(it->second, policy);
                }
                
                /** Create a new instance of a Formatter subclass given the string name of its
                 * corresponding Persistable subclass.
                 * \param[in] persistableName Name of the Persistable subclass
                 * \param[in] policy Policy containing all Formatter policies
                 * \return Shared pointer to an instance of the subclass
                 */
                Formatter::Ptr FormatterRegistry::lookupFormatter(
                    std::string const& persistableName,
                    lsst::pex::policy::Policy::Ptr policy) {
                    FactoryMap::const_iterator it = _byName.find(persistableName);
                    if (it == _byName.end()) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
104  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::InvalidParameterException,</div>
              ?                                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
104  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::InvalidParameterError,</div>
              ?                                                                   ^^ ^
                            "No Formatter registered for Persistable name: " +
                            persistableName);
                    }
                    lsst::pex::policy::Policy::Ptr formatterPolicy;
                    if (policy && policy->exists(persistableName)) {
                        formatterPolicy = policy->getPolicy(persistableName);
                    }
                    return (*(it->second))(formatterPolicy);
                }
                
                /** Default constructor.
                 */
                FormatterRegistry::FormatterRegistry(void) :
                    lsst::daf::base::Citizen(typeid(*this)) {
                    markPersistent();
                }
                
                /** Minimal destructor.
                 */
                FormatterRegistry::~FormatterRegistry(void) {
                }
                
                }}} // namespace lsst::daf::persistence
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="9966404e"/></a>9966404e</h3>

<pre>
commit 9966404e8df345526d211ae57b1dc976149a8efd
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Dec 18 22:56:53 2008 +0000

    Merged revisions 6561-6817 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/persistence/tickets/492
    
    ........
      r6561 | ktlim | 2008-11-25 21:59:52 -0800 (Tue, 25 Nov 2008) | 2 lines
    
      Create branch for #492 (add PropertySetFormatter).
    ........
      r6712 | ktlim | 2008-12-09 19:35:00 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Replace DataPropertyFormatter with PropertySetFormatter.
    ........
      r6713 | ktlim | 2008-12-09 19:36:51 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change DataProperty to PropertySet.
    ........
      r6714 | ktlim | 2008-12-09 19:37:09 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change to new exceptions.
    ........
      r6715 | ktlim | 2008-12-09 19:37:25 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Add needed packages to table.
    ........
      r6732 | ktlim | 2008-12-13 15:31:12 -0800 (Sat, 13 Dec 2008) | 1 line
    
      Update tests to use PropertySet instead of DataProperty.
    ........
      r6739 | ktlim | 2008-12-14 15:00:54 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update build files to more modern structures.
    ........
      r6740 | ktlim | 2008-12-14 15:01:59 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update to more modern .i structure.
    ........
      r6763 | ktlim | 2008-12-15 15:53:26 -0800 (Mon, 15 Dec 2008) | 1 line
    
      Fix standards incompatibility detected by gcc4.
    ........
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="tests/FormatterRegistry_1.cc"/></a>tests/FormatterRegistry_1.cc
### Diff:

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * \file FormatterRegistry_1.cc
                 *
                 * This test tests the FormatterRegistry class.
                 */
                #include <sstream>
                #include <string>
                #include "lsst/daf/base/Persistable.h"
                #include "lsst/daf/persistence/FormatterRegistry.h"
                #include "lsst/pex/exceptions.h"
                
                #define BOOST_TEST_MODULE FormatterRegistry_1
                #define BOOST_TEST_DYN_LINK
                #include "boost/test/unit_test.hpp"
                
                namespace test = boost::test_tools;
                namespace dafBase = lsst::daf::base;
                namespace dafPersist = lsst::daf::persistence;
                
                // A (very) minimal Persistable.
                class MyPersistable : public dafBase::Persistable {
                };
                
                // A minimal Formatter.
                class MyFormatter : public dafPersist::Formatter {
                public:
                    MyFormatter(void) : dafPersist::Formatter(typeid(*this)) { };
                    // Normally, the following functions would do something.  For testing,
                    // they do nothing.
                    virtual void write(dafBase::Persistable const* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) { };
                    virtual dafBase::Persistable* read(dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) { return 0; };
                    virtual void update(dafBase::Persistable* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) { };
                private:
                    static dafPersist::Formatter::Ptr createInstance(lsst::pex::policy::Policy::Ptr policy);
                    static dafPersist::FormatterRegistration registration;
                };
                
                // Register the formatter factory function.
                dafPersist::FormatterRegistration MyFormatter::registration("MyPersistable", typeid(MyPersistable), createInstance);
                
                dafPersist::Formatter::Ptr MyFormatter::createInstance(lsst::pex::policy::Policy::Ptr policy) {
                    return dafPersist::Formatter::Ptr(new MyFormatter);
                }
                
                // Another minimal Formatter, this time without registration and an external
                // factory function.  This is not the normal way of writing Formatters; it is
                // here for test purposes only.
                class YourFormatter : public dafPersist::Formatter {
                public:
                    YourFormatter(void) : dafPersist::Formatter(typeid(*this)) { };
                    virtual void write(dafBase::Persistable const* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) { };
                    virtual dafBase::Persistable* read(dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) { return 0; };
                    virtual void update(dafBase::Persistable* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) { };
                };
                
                // External factory function for YourFormatters.  This would normally be a
                // static member function as for MyFormatter above.
                static dafPersist::Formatter::Ptr factory(lsst::pex::policy::Policy::Ptr policy) {
                    return dafPersist::Formatter::Ptr(new YourFormatter);
                }
                
                BOOST_AUTO_TEST_SUITE(FormatterRegistrySuite)
                
                BOOST_AUTO_TEST_CASE(FormatterRegistry1) {
                    dafPersist::FormatterRegistry& f(dafPersist::FormatterRegistry::getInstance());
                    dafPersist::Formatter::FactoryPtr p = factory;
                    lsst::pex::policy::Policy::Ptr policy(new lsst::pex::policy::Policy);
                
                    // These tests are to ensure that the basic functionality of the
                    // FormatterRegistry is working.  They do not represent the normal method
                    // of using the registry and are here for test purposes only.  In
                    // particular, registering a Formatter for a built-in type does not make
                    // any sense (but cannot be prevented without a lot of extra work).
                    f.registerFormatter("YourPersistable", typeid(int), p);
                    dafPersist::Formatter::Ptr fp = dafPersist::Formatter::lookupFormatter(typeid(int), policy);
                    BOOST_CHECK_MESSAGE(typeid(*fp) == typeid(YourFormatter), "Didn't get YourFormatter");
                    dafPersist::Formatter::Ptr fp2 = dafPersist::Formatter::lookupFormatter("YourPersistable", policy);
                    BOOST_CHECK_MESSAGE(typeid(*fp2) == typeid(YourFormatter), "Didn't get YourFormatter");
                    BOOST_CHECK_MESSAGE(fp != fp2, "Old YourFormatter returned");
                
                    // This is the normal way of using FormatterRegistry (i.e. implicitly
                    // through Formatter and static FormatterRegistration members).
                    dafPersist::Formatter::Ptr fp3 = dafPersist::Formatter::lookupFormatter("MyPersistable", policy);
                    BOOST_CHECK_MESSAGE(typeid(*fp3) == typeid(MyFormatter), "Didn't get MyFormatter");
                    BOOST_CHECK_MESSAGE(fp != fp3 && fp2 != fp3, "Old MyFormatter returned");
                    dafPersist::Formatter::Ptr fp4 = dafPersist::Formatter::lookupFormatter(typeid(MyPersistable), policy);
                    BOOST_CHECK_MESSAGE(typeid(*fp4) == typeid(MyFormatter), "Didn't get MyFormatter");
                    BOOST_CHECK_MESSAGE(fp != fp4 && fp2 != fp4 && fp3 != fp4, "Old MyFormatter returned");
                
                    // These tests look at failure cases, where we try to find a Formatter
                    // that doesn't exist.  This should cause an InvalidParameter exception to
                    // be thrown.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#1a405fa7">1a405fa7</a> -     BOOST_CHECK_THROW(dafPersist::Formatter::lookupFormatter("FooBar", policy), lsst::pex::exceptions::InvalidParameterException);</div>
              ?                                                                                                                         ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#0c1dd2d0">0c1dd2d0</a> +     BOOST_CHECK_THROW(dafPersist::Formatter::lookupFormatter("FooBar", policy), lsst::pex::exceptions::InvalidParameterError);</div>
              ?                                                                                                                         ^^ ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
116  <a href="#1a405fa7">1a405fa7</a> -     BOOST_CHECK_THROW(dafPersist::Formatter::lookupFormatter(typeid(double), policy), lsst::pex::exceptions::InvalidParameterException);</div>
              ?                                                                                                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
116  <a href="#0c1dd2d0">0c1dd2d0</a> +     BOOST_CHECK_THROW(dafPersist::Formatter::lookupFormatter(typeid(double), policy), lsst::pex::exceptions::InvalidParameterError);</div>
              ?                                                                                                                               ^^ ^
                }
                
                BOOST_AUTO_TEST_SUITE_END()
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="1a405fa7"/></a>1a405fa7</h3>

<pre>
commit 1a405fa7e09c6d733635e74ae7fa4db0eec5b90d
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Jan 23 20:40:09 2009 +0000

    Finish updating to boost::test.  Standardize namespace abbreviation.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="tests/DbStorage_1.cc"/></a>tests/DbStorage_1.cc
### Diff:

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * \file DbStorage_1.cc
                 *
                 * This test tests the DbStorage class.
                 */
                #include <sstream>
                #include <string>
                #include <sys/time.h>
                #include "lsst/daf/persistence/DbStorage.h"
                #include "lsst/daf/persistence/LogicalLocation.h"
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
33   <a href="#615041f9">615041f9</a> + #include "lsst/daf/persistence/DbAuth.h"</div>
                #include "lsst/pex/exceptions.h"
                
                #define BOOST_TEST_MODULE DbStorage_1
                #define BOOST_TEST_DYN_LINK
                #include "boost/test/unit_test.hpp"
                
                namespace test = boost::test_tools;
                namespace dafPersist = lsst::daf::persistence;
                
                BOOST_AUTO_TEST_SUITE(DbStorageSuite)
                
                BOOST_AUTO_TEST_CASE(DbStorage) {
                    lsst::pex::policy::Policy::Ptr policy(new lsst::pex::policy::Policy);
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
47   <a href="#f69b65eb">f69b65eb</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
48   <a href="#615041f9">615041f9</a> +     //If the user cannot access the test database, exit</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
49   <a href="#615041f9">615041f9</a> +     //without failing</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
50   <a href="#615041f9">615041f9</a> +     dafPersist::DbAuth testAuth;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
51   <a href="#615041f9">615041f9</a> +     testAuth.setPolicy(policy);</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
52   <a href="#615041f9">615041f9</a> +     if(!testAuth.available("lsst10.ncsa.uiuc.edu","3306")){</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
53   <a href="#615041f9">615041f9</a> +         return;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
54   <a href="#615041f9">615041f9</a> +     }</div>
                
                    struct timeval tv;
                    gettimeofday(&tv, 0); 
                    long long testId = tv.tv_sec * 1000000LL + tv.tv_usec;
                    std::ostringstream os;
                    os << "DbStorage_Test_N_" << testId;
                    std::string tempTableName = os.str();
                
                    // Normally, we would create a DbStorage via
                    // Persistence::getPersistStorage().  For testing purposes, we create one
                    // ourselves.
                    dafPersist::DbStorage dbs;
                
                    dbs.setPolicy(policy);
                    dafPersist::LogicalLocation loc("mysql://lsst10.ncsa.uiuc.edu:3306/test");
                    dbs.setPersistLocation(loc);
                
                    dbs.startTransaction();
                    dbs.createTableFromTemplate(tempTableName, "DbStorage_Test_1");
                    dbs.endTransaction();
                
                    dbs.startTransaction();
                    dbs.truncateTable(tempTableName);
                    dbs.endTransaction();
                
                    dbs.startTransaction();
                    dbs.dropTable(tempTableName);
                    dbs.endTransaction();
                
                    dbs.startTransaction();
                    dbs.setTableForInsert("DbStorage_Test_1");
                    dbs.setColumn<long long>("id", testId);
                    dbs.setColumn<double>("ra", 3.14159);
                    dbs.setColumn<double>("decl", 2.71828);
                    dbs.setColumnToNull("something");
                    dbs.insertRow();
                    dbs.endTransaction();
                    // Everything is OK as long as we didn't throw an exception above.
                
                    // Normally, DbStorages are not reused.  There is no reason they cannot
                    // be, however.
                    dbs.setRetrieveLocation(loc);
                    dbs.startTransaction();
                    dbs.setTableForQuery("DbStorage_Test_1");
                    dbs.condParam<long long>("id", testId);
                    dbs.setQueryWhere("id = :id");
                    dbs.outColumn("decl");
                    dbs.outColumn("DbStorage_Test_1.something");
                    dbs.outColumn("ra");
                
                    dbs.query();
                
                    BOOST_CHECK_MESSAGE(dbs.next() == true, "Failed to get row");
                    BOOST_CHECK_MESSAGE(dbs.columnIsNull(0) == false, "Null decl column");
                    BOOST_CHECK_MESSAGE(dbs.columnIsNull(1) == true, "Non-null something column");
                    BOOST_CHECK_MESSAGE(dbs.columnIsNull(2) == false, "Null ra column");
                    double ra = dbs.getColumnByPos<double>(2);
                    BOOST_CHECK_MESSAGE(ra == 3.14159, "RA is incorrect");
                    double decl = dbs.getColumnByPos<double>(0);
                    BOOST_CHECK_MESSAGE(decl == 2.71828, "Decl is incorrect");
                    BOOST_CHECK_MESSAGE(dbs.next() == false, "Got more than one row");
                
                    dbs.finishQuery();
                    dbs.endTransaction();
                
                    // Let's do that query again, this time using bound variables.
                    dbs.setRetrieveLocation(loc);
                    dbs.startTransaction();
                    dbs.setTableForQuery("DbStorage_Test_1");
                    dbs.condParam<long long>("id", testId);
                    dbs.setQueryWhere("id = :id");
                    dbs.outParam("decl", &decl);
                    int junk;
                    dbs.outParam("something", &junk);
                    dbs.outParam("ra", &ra);
                
                    dbs.query();
                
                    BOOST_CHECK_MESSAGE(dbs.next() == true, "Failed to get row");
                    BOOST_CHECK_MESSAGE(dbs.columnIsNull(0) == false, "Null decl column");
                    BOOST_CHECK_MESSAGE(dbs.columnIsNull(1) == true, "Non-null something column");
                    BOOST_CHECK_MESSAGE(dbs.columnIsNull(2) == false, "Null ra column");
                    BOOST_CHECK_MESSAGE(ra == 3.14159, "RA is incorrect");
                    BOOST_CHECK_MESSAGE(decl == 2.71828, "Decl is incorrect");
                    BOOST_CHECK_MESSAGE(dbs.next() == false, "Got more than one row");
                
                    dbs.finishQuery();
                    dbs.endTransaction();
                }
                
                BOOST_AUTO_TEST_CASE(DbStorageExprs) {
                    lsst::pex::policy::Policy::Ptr policy(new lsst::pex::policy::Policy);
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
148  <a href="#615041f9">615041f9</a> +     //If the user cannot access the test database, exit</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
149  <a href="#615041f9">615041f9</a> +     //without failing</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
150  <a href="#615041f9">615041f9</a> +     dafPersist::DbAuth testAuth;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
151  <a href="#615041f9">615041f9</a> +     testAuth.setPolicy(policy);</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
152  <a href="#615041f9">615041f9</a> +     if(!testAuth.available("lsst10.ncsa.uiuc.edu","3306")){</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
153  <a href="#615041f9">615041f9</a> +         return;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
154  <a href="#615041f9">615041f9</a> +     }</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
155  <a href="#615041f9">615041f9</a> + </div>
                    // Normally, we would create a DbStorage via
                    // Persistence::getRetrieveStorage().  For testing purposes, we create one
                    // ourselves.
                    dafPersist::DbStorage dbs;
                
                    dbs.setPolicy(policy);
                    dafPersist::LogicalLocation loc("mysql://lsst10.ncsa.uiuc.edu:3306/test");
                    dbs.setRetrieveLocation(loc);
                
                    dbs.startTransaction();
                    dbs.setTableForQuery("DUAL", true);
                    dbs.outColumn("1 + 1", true);
                    dbs.query();
                
                    BOOST_CHECK_MESSAGE(dbs.next() == true, "Failed to get row");
                    BOOST_CHECK_MESSAGE(dbs.columnIsNull(0) == false, "Null output column");
                    int result = dbs.getColumnByPos<int>(0);
                    BOOST_CHECK_MESSAGE(result == 2, "Result is incorrect");
                    BOOST_CHECK_MESSAGE(dbs.next() == false, "Got more than one row");
                
                    dbs.finishQuery();
                    dbs.endTransaction();
                
                    dbs.startTransaction();
                    dbs.setTableForQuery("DUAL", true);
                    result = 0;
                    dbs.outParam("2 + 2", &result, true);
                    dbs.query();
                
                    BOOST_CHECK_MESSAGE(dbs.next() == true, "Failed to get row");
                    BOOST_CHECK_MESSAGE(dbs.columnIsNull(0) == false, "Null output column");
                    BOOST_CHECK_MESSAGE(result == 4, "Result is incorrect");
                    BOOST_CHECK_MESSAGE(dbs.next() == false, "Got more than one row");
                
                    dbs.finishQuery();
                    dbs.endTransaction();
                }
                
                BOOST_AUTO_TEST_SUITE_END()
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="615041f9"/></a>615041f9</h3>

<pre>
commit 615041f9996a0243e2ea3dec88dc42f64d9545d2
Author: danielsf <scott.f.daniel@gmail.com>
Date:   Fri May 8 10:17:06 2015 -0700

    removed the code that skips unit tests from the tests/SConscript
    
    added code to Persistence_2.py in tests/ that will simply exit
    without running any tests if the user does not have credentials
    for the necessary database
    
    added code to the C++ unit tests to exit without failing
    if the user does not have credentials to access the
    test database
    
    added comments explaining changes to unit test
</pre>
<h3><a name="f69b65eb"/></a>f69b65eb</h3>

<pre>
commit f69b65ebab9e2c985d935e21ee205bcf0b953a00
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Mar 28 01:07:49 2008 +0000

    Initial move of mwi/persistence to daf/persistence.
</pre>
</div>


[Return to list](#homelist)
# <a name="src/DbStorageImpl.cc"/></a>src/DbStorageImpl.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** @file
                 * @brief Implementation of DbStorageImpl class
                 *
                 * Uses MySQL C API directly.
                 *
                 * @author $Author$
                 * @version $Revision$
                 * @date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * @ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/DbStorageImpl.h"
                #include "boost/regex.hpp"
                #include <ctime>
                #include <iostream>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
49   <a href="#f80e148c">f80e148c</a> + #include <sstream></div>
                #include <stdlib.h>
                #include <unistd.h>
                #include <vector>
                
                #include <mysql/mysql.h>
                
                #include "lsst/pex/exceptions.h"
                #include "lsst/pex/logging/Trace.h"
                #include "lsst/daf/persistence/DbStorageLocation.h"
                #include "lsst/daf/persistence/LogicalLocation.h"
                #include "lsst/daf/base/DateTime.h"
                
                namespace dafPer = lsst::daf::persistence;
                namespace dafBase = lsst::daf::base;
                namespace pexExcept = lsst::pex::exceptions;
                namespace pexPolicy = lsst::pex::policy;
                
                namespace lsst {
                namespace daf {
                namespace persistence {
                
                template <size_t N>
                struct IntegerTypeTraits {
                public:
                    static enum_field_types mysqlType;
                };
                
                template <typename T>
                struct BoundVarTraits {
                public:
                    static enum_field_types mysqlType;
                    static bool isUnsigned;
                };
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
84   <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
85   <a href="#a0127c4a">a0127c4a</a> +     IntegerTypeTraits<1>::mysqlType = MYSQL_TYPE_TINY;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
86   <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#a0127c4a">a0127c4a</a> +     IntegerTypeTraits<2>::mysqlType = MYSQL_TYPE_SHORT;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
88   <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
89   <a href="#a0127c4a">a0127c4a</a> +     IntegerTypeTraits<4>::mysqlType = MYSQL_TYPE_LONG;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
91   <a href="#a0127c4a">a0127c4a</a> +     IntegerTypeTraits<8>::mysqlType = MYSQL_TYPE_LONGLONG;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
92   <a href="#b90cb2a1">b90cb2a1</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
93   <a href="#b90cb2a1">b90cb2a1</a> + template <typename N> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
94   <a href="#a0127c4a">a0127c4a</a> +     BoundVarTraits<N>::mysqlType =</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
95   <a href="#a0127c4a">a0127c4a</a> +     IntegerTypeTraits<sizeof(N)>::mysqlType;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
96   <a href="#b90cb2a1">b90cb2a1</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
97   <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
98   <a href="#a0127c4a">a0127c4a</a> +     BoundVarTraits<bool>::mysqlType = MYSQL_TYPE_LONG;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
99   <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<bool>::isUnsigned = true;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
100  <a href="#a0127c4a">a0127c4a</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
101  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<char>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
102  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<signed char>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
103  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<unsigned char>::isUnsigned = true;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
104  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<short>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
105  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<unsigned short>::isUnsigned = true;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
106  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<int>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
107  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<unsigned int>::isUnsigned = true;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
108  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<long>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
109  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<unsigned long>::isUnsigned = true;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
110  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<long long>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<unsigned long long>::isUnsigned = true;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
112  <a href="#b90cb2a1">b90cb2a1</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
113  <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#a0127c4a">a0127c4a</a> +     BoundVarTraits<float>::mysqlType = MYSQL_TYPE_FLOAT;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<float>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
116  <a href="#b90cb2a1">b90cb2a1</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
117  <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
118  <a href="#a0127c4a">a0127c4a</a> +     BoundVarTraits<double>::mysqlType = MYSQL_TYPE_DOUBLE;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
119  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<double>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
120  <a href="#b90cb2a1">b90cb2a1</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
121  <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
122  <a href="#a0127c4a">a0127c4a</a> +     BoundVarTraits<dafBase::DateTime>::mysqlType = MYSQL_TYPE_DATETIME;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
123  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<dafBase::DateTime>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
124  <a href="#b90cb2a1">b90cb2a1</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
125  <a href="#b90cb2a1">b90cb2a1</a> + template<> enum_field_types</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
126  <a href="#a0127c4a">a0127c4a</a> +     BoundVarTraits<std::string>::mysqlType = MYSQL_TYPE_VAR_STRING;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
127  <a href="#a0127c4a">a0127c4a</a> + template<> bool BoundVarTraits<std::string>::isUnsigned = false;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
128  <a href="#a0127c4a">a0127c4a</a> + </div>
                }}} // namespace lsst::daf::persistence
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
84   <a href="#f69b65eb">f69b65eb</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
85   <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
86   <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::IntegerTypeTraits<1>::mysqlType = MYSQL_TYPE_TINY;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
88   <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::IntegerTypeTraits<2>::mysqlType = MYSQL_TYPE_SHORT;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
89   <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::IntegerTypeTraits<4>::mysqlType = MYSQL_TYPE_LONG;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
91   <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
92   <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::IntegerTypeTraits<8>::mysqlType = MYSQL_TYPE_LONGLONG;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
93   <a href="#b90cb2a1">b90cb2a1</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
94   <a href="#b90cb2a1">b90cb2a1</a> - template <typename N> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
95   <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::BoundVarTraits<N>::mysqlType =</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
96   <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::IntegerTypeTraits<sizeof(N)>::mysqlType;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
97   <a href="#b90cb2a1">b90cb2a1</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
98   <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
99   <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::BoundVarTraits<bool>::mysqlType = MYSQL_TYPE_LONG;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
100  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<bool>::isUnsigned = true;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
101  <a href="#b90cb2a1">b90cb2a1</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
102  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<char>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
103  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<signed char>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
104  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<unsigned char>::isUnsigned = true;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
105  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<short>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
106  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<unsigned short>::isUnsigned = true;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
107  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<int>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
108  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<unsigned int>::isUnsigned = true;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
109  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<long>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
110  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<unsigned long>::isUnsigned = true;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
111  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<long long>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
112  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<unsigned long long>::isUnsigned = true;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
113  <a href="#b90cb2a1">b90cb2a1</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
114  <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
115  <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::BoundVarTraits<float>::mysqlType = MYSQL_TYPE_FLOAT;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
116  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<float>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
117  <a href="#b90cb2a1">b90cb2a1</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
118  <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
119  <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::BoundVarTraits<double>::mysqlType = MYSQL_TYPE_DOUBLE;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
120  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<double>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
121  <a href="#b90cb2a1">b90cb2a1</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
122  <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
123  <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::BoundVarTraits<dafBase::DateTime>::mysqlType = MYSQL_TYPE_DATETIME;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
124  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<dafBase::DateTime>::isUnsigned = false;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
125  <a href="#b90cb2a1">b90cb2a1</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
126  <a href="#b90cb2a1">b90cb2a1</a> - template<> enum_field_types</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
127  <a href="#b90cb2a1">b90cb2a1</a> -     dafPer::BoundVarTraits<std::string>::mysqlType = MYSQL_TYPE_VAR_STRING;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
128  <a href="#b90cb2a1">b90cb2a1</a> - template<> bool dafPer::BoundVarTraits<std::string>::isUnsigned = false;</div>
                
                ///////////////////////////////////////////////////////////////////////////////
                // BoundVar
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Default constructor.
                 */
                dafPer::BoundVar::BoundVar(void) :
                    lsst::daf::base::Citizen(typeid(*this)), _data(0) {
                }
                
                /** Constructor from pointer.
                  */
                dafPer::BoundVar::BoundVar(void* location) :
                    lsst::daf::base::Citizen(typeid(*this)), _data(location) {
                }
                
                /** Copy constructor.
                  */
                dafPer::BoundVar::BoundVar(BoundVar const& src) :
                    lsst::daf::base::Citizen(typeid(*this)),
                    _type(src._type), _isNull(src._isNull), _isUnsigned(src._isUnsigned),
                    _length(src._length), _data(src._data) {
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // CONSTRUCTORS
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Default constructor.
                 */
                dafPer::DbStorageImpl::DbStorageImpl(void) :
                    lsst::daf::base::Citizen(typeid(*this)), _db(0) {
                }
                
                /** Destructor.
                 * End session if present.
                 */
                dafPer::DbStorageImpl::~DbStorageImpl(void) {
                    if (_db) {
                        mysql_close(_db);
                        _db = 0;
                    }
                }
                
                /** Allow a Policy to be used to configure the DbStorage.
                 * @param[in] policy
                 */
                void dafPer::DbStorageImpl::setPolicy(pexPolicy::Policy::Ptr policy) {
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // SESSIONS
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Start a database session.
                 * @param[in] location Physical database location
                 * @param[in] am Access mode for the database (ReadOnly or Update)
                 */
                void dafPer::DbStorageImpl::startSession(std::string const& location) {
                    // Set the timezone for any DATE/TIME/TIMESTAMP fields.
                    setenv("TZ", "UTC", 1);
                
                    DbStorageLocation dbloc(location);
                
                    if (_db) {
                        mysql_close(_db);
                    }
                    _db = mysql_init(0);
                
                    unsigned int port = strtoul(dbloc.getPort().c_str(), 0, 10);
                    if (mysql_real_connect(_db,
                                           dbloc.getHostname().c_str(),
                                           dbloc.getUsername().c_str(),
                                           dbloc.getPassword().c_str(),
                                           dbloc.getDbName().c_str(),
                                           port, 0, 0) == 0) {
                        error("Unable to connect to MySQL database: " + _location);
                    }
                }
                
                /** Set the database location to persist to.
                 * @param[in] location Database connection string to insert into
                 */
                void dafPer::DbStorageImpl::setPersistLocation(LogicalLocation const& location) {
                    startSession(location.locString());
                    _readonly = false;
                }
                
                /** Set the database location to retrieve from.
                 * @param[in] location Database connection string to query
                 */
                void dafPer::DbStorageImpl::setRetrieveLocation(LogicalLocation const& location) {
                    startSession(location.locString());
                    _readonly = true;
                }
                
                /** Start a transaction.
                 */
                void dafPer::DbStorageImpl::startTransaction(void) {
                    if (_db == 0) error("Database session not initialized "
                                        "in DbStorage::startTransaction()", false);
                    if (mysql_autocommit(_db, false)) error("Unable to turn off autocommit");
                }
                
                /** End a transaction.
                 */
                void dafPer::DbStorageImpl::endTransaction(void) {
                    if (_db == 0) error("Database session not initialized "
                                        "in DbStorage::endTransaction()", false);
                    if (mysql_commit(_db)) error("Unable to commit transaction");
                    if (mysql_autocommit(_db, true)) error("Unable to turn on autocommit");
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // UTILITIES
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Execute a query string.
                  */
                void dafPer::DbStorageImpl::executeQuery(std::string const& query) {
                    if (_db == 0) {
                        error("No DB connection for query: " + query, false);
                    }
                    lsst::pex::logging::TTrace<5>("daf.persistence.DbStorage",
                                                  "Query: " + query);
                    if (mysql_query(_db, query.c_str()) != 0) {
                        error("Unable to execute query: " + query);
                    }
                }
                
                /** Quote a name in ANSI-standard fashion.
                  */
                std::string dafPer::DbStorageImpl::quote(std::string const& name) {
                    std::string::size_type pos = name.find('.');
                    if (pos == std::string::npos) return '`' + name + '`';
                    return '`' + std::string(name, 0, pos) + "`.`" +
                        std::string(name, pos + 1) + '`';
                }
                
                void dafPer::DbStorageImpl::stError(std::string const& text) {
                    error(text + " - * " + mysql_stmt_error(_statement), false);
                }
                
                void dafPer::DbStorageImpl::error(std::string const& text, bool mysqlCause) {
                    if (mysqlCause) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
275  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, text + " - * " + mysql_error(_db));</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
276  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError, text + " - * " + mysql_error(_db));</div>
                    }
                    else {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
278  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, text);</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
279  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError, text);</div>
                    }
                }
                
                void* dafPer::DbStorageImpl::allocateMemory(size_t size) {
                    boost::shared_array<char> mem(new char[size]);
                    _bindingMemory.push_back(mem);
                    return mem.get();
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // TABLE OPERATIONS
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Create a new table from an existing template table.
                 * @param[in] tableName Name of the new table
                 * @param[in] templateName Name of the existing template table
                 * @param[in] mayAlreadyExist False (default) if the table must not be present
                 */
                void dafPer::DbStorageImpl::createTableFromTemplate(std::string const& tableName,
                                                        std::string const& templateName,
                                                        bool mayAlreadyExist) {
                    std::string query = "CREATE TABLE ";
                    if (mayAlreadyExist) query += "IF NOT EXISTS ";
                    query += quote(tableName) + " LIKE " + quote(templateName);
                    executeQuery(query);
                }
                
                /** Drop a table.
                 * @param[in] tableName Name of the table to drop
                 */
                void dafPer::DbStorageImpl::dropTable(std::string const& tableName) {
                    executeQuery("DROP TABLE " + quote(tableName));
                }
                
                /** Truncate a table.
                 * @param[in] tableName Name of the table to truncate
                 */
                void dafPer::DbStorageImpl::truncateTable(std::string const& tableName) {
                    executeQuery("TRUNCATE TABLE " + quote(tableName));
                }
                
                /** Execute an arbitrary SQL statement.  Use primarily to perform server-side
                 * computations or complex DDL.
                 * \param[in] sqlStatement SQL statement to be executed.  Must not end in ";".
                 */
                void dafPer::DbStorageImpl::executeSql(std::string const& sqlStatement) {
                    executeQuery(sqlStatement);
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // PERSISTENCE
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Set the table to insert rows into.
                 * @param[in] tableName Name of the table
                 */
                void dafPer::DbStorageImpl::setTableForInsert(std::string const& tableName) {
                    if (_readonly) {
                        error("Attempt to insert into read-only database", false);
                    }
                    _insertTable = tableName;
                    _inputVars.clear();
                }
                
                /** Set the value to insert in a given column.
                 * @param[in] columnName Name of the column
                 * @param[in] value Value to set in the column
                 */
                template <typename T>
                void dafPer::DbStorageImpl::setColumn(std::string const& columnName,
                                                      T const& value) {
                    BoundVarMap::iterator bv = _inputVars.find(columnName);
                    size_t size = sizeof(T);
                    if (bv == _inputVars.end()) {
                       bv = _inputVars.insert(
                            BoundVarMap::value_type(columnName,
                                                    BoundVar(allocateMemory(size)))).first;
                    }
                    else if (bv->second._length != size) {
                        bv->second._data = allocateMemory(size);
                    }
                    bv->second._type = BoundVarTraits<T>::mysqlType;
                    bv->second._isNull = false;
                    bv->second._isUnsigned = BoundVarTraits<T>::isUnsigned;
                    bv->second._length = size;
                    memcpy(bv->second._data, &value, size);
                }
                
                template <>
                void dafPer::DbStorageImpl::setColumn(std::string const& columnName,
                                                      std::string const& value) {
                    BoundVarMap::iterator bv = _inputVars.find(columnName);
                    size_t size = value.length();
                    if (bv == _inputVars.end()) {
                       bv = _inputVars.insert(
                            BoundVarMap::value_type(columnName,
                                                    BoundVar(allocateMemory(size)))).first;
                    }
                    else if (bv->second._length != size) {
                        bv->second._data = allocateMemory(size);
                    }
                    bv->second._type = BoundVarTraits<std::string>::mysqlType;
                    bv->second._isNull = false;
                    bv->second._isUnsigned = BoundVarTraits<std::string>::isUnsigned;
                    bv->second._length = size;
                    memcpy(bv->second._data, value.data(), size);
                }
                
                template <>
                void dafPer::DbStorageImpl::setColumn(std::string const& columnName,
                                                      dafBase::DateTime const& value) {
                    BoundVarMap::iterator bv = _inputVars.find(columnName);
                    size_t size = sizeof(MYSQL_TIME);
                    if (bv == _inputVars.end()) {
                       bv = _inputVars.insert(
                            BoundVarMap::value_type(columnName,
                                                    BoundVar(allocateMemory(size)))).first;
                    }
                    else if (bv->second._length != size) {
                        bv->second._data = allocateMemory(size);
                    }
                    bv->second._type = BoundVarTraits<dafBase::DateTime>::mysqlType;
                    bv->second._isNull = false;
                    bv->second._isUnsigned = BoundVarTraits<dafBase::DateTime>::isUnsigned;
                    bv->second._length = size;
                    struct tm v = value.gmtime();
                    MYSQL_TIME* t = reinterpret_cast<MYSQL_TIME*>(bv->second._data);
                    t->year = v.tm_year + 1900;
                    t->month = v.tm_mon + 1;
                    t->day = v.tm_mday;
                    t->hour = v.tm_hour;
                    t->minute = v.tm_min;
                    t->second = v.tm_sec;
                    t->neg = false;
                    t->second_part =
                        static_cast<unsigned long>((value.nsecs() % 1000000000LL) / 1000);
                }
                
                /** Set a given column to NULL.
                 * @param[in] columnName Name of the column
                 */
                void dafPer::DbStorageImpl::setColumnToNull(std::string const& columnName) {
                    BoundVarMap::iterator bv = _inputVars.find(columnName);
                    if (bv == _inputVars.end()) {
                       bv = _inputVars.insert(
                            BoundVarMap::value_type(columnName,
                                                    BoundVar(allocateMemory(1)))).first;
                    }
                    bv->second._isNull = true;
                    bv->second._length = 1;
                }
                
                /** Insert the row.
                 * Row values must have been set with setColumn() calls.
                 */
                void dafPer::DbStorageImpl::insertRow(void) {
                    if (_readonly) {
                        error("Attempt to insert into read-only database", false);
                    }
                    if (_insertTable.empty()) error("Insert table not initialized in DbStorage::insertRow()", false);
                    if (_inputVars.empty()) error("No values to insert", false);
                
                    std::string query = "INSERT INTO " + quote(_insertTable) + " (";
                
                    boost::scoped_array<MYSQL_BIND> binder(new MYSQL_BIND[_inputVars.size()]);
                    memset(binder.get(), 0, _inputVars.size() * sizeof(MYSQL_BIND));
                
                    int i = 0;
                    for (BoundVarMap::iterator it = _inputVars.begin();
                         it != _inputVars.end(); ++it) {
                        if (it != _inputVars.begin()) {
                            query += ", ";
                        }
                        query += quote(it->first);
                
                        // Bind variables
                        MYSQL_BIND& bind(binder[i]);
                        BoundVar& bv(it->second);
                        if (bv._isNull) {
                            bind.buffer_type = MYSQL_TYPE_NULL;
                        }
                        else {
                            bind.buffer_type = bv._type;
                            bind.buffer = bv._data;
                            bind.buffer_length = bv._length;
                            bind.length = &(bv._length);
                            bind.is_null = 0;
                            bind.is_unsigned = bv._isUnsigned;
                            bind.error = 0;
                        }
                        ++i;
                    }
                    query += ") VALUES (";
                    for (size_t i = 0; i < _inputVars.size(); ++i) {
                        if (i != 0) {
                            query += ", ";
                        }
                        query += "?";
                    }
                    query += ")";
                
                    // Execute statement
                    // Guard statement with mysql_stmt_close()
                    _statement = mysql_stmt_init(_db);
                    if (_statement == 0) {
                        error("Unable to initialize statement: " + query);
                    }
                    if (mysql_stmt_prepare(_statement, query.c_str(), query.length()) != 0) {
                        stError("Unable to prepare statement: " + query);
                    }
                    if (mysql_stmt_bind_param(_statement, binder.get())) {
                        stError("Unable to bind variables in: " + query);
                    }
                    if (mysql_stmt_execute(_statement) != 0) {
                        stError("Unable to execute statement: " + query);
                    }
                    mysql_stmt_close(_statement);
                    _statement = 0;
                }
                
                ///////////////////////////////////////////////////////////////////////////////
                // RETRIEVAL
                ///////////////////////////////////////////////////////////////////////////////
                
                /** Set the table to query (single-table queries only).
                 * @param[in] tableName Name of the table
                 * @param[in] isExpr True if the name is actually a table expression
                 */
                void dafPer::DbStorageImpl::setTableForQuery(std::string const& tableName,
                                                             bool isExpr) {
                    if (_db == 0) error("Database session not initialized in DbStorage::setTableForQuery()", false);
                    _queryTables.clear();
                    _queryTables.push_back(isExpr ? tableName : quote(tableName));
                    _inputVars.clear();
                    _outputVars.clear();
                    _outColumns.clear();
                    _whereClause.clear();
                    _groupBy.clear();
                    _orderBy.clear();
                    _statement = 0;
                }
                
                /** Set a list of tables to query (multiple-table queries).
                 * @param[in] tableNameList Vector of names of tables
                 */
                void dafPer::DbStorageImpl::setTableListForQuery(
                    std::vector<std::string> const& tableNameList) {
                    if (_db == 0) error("Database session not initialized in DbStorage::setTableListForQuery()", false);
                    for (std::vector<std::string>::const_iterator it = tableNameList.begin();
                         it != tableNameList.end(); ++it) {
                        _queryTables.push_back(quote(*it));
                    }
                    _inputVars.clear();
                    _outputVars.clear();
                    _outColumns.clear();
                    _whereClause.clear();
                    _groupBy.clear();
                    _orderBy.clear();
                    _statement = 0;
                }
                
                /** Request a column in the query output.
                 * @param[in] columnName Name of the column
                 * @param[in] isExpr True if the name is actually an expression
                 *
                 * The order of outColumn() calls is the order of appearance in the output
                 * row.  Use either outColumn() or outParam() but not both.
                 */
                void dafPer::DbStorageImpl::outColumn(std::string const& columnName,
                                                      bool isExpr) {
                    std::string col = isExpr ? columnName : quote(columnName);
                    _outColumns.push_back(col);
                }
                
                /** Request a column in the query output and bind a destination location.
                 * @param[in] columnName Name of the column
                 * @param[in] location Pointer to the destination
                 * @param[in] isExpr True if the name is actually an expression
                 *
                 * The order of outParam() calls is the order of appearance in the output row.
                 * Use either outColumn() or outParam() but not both.
                 */
                template <typename T>
                void dafPer::DbStorageImpl::outParam(std::string const& columnName,
                                                     T* location, bool isExpr) {
                    std::string col = isExpr ? columnName : quote(columnName);
                    _outColumns.push_back(col);
                    size_t size = sizeof(T);
                    std::pair<BoundVarMap::iterator, bool> pair = _outputVars.insert(
                        BoundVarMap::value_type(col, BoundVar(location)));
                    if (!pair.second) {
                        error("Duplicate column name requested: " + columnName, false);
                    }
                    BoundVar& bv = pair.first->second;
                    bv._type = BoundVarTraits<T>::mysqlType;
                    bv._isNull = false;
                    bv._isUnsigned = BoundVarTraits<T>::isUnsigned;
                    bv._length = size;
                }
                
                template <>
                void dafPer::DbStorageImpl::outParam(std::string const& columnName,
                                                     std::string* location, bool isExpr) {
                    std::string col = isExpr ? columnName : quote(columnName);
                    _outColumns.push_back(col);
                    size_t size = 4096;
                    std::pair<BoundVarMap::iterator, bool> pair = _outputVars.insert(
                        BoundVarMap::value_type(
                            col, BoundVar(allocateMemory(size + sizeof(std::string*)))));
                    if (!pair.second) {
                        error("Duplicate column name requested: " + columnName, false);
                    }
                    BoundVar& bv = pair.first->second;
                    *reinterpret_cast<std::string**>(bv._data) = location;
                    bv._type = BoundVarTraits<std::string>::mysqlType;
                    bv._isNull = false;
                    bv._isUnsigned = BoundVarTraits<std::string>::isUnsigned;
                    bv._length = size;
                }
                
                template <>
                void dafPer::DbStorageImpl::outParam(std::string const& columnName,
                                                     dafBase::DateTime* location,
                                                     bool isExpr) {
                    std::string col = isExpr ? columnName : quote(columnName);
                    _outColumns.push_back(col);
                    size_t size = sizeof(MYSQL_TIME);
                    std::pair<BoundVarMap::iterator, bool> pair = _outputVars.insert(
                        BoundVarMap::value_type(
                            col, BoundVar(allocateMemory(size + sizeof(dafBase::DateTime*)))));
                    if (!pair.second) {
                        error("Duplicate column name requested: " + columnName, false);
                    }
                    BoundVar& bv = pair.first->second;
                    *reinterpret_cast<dafBase::DateTime**>(bv._data) = location;
                    bv._type = BoundVarTraits<dafBase::DateTime>::mysqlType;
                    bv._isNull = false;
                    bv._isUnsigned = BoundVarTraits<dafBase::DateTime>::isUnsigned;
                    bv._length = size;
                }
                
                /** Bind a value to a WHERE condition parameter.
                 * @param[in] paramName Name of the parameter (prefixed by ":" in the WHERE
                 * clause)
                 * @param[in] value Value to be bound to the parameter.
                 */
                template <typename T>
                void dafPer::DbStorageImpl::condParam(std::string const& paramName, T const& value) {
                    setColumn<T>(paramName, value);
                }
                
                /** Request that the query output be sorted by an expression.  Multiple
                 * expressions may be specified, in order.
                 * @param[in] expression Text of the SQL expression
                 */
                void dafPer::DbStorageImpl::orderBy(std::string const& expression) {
                    if (!_orderBy.empty()) {
                        _orderBy += ", ";
                    }
                    _orderBy += expression;
                }
                
                /** Request that the query output be grouped by an expression.
                 * @param[in] expression Text of the SQL expression
                 */
                void dafPer::DbStorageImpl::groupBy(std::string const& expression) {
                    if (!_groupBy.empty()) {
                        _groupBy += ", ";
                    }
                    _groupBy += expression;
                }
                
                /** Set the condition for the WHERE clause of the query.
                 * @param[in] whereClause SQL text of the WHERE clause
                 *
                 * May include join conditions.
                 */
                void dafPer::DbStorageImpl::setQueryWhere(std::string const& whereClause) {
                    _whereClause = whereClause;
                }
                
                /** Execute the query.
                 */
                void dafPer::DbStorageImpl::query(void) {
                    if (_outColumns.empty()) error("No output columns for query", false);
                
                    // SELECT outVars FROM queryTables WHERE whereClause GROUP BY groupBy
                    // ORDER BY orderBy
                
                    // SELECT clause
                    std::string query = "SELECT ";
                    for (std::vector<std::string>::const_iterator it = _outColumns.begin();
                         it != _outColumns.end(); ++it) {
                        if (it != _outColumns.begin()) {
                            query += ", ";
                        }
                        query += *it;
                    }
                
                    // FROM clause
                    query += " FROM ";
                    for (std::vector<std::string>::const_iterator it = _queryTables.begin();
                         it != _queryTables.end(); ++it) {
                        if (it != _queryTables.begin()) {
                            query += ", ";
                        }
                        query += *it;
                    }
                
                    // WHERE clause
                    std::vector<std::string> whereBindings;
                    if (!_whereClause.empty()) {
                        boost::regex re(":([A-Za-z_]+)");
                        std::string result;
                        std::back_insert_iterator<std::string> out(result);
                        boost::regex_iterator<std::string::iterator> m; 
                        for (boost::regex_iterator<std::string::iterator> i(
                                _whereClause.begin(), _whereClause.end(), re);
                             i != boost::regex_iterator<std::string::iterator>(); ++i) {
                            m = i;
                            std::copy(m->prefix().first, m->prefix().second, out);
                            *out++ = '?';
                            assert(m->size() == 2);
                            whereBindings.push_back(m->str(1));
                        }
                        if (m != boost::regex_iterator<std::string::iterator>()) {
                            std::copy(m->suffix().first, m->suffix().second, out);
                        }
                        else {
                            std::copy(_whereClause.begin(), _whereClause.end(), out);
                        }
                        query += " WHERE " + result;
                    }
                
                    // GROUP BY clause
                    if (!_groupBy.empty()) query += " GROUP BY " + _groupBy;
                
                    // ORDER BY clause
                    if (!_orderBy.empty()) query += " ORDER BY " + _orderBy;
                
                
                    // Create bindings for input WHERE clause variables, if any
                
                    boost::scoped_array<MYSQL_BIND> inBinder(
                        new MYSQL_BIND[whereBindings.size()]);
                    memset(inBinder.get(), 0, whereBindings.size() * sizeof(MYSQL_BIND));
                    for (size_t i = 0; i < whereBindings.size(); ++i) {
                        MYSQL_BIND& bind(inBinder[i]);
                        BoundVarMap::iterator it = _inputVars.find(whereBindings[i]);
                        if (it == _inputVars.end()) {
                            error("Unbound variable in WHERE clause: " + whereBindings[i],
                                  false);
                        }
                        BoundVar& bv = it->second;
                        bind.buffer_type = bv._type;
                        bind.buffer = bv._data;
                        bind.buffer_length = bv._length;
                        bind.is_null = 0;
                        bind.is_unsigned = bv._isUnsigned;
                        bind.error = 0;
                    }
                
                
                    // Initialize and prepare statement
                
                    _statement = mysql_stmt_init(_db);
                    if (!_statement) {
                        error("Unable to initialize prepared statement");
                    }
                
                    if (mysql_stmt_prepare(_statement, query.c_str(), query.length()) != 0) {
                        stError("Unable to prepare statement: " + query);
                    }
                
                
                    // Check number of input parameters and bind them
                    unsigned int params = mysql_stmt_param_count(_statement);
                    if (_whereClause.empty()) {
                        if (params != 0) {
                            error("Unbound WHERE clause parameters: " + query, false);
                        }
                    }
                    else {
                        if (params != whereBindings.size()) {
                            error("Mismatch in number of WHERE clause parameters: " + query,
                                  false);
                        }
                        if (mysql_stmt_bind_param(_statement, inBinder.get())) {
                            stError("Unable to bind WHERE parameters: " + query);
                        }
                    }
                
                    // Check number of result columns
                    MYSQL_RES* queryMetadata = mysql_stmt_result_metadata(_statement);
                    if (!queryMetadata) {
                        stError("No query metadata: " + query);
                    }
                    _numResultFields = mysql_num_fields(queryMetadata);
                    if (static_cast<unsigned int>(_numResultFields) != _outColumns.size()) {
                        error("Mismatch in number of SELECT items: " + query, false);
                    }
                
                
                    // Execute query
                
                    if (mysql_stmt_execute(_statement) != 0) {
                        stError("MySQL query failed: " + query);
                    }
                
                
                    // Create bindings for output variables
                
                    _resultFields = mysql_fetch_fields(queryMetadata);
                
                    boost::scoped_array<MYSQL_BIND> outBinder(new MYSQL_BIND[_numResultFields]);
                    memset(outBinder.get(), 0, _numResultFields * sizeof(MYSQL_BIND));
                    _fieldLengths.reset(new unsigned long[_numResultFields]);
                    _fieldNulls.reset(new my_bool[_numResultFields]);
                
                    for (int i = 0; i < _numResultFields; ++i) {
                        MYSQL_BIND& bind(outBinder[i]);
                        if (_outputVars.empty()) {
                            bind.buffer_type = MYSQL_TYPE_STRING;
                            bind.buffer = 0;
                            bind.buffer_length = 0;
                            bind.length = &(_fieldLengths[i]);
                            bind.is_null = &(_fieldNulls[i]);
                            bind.is_unsigned = (_resultFields[i].flags & UNSIGNED_FLAG) != 0;
                            bind.error = 0;
                        }
                        else {
                            BoundVarMap::iterator it = _outputVars.find(_outColumns[i]);
                            if (it == _outputVars.end()) {
                                error("Unbound variable in SELECT clause: " + _outColumns[i],
                                      false);
                            }
                            BoundVar& bv = it->second;
                
                            bind.buffer_type = bv._type;
                            if (bv._type == BoundVarTraits<std::string>::mysqlType) {
                                bind.buffer = reinterpret_cast<char*>(bv._data) +
                                    sizeof(std::string*);
                            }
                            else if (bv._type == BoundVarTraits<dafBase::DateTime>::mysqlType) {
                                bind.buffer = reinterpret_cast<char*>(bv._data) +
                                    sizeof(std::string*);
                            }
                            else {
                                bind.buffer = bv._data;
                            }
                            bind.buffer_length = bv._length;
                            bind.length = &(_fieldLengths[i]);
                            bind.is_null = &(_fieldNulls[i]);
                            bind.is_unsigned = bv._isUnsigned;
                            bind.error = 0;
                        }
                    }
                    if (mysql_stmt_bind_result(_statement, outBinder.get())) {
                        stError("Unable to bind results: " + query);
                    }
                }
                
                /** Move to the next (first) row of the query result.
                 * @return false if no more rows
                 */
                bool dafPer::DbStorageImpl::next(void) {
                    if (_statement == 0) {
                        error("Statement not initialized in DbStorage::next()", false);
                    }
                    int ret = mysql_stmt_fetch(_statement);
                    if (ret == 0) {
                        // Fix up strings and DateTimes
                        if (!_outputVars.empty()) {
                            for (size_t i = 0; i < _outColumns.size(); ++i) {
                                BoundVarMap::iterator bvit = _outputVars.find(_outColumns[i]);
                                if (bvit == _outputVars.end()) {
                                    error("Unbound variable in SELECT clause: " +
                                          _outColumns[i], false);
                                }
                                BoundVar& bv = bvit->second;
                                if (bv._type == BoundVarTraits<std::string>::mysqlType) {
                                    **reinterpret_cast<std::string**>(bv._data) =
                                        std::string(reinterpret_cast<char*>(bv._data) +
                                                    sizeof(std::string*), _fieldLengths[i]);
                                }
                                else if (bv._type ==
                                         BoundVarTraits<dafBase::DateTime>::mysqlType) {
                                    char* cp = reinterpret_cast<char*>(bv._data) +
                                        sizeof(dafBase::DateTime*);
                                    MYSQL_TIME* t = reinterpret_cast<MYSQL_TIME*>(cp);
                                    **reinterpret_cast<dafBase::DateTime**>(bv._data) =
                                        dafBase::DateTime(t->year, t->month, t->day,
                                                          t->hour, t->minute, t->second,
                                                          dafBase::DateTime::UTC);
                                }
                            }
                        }
                        return true;
                    }
                    if (ret == MYSQL_NO_DATA) return false;
                    if (ret == MYSQL_DATA_TRUNCATED && _outputVars.empty()) return true;
                    stError("Error fetching next row");
                    return false;
                }
                
                /** Get the value of a column of the query result row by position.
                 * @param[in] pos Position of the column (starts at 0)
                 * @return Reference to the value of the column
                 */
                template <typename T>
                T const& dafPer::DbStorageImpl::getColumnByPos(int pos) {
                    if (pos > _numResultFields) {
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
892  <a href="#f80e148c">f80e148c</a> +         std::ostringstream os;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
891  <a href="#b90cb2a1">b90cb2a1</a> -         error("Nonexistent column: " + pos, false);</div>
              ?         --- ^^                       ^    --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
893  <a href="#f80e148c">f80e148c</a> +         os << "Nonexistent column: " << pos;</div>
              ?          ^^^^^                       ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
894  <a href="#f80e148c">f80e148c</a> +         error(os.str(), false);</div>
                    }
                    MYSQL_BIND bind;
                    memset(&bind, 0, sizeof(MYSQL_BIND));
                    static T t;
                    bind.buffer_type = BoundVarTraits<T>::mysqlType;
                    bind.is_unsigned = BoundVarTraits<T>::isUnsigned;
                    bind.buffer = &t;
                    bind.buffer_length = sizeof(T);
                    bind.length = &(_fieldLengths[pos]);
                    bind.is_null = &(_fieldNulls[pos]);
                    if (mysql_stmt_fetch_column(_statement, &bind, pos, 0)) {
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
906  <a href="#f80e148c">f80e148c</a> +         std::ostringstream os;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
903  <a href="#b90cb2a1">b90cb2a1</a> -         stError("Error fetching column: " + pos);</div>
              ?          ^^^^^^^                          ^    -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
907  <a href="#f80e148c">f80e148c</a> +         os << "Error fetching column: " << pos;</div>
              ?         + ^^^^                          ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
908  <a href="#f80e148c">f80e148c</a> +         error(os.str(), false);</div>
                    }
                    return t;
                }
                
                template <>
                std::string const& dafPer::DbStorageImpl::getColumnByPos(int pos) {
                    if (pos > _numResultFields) {
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
916  <a href="#f80e148c">f80e148c</a> +         std::ostringstream os;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
911  <a href="#b90cb2a1">b90cb2a1</a> -         error("Nonexistent column: " + pos, false);</div>
              ?         --- ^^                       ^    --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
917  <a href="#f80e148c">f80e148c</a> +         os << "Nonexistent column: " << pos;</div>
              ?          ^^^^^                       ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
918  <a href="#f80e148c">f80e148c</a> +         error(os.str(), false);</div>
                    }
                    MYSQL_BIND bind;
                    memset(&bind, 0, sizeof(MYSQL_BIND));
                    if (_resultFields[pos].type == MYSQL_TYPE_BIT) {
                        error("Invalid type for string retrieval", false);
                    }
                    boost::scoped_array<char> t(new char[_fieldLengths[pos]]);
                    bind.buffer_type = BoundVarTraits<std::string>::mysqlType;
                    bind.is_unsigned = BoundVarTraits<std::string>::isUnsigned;
                    bind.buffer = t.get();
                    bind.buffer_length = _fieldLengths[pos];
                    bind.length = &(_fieldLengths[pos]);
                    bind.is_null = &(_fieldNulls[pos]);
                    if (mysql_stmt_fetch_column(_statement, &bind, pos, 0)) {
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
933  <a href="#f80e148c">f80e148c</a> +         std::ostringstream os;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
926  <a href="#b90cb2a1">b90cb2a1</a> -         stError("Error fetching string column: " + pos);</div>
              ?          ^^^^^^^                                 ^    -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
934  <a href="#f80e148c">f80e148c</a> +         os << "Error fetching string column: " << pos;</div>
              ?         + ^^^^                                 ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
935  <a href="#f80e148c">f80e148c</a> +         stError(os.str());</div>
                    }
                    static std::string s;
                    s = std::string(t.get(), _fieldLengths[pos]);
                    return s;
                }
                
                template <>
                dafBase::DateTime const& dafPer::DbStorageImpl::getColumnByPos(int pos) {
                    if (pos > _numResultFields) {
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
945  <a href="#f80e148c">f80e148c</a> +         std::ostringstream os;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
936  <a href="#5d046b74">5d046b74</a> -         error("Nonexistent column: " + pos, false);</div>
              ?         --- ^^                       ^    --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
946  <a href="#f80e148c">f80e148c</a> +         os << "Nonexistent column: " << pos;</div>
              ?          ^^^^^                       ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
947  <a href="#f80e148c">f80e148c</a> +         error(os.str(), false);</div>
                    }
                    MYSQL_BIND bind;
                    memset(&bind, 0, sizeof(MYSQL_BIND));
                    if (_resultFields[pos].type != MYSQL_TYPE_TIME &&
                        _resultFields[pos].type != MYSQL_TYPE_DATE &&
                        _resultFields[pos].type != MYSQL_TYPE_DATETIME &&
                        _resultFields[pos].type != MYSQL_TYPE_TIMESTAMP) {
                        error("Invalid type for DateTime retrieval", false);
                    }
                    static MYSQL_TIME t;
                    bind.buffer_type = BoundVarTraits<dafBase::DateTime>::mysqlType;
                    bind.is_unsigned = BoundVarTraits<dafBase::DateTime>::isUnsigned;
                    bind.buffer = &t;
                    bind.buffer_length = sizeof(MYSQL_TIME);
                    bind.length = &(_fieldLengths[pos]);
                    bind.is_null = &(_fieldNulls[pos]);
                    if (mysql_stmt_fetch_column(_statement, &bind, pos, 0)) {
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
965  <a href="#f80e148c">f80e148c</a> +         std::ostringstream os;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
954  <a href="#5d046b74">5d046b74</a> -         stError("Error fetching DateTime column: " + pos);</div>
              ?          ^^^^^^^                                   ^    -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
966  <a href="#f80e148c">f80e148c</a> +         os << "Error fetching DateTime column: " << pos;</div>
              ?         + ^^^^                                   ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
967  <a href="#f80e148c">f80e148c</a> +         stError(os.str());</div>
                    }
                    static dafBase::DateTime v;
                    v = dafBase::DateTime(t.year, t.month, t.day, t.hour, t.minute, t.second,
                                          dafBase::DateTime::UTC);
                    return v;
                }
                
                /** Determine if the value of a column is NULL.
                 * @param[in] pos Position of the column (starts at 0)
                 * @return true if value is NULL
                 */
                bool dafPer::DbStorageImpl::columnIsNull(int pos) {
                    if (pos > _numResultFields) {
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
981  <a href="#f80e148c">f80e148c</a> +         std::ostringstream os;</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
968  <a href="#b90cb2a1">b90cb2a1</a> -         error("Nonexistent column: " + pos, false);</div>
              ?         --- ^^                       ^    --------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
982  <a href="#f80e148c">f80e148c</a> +         os << "Nonexistent column: " << pos;</div>
              ?          ^^^^^                       ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
983  <a href="#f80e148c">f80e148c</a> +         error(os.str(), false);</div>
                    }
                    return _fieldNulls[pos];
                }
                
                /** Indicate that query processing is finished.
                 */
                void dafPer::DbStorageImpl::finishQuery(void) {
                    mysql_stmt_close(_statement);
                    _statement = 0;
                }
                
                
                // Explicit template member function instantiations
                // Ignore for doxygen processing.
                //! @cond
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, char const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, short const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, int const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, long const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, long long const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, float const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, double const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, std::string const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, bool const& value);
                template void dafPer::DbStorageImpl::setColumn<>(std::string const& columnName, dafBase::DateTime const& value);
                
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, char* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, short* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, int* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, long* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, long long* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, float* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, double* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, std::string* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, bool* location, bool isExpr);
                template void dafPer::DbStorageImpl::outParam<>(std::string const& columnName, dafBase::DateTime* location, bool isExpr);
                
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, char const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, short const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, int const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, long const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, long long const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, float const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, double const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, std::string const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, bool const& value);
                template void dafPer::DbStorageImpl::condParam<>(std::string const& paramName, dafBase::DateTime const& value);
                
                template char const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template short const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template int const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template long const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template long long const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template float const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template double const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template std::string const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template bool const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                template dafBase::DateTime const& dafPer::DbStorageImpl::getColumnByPos<>(int pos);
                //! @endcond
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="b90cb2a1"/></a>b90cb2a1</h3>

<pre>
commit b90cb2a19b1837115e66cc6b6589cdb5615fe08c
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Aug 19 17:46:57 2008 +0000

    Merged revisions 4712-5896 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/persistence/tickets/332
    
    ........
      r5656 | ktlim | 2008-05-30 13:45:04 -0700 (Fri, 30 May 2008) | 1 line
    
      Remove references to CORAL/SEAL libraries.
    ........
      r5657 | ktlim | 2008-05-30 13:45:32 -0700 (Fri, 30 May 2008) | 1 line
    
      More progress towards de-CORAL-ization of DbStorageImpl.
    ........
      r5878 | ktlim | 2008-08-12 17:21:35 -0700 (Tue, 12 Aug 2008) | 1 line
    
      Remove template instantiations for long int.
    ........
      r5879 | ktlim | 2008-08-12 17:22:35 -0700 (Tue, 12 Aug 2008) | 1 line
    
      Nearly working, with new just-in-time binding for retrieving columns and hacky string manipulation.
    ........
      r5883 | ktlim | 2008-08-13 14:28:27 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Remove template instantiation for long int.
    ........
      r5884 | ktlim | 2008-08-13 14:28:57 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Add private member function for statement-based errors.
    ........
      r5885 | ktlim | 2008-08-13 14:33:53 -0700 (Wed, 13 Aug 2008) | 8 lines
    
      Fix INSERT query building and check return values.  Fix incorrect tests after
      inserting into hashes.  Fix regular expression for finding parameters and test
      for trailing WHERE clause text.  For unbound results, bind a zero-length string
      type initially.  Zero-fill all bind structures.  Always return length and null
      status into member arrays, not bound variable.  Ignore truncation for unbound
      results.  Use static buffers for unbound results.
    ........
      r5886 | ktlim | 2008-08-13 17:43:05 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Fix memory management bugs.  All tests pass!
    ........
      r5887 | ktlim | 2008-08-13 21:00:20 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Fixes for MacOS.
    ........
      r5888 | ktlim | 2008-08-13 21:01:11 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Add template instantiations for long.  Hat tip to Serge for the suggestion to use a sizeof template.
    ........
      r5890 | ktlim | 2008-08-13 22:35:31 -0700 (Wed, 13 Aug 2008) | 1 line
    
      long and long long need to be handled explicitly to deal with 64-bit machines.
    ........
      r5891 | ktlim | 2008-08-13 22:49:26 -0700 (Wed, 13 Aug 2008) | 1 line
    
      SWIG does not follow includes in include files.
    ........
</pre>
<h3><a name="9966404e"/></a>9966404e</h3>

<pre>
commit 9966404e8df345526d211ae57b1dc976149a8efd
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Dec 18 22:56:53 2008 +0000

    Merged revisions 6561-6817 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/persistence/tickets/492
    
    ........
      r6561 | ktlim | 2008-11-25 21:59:52 -0800 (Tue, 25 Nov 2008) | 2 lines
    
      Create branch for #492 (add PropertySetFormatter).
    ........
      r6712 | ktlim | 2008-12-09 19:35:00 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Replace DataPropertyFormatter with PropertySetFormatter.
    ........
      r6713 | ktlim | 2008-12-09 19:36:51 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change DataProperty to PropertySet.
    ........
      r6714 | ktlim | 2008-12-09 19:37:09 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change to new exceptions.
    ........
      r6715 | ktlim | 2008-12-09 19:37:25 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Add needed packages to table.
    ........
      r6732 | ktlim | 2008-12-13 15:31:12 -0800 (Sat, 13 Dec 2008) | 1 line
    
      Update tests to use PropertySet instead of DataProperty.
    ........
      r6739 | ktlim | 2008-12-14 15:00:54 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update build files to more modern structures.
    ........
      r6740 | ktlim | 2008-12-14 15:01:59 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update to more modern .i structure.
    ........
      r6763 | ktlim | 2008-12-15 15:53:26 -0800 (Mon, 15 Dec 2008) | 1 line
    
      Fix standards incompatibility detected by gcc4.
    ........
</pre>
<h3><a name="5d046b74"/></a>5d046b74</h3>

<pre>
commit 5d046b74a1d9668c6b26c1c43c3299c8d4f074ab
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Sat Mar 7 09:01:12 2009 +0000

    Specialize DbStorageImpl methods for DateTime to properly persist to MySQL TIME/DATE/DATETIME/TIMESTAMP fields.
</pre>
<h3><a name="f69b65eb"/></a>f69b65eb</h3>

<pre>
commit f69b65ebab9e2c985d935e21ee205bcf0b953a00
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Mar 28 01:07:49 2008 +0000

    Initial move of mwi/persistence to daf/persistence.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="b90cb2a1"/></a>b90cb2a1</h3>

<pre>
commit b90cb2a19b1837115e66cc6b6589cdb5615fe08c
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Aug 19 17:46:57 2008 +0000

    Merged revisions 4712-5896 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/persistence/tickets/332
    
    ........
      r5656 | ktlim | 2008-05-30 13:45:04 -0700 (Fri, 30 May 2008) | 1 line
    
      Remove references to CORAL/SEAL libraries.
    ........
      r5657 | ktlim | 2008-05-30 13:45:32 -0700 (Fri, 30 May 2008) | 1 line
    
      More progress towards de-CORAL-ization of DbStorageImpl.
    ........
      r5878 | ktlim | 2008-08-12 17:21:35 -0700 (Tue, 12 Aug 2008) | 1 line
    
      Remove template instantiations for long int.
    ........
      r5879 | ktlim | 2008-08-12 17:22:35 -0700 (Tue, 12 Aug 2008) | 1 line
    
      Nearly working, with new just-in-time binding for retrieving columns and hacky string manipulation.
    ........
      r5883 | ktlim | 2008-08-13 14:28:27 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Remove template instantiation for long int.
    ........
      r5884 | ktlim | 2008-08-13 14:28:57 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Add private member function for statement-based errors.
    ........
      r5885 | ktlim | 2008-08-13 14:33:53 -0700 (Wed, 13 Aug 2008) | 8 lines
    
      Fix INSERT query building and check return values.  Fix incorrect tests after
      inserting into hashes.  Fix regular expression for finding parameters and test
      for trailing WHERE clause text.  For unbound results, bind a zero-length string
      type initially.  Zero-fill all bind structures.  Always return length and null
      status into member arrays, not bound variable.  Ignore truncation for unbound
      results.  Use static buffers for unbound results.
    ........
      r5886 | ktlim | 2008-08-13 17:43:05 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Fix memory management bugs.  All tests pass!
    ........
      r5887 | ktlim | 2008-08-13 21:00:20 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Fixes for MacOS.
    ........
      r5888 | ktlim | 2008-08-13 21:01:11 -0700 (Wed, 13 Aug 2008) | 1 line
    
      Add template instantiations for long.  Hat tip to Serge for the suggestion to use a sizeof template.
    ........
      r5890 | ktlim | 2008-08-13 22:35:31 -0700 (Wed, 13 Aug 2008) | 1 line
    
      long and long long need to be handled explicitly to deal with 64-bit machines.
    ........
      r5891 | ktlim | 2008-08-13 22:49:26 -0700 (Wed, 13 Aug 2008) | 1 line
    
      SWIG does not follow includes in include files.
    ........
</pre>
<h3><a name="f80e148c"/></a>f80e148c</h3>

<pre>
commit f80e148c5d09ed81f70627931fcd7ed93500d4c1
Author: Russell Owen <rowen@uw.edu>
Date:   Sun Oct 5 08:01:11 2014 -0700

    Eliminate warnings about adding 'int' to a string
</pre>
<h3><a name="a0127c4a"/></a>a0127c4a</h3>

<pre>
commit a0127c4aa5f61c3f67b12540033e465ee1202b49
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Oct 7 16:07:21 2014 -0700

    Eliminate compiler warning about first declaration of static data mmember
    
    Eliminate compiler warnings: first declaration of static data member
    specialization of 'mysqlType' outside namespace 'persistence' is a C++11
    extension [-Wc++11-extensions]
</pre>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="include/lsst/daf/persistence/PropertySetFormatter.cc"/></a>include/lsst/daf/persistence/PropertySetFormatter.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
3    <a href="#f76174dd">f76174dd</a> - /* </div>
              ?   -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
3    <a href="#c07b65e7">c07b65e7</a> + /*</div>
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#f76174dd">f76174dd</a> -  * </div>
              ?   -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#c07b65e7">c07b65e7</a> +  *</div>
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
14   <a href="#f76174dd">f76174dd</a> -  * </div>
              ?   -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
14   <a href="#c07b65e7">c07b65e7</a> +  *</div>
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
19   <a href="#f76174dd">f76174dd</a> -  * </div>
              ?   -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
19   <a href="#c07b65e7">c07b65e7</a> +  *</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
20   <a href="#f76174dd">f76174dd</a> -  * You should have received a copy of the LSST License Statement and </div>
              ?                                                                     -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
20   <a href="#c07b65e7">c07b65e7</a> +  * You should have received a copy of the LSST License Statement and</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
21   <a href="#f76174dd">f76174dd</a> -  * the GNU General Public License along with this program.  If not, </div>
              ?                                                                    -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
21   <a href="#c07b65e7">c07b65e7</a> +  * the GNU General Public License along with this program.  If not,</div>
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
24   <a href="#f76174dd">f76174dd</a> -  </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
24   <a href="#c07b65e7">c07b65e7</a> + </div>
                
                /** \file
                 * \brief Implementation of PropertySetFormatter class
                 *
                 * \version $Revision$
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #include <string>
                #include <vector>
                
                #include <boost/serialization/nvp.hpp>
                #include <boost/serialization/shared_ptr.hpp>
                
                #include <lsst/daf/base/PropertySet.h>
                #include "lsst/daf/base/DateTime.h"
                #include <lsst/pex/exceptions.h>
                #include <lsst/pex/logging/Trace.h>
                
                
                using boost::serialization::make_nvp;
                
                namespace lsst {
                namespace daf {
                namespace persistence {
                
                namespace dafBase = lsst::daf::base;
                
                namespace {
                
                /** Serialize a PropertySet value.
                 * \param[in,out] ar Boost archive
                 * \param[in] name Name of property to serialize/deserialize.
                 * \param[in,out] ps Pointer to PropertySet.
                 */
                template <class Archive, typename T>
                static void serializeItem(Archive& ar, std::string const& name,
                                          dafBase::PropertySet* ps) {
                    std::vector<T> value;
                    if (Archive::is_saving::value) {
                        value = ps->getArray<T>(name);
                        ar & make_nvp("value", value);
                    }
                    else {
                        ar & make_nvp("value", value);
                        ps->set(name, value);
                    }
                }
                
                /** Serialize a DateTime PropertySet value.
                 * \param[in,out] ar Boost archive
                 * \param[in] name Name of property to serialize/deserialize.
                 * \param[in,out] ps Pointer to PropertySet.
                 */
                template <class Archive>
                static void serializeDateTime(Archive& ar, std::string const& name,
                                              dafBase::PropertySet* ps) {
                    std::vector<dafBase::DateTime> value;
                    std::vector<long long> nsecs;
                    if (Archive::is_saving::value) {
                        value = ps->getArray<dafBase::DateTime>(name);
                        for (std::vector<dafBase::DateTime>::const_iterator i = value.begin();
                             i != value.end(); ++i) {
                            nsecs.push_back(i->nsecs());
                        }
                        ar & make_nvp("value", nsecs);
                    }
                    else {
                        ar & make_nvp("value", nsecs);
                        for (std::vector<long long>::const_iterator i = nsecs.begin();
                             i != nsecs.end(); ++i) {
                            value.push_back(dafBase::DateTime(*i));
                        }
                        ps->set(name, value);
                    }
                }
                
                } // anonymous namespace
                
                /** Serialize a PropertySet to a Boost archive.  Handles text or XML
                 * archives, input or output.
                 * \param[in,out] ar Boost archive
                 * \param[in] version Version of the PropertySet class
                 * \param[in,out] persistable Pointer to the PropertySet as a Persistable
                 */
                template <class Archive>
                void PropertySetFormatter::delegateSerialize(
                    Archive& ar, unsigned int const version, dafBase::Persistable* persistable) {
                    dafBase::PropertySet* ps =
                        dynamic_cast<dafBase::PropertySet*>(persistable);
                    if (ps == 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
120  <a href="#f76174dd">f76174dd</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, "Serializing non-PropertySet");</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
120  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError, "Serializing non-PropertySet");</div>
                    }
                    ar & make_nvp("base",
                                  boost::serialization::base_object<dafBase::Persistable>(*ps));
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
124  <a href="#f76174dd">f76174dd</a> -     </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
124  <a href="#c07b65e7">c07b65e7</a> + </div>
                    std::vector<std::string> names;
                    size_t nNames;
                    if (Archive::is_saving::value) {
                        names = ps->paramNames(false);
                        nNames = names.size();
                    }
                    ar & make_nvp("nitems", nNames);
                
                    char type;
                    std::string name;
                    for (size_t i = 0; i < nNames; ++i) {
                        if (Archive::is_saving::value) {
                            name = names[i];
                            std::type_info const& id(ps->typeOf(name));
                
                            if (id == typeid(bool)) type = 'b';
                            else if (id == typeid(char)) type = 'c';
                            else if (id == typeid(signed char)) type = 'y';
                            else if (id == typeid(unsigned char)) type = 'C';
                            else if (id == typeid(short)) type = 'w';
                            else if (id == typeid(unsigned short)) type = 'W';
                            else if (id == typeid(int)) type = 'i';
                            else if (id == typeid(unsigned int)) type = 'I';
                            else if (id == typeid(long)) type = 'l';
                            else if (id == typeid(unsigned long)) type = 'L';
                            else if (id == typeid(long long)) type = 'x';
                            else if (id == typeid(unsigned long long)) type = 'X';
                            else if (id == typeid(float)) type = 'f';
                            else if (id == typeid(double)) type = 'd';
                            else if (id == typeid(std::string)) type = 's';
                            else if (id == typeid(dafBase::DateTime)) type = 'T';
                            else if (id == typeid(dafBase::Persistable::Ptr)) type = 'p';
                            else {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
158  <a href="#f76174dd">f76174dd</a> -                 throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException,</div>
              ?                                                                      ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
158  <a href="#0c1dd2d0">0c1dd2d0</a> +                 throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                                                  name +
                                                  ": Unknown type in PropertySet serialize");
                            }
                        }
                
                        ar & make_nvp("name", name);
                        ar & make_nvp("type", type);
                        switch (type) {
                        case 'b': serializeItem<Archive, bool>(ar, name, ps); break;
                        case 'c': serializeItem<Archive, char>(ar, name, ps); break;
                        case 'y': serializeItem<Archive, signed char>(ar, name, ps); break;
                        case 'C': serializeItem<Archive, unsigned char>(ar, name, ps); break;
                        case 'w': serializeItem<Archive, short>(ar, name, ps); break;
                        case 'W': serializeItem<Archive, unsigned short>(ar, name, ps); break;
                        case 'i': serializeItem<Archive, int>(ar, name, ps); break;
                        case 'I': serializeItem<Archive, unsigned int>(ar, name, ps); break;
                        case 'l': serializeItem<Archive, long>(ar, name, ps); break;
                        case 'L': serializeItem<Archive, unsigned long>(ar, name, ps); break;
                        case 'x': serializeItem<Archive, long long>(ar, name, ps); break;
                        case 'X': serializeItem<Archive, unsigned long long>(ar, name, ps); break;
                        case 'f': serializeItem<Archive, float>(ar, name, ps); break;
                        case 'd': serializeItem<Archive, double>(ar, name, ps); break;
                        case 's': serializeItem<Archive, std::string>(ar, name, ps); break;
                        case 'T': serializeDateTime<Archive>(ar, name, ps); break;
                        case 'p': serializeItem<Archive, dafBase::Persistable::Ptr>(ar, name, ps); break;
                        default:
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
185  <a href="#f76174dd">f76174dd</a> -                   throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, </div>
              ?                                                                        --------- -
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
185  <a href="#c07b65e7">c07b65e7</a> +                   throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                                      std::string("Unknown type reading PropertySet") +
                                      type + ", name = " + name);
                        }
                    }
                }
                
                }}} // namespace lsst::daf::persistence
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="f76174dd"/></a>f76174dd</h3>

<pre>
commit f76174ddefeb29106f46c300b77271981c35634e
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Oct 14 02:25:24 2011 +0000

    Move delegateSerialize() template definition (and related templates) to header file.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="c07b65e7"/></a>c07b65e7</h3>

<pre>
commit c07b65e79d3904bc7672569d1178870c291ccf08
Author: Russell Owen <rowen@uw.edu>
Date:   Wed Jun 25 15:55:11 2014 -0700

    Respond to K-T's review by removing trailing whitespace in two files.
</pre>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="python/lsst/daf/persistence/butler.py"/></a>python/lsst/daf/persistence/butler.py
### Diff:

<pre>
                #!/usr/bin/env python
                
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                # -*- python -*-
                
                """This module defines the Butler class."""
                
                from __future__ import with_statement
                import cPickle
                import importlib
                import os
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
33   <a href="#4c72f843">4c72f843</a> - import re</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
34   <a href="#0789a647">0789a647</a> - import socket</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
35   <a href="#0789a647">0789a647</a> - import getpass</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
36   <a href="#0ee7da3a">0ee7da3a</a> - import lsst.pex.config as pexConfig</div>
                import lsst.pex.logging as pexLog
                import lsst.pex.policy as pexPolicy
                from lsst.daf.persistence import StorageList, LogicalLocation, ReadProxy, ButlerSubset, ButlerDataRef, \
                    Persistence
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
41   <a href="#4506d9c2">4506d9c2</a> - import tempfile</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
42   <a href="#f9540de3">f9540de3</a> - import errno</div>
                
                class Butler(object):
                    """Butler provides a generic mechanism for persisting and retrieving data using mappers.
                
                    A Butler manages a collection of datasets known as a repository.  Each
                    dataset has a type representing its intended usage and a location.  Note
                    that the dataset type is not the same as the C++ or Python type of the
                    object containing the data.  For example, an ExposureF object might be
                    used to hold the data for a raw image, a post-ISR image, a calibrated
                    science image, or a difference image.  These would all be different
                    dataset types.
                
                    A Butler can produce a collection of possible values for a key (or tuples
                    of values for multiple keys) if given a partial data identifier.  It can
                    check for the existence of a file containing a dataset given its type and
                    data identifier.  The Butler can then retrieve the dataset.  Similarly, it
                    can persist an object to an appropriate location when given its associated
                    data identifier.
                
                    Note that the Butler has two more advanced features when retrieving a data
                    set.  First, the retrieval is lazy.  Input does not occur until the data
                    set is actually accessed.  This allows datasets to be retrieved and
                    placed on a clipboard prospectively with little cost, even if the
                    algorithm of a stage ends up not using them.  Second, the Butler will call
                    a standardization hook upon retrieval of the dataset.  This function,
                    contained in the input mapper object, must perform any necessary
                    manipulations to force the retrieved object to conform to standards,
                    including translating metadata.
                
                    Public methods:
                
                    __init__(self, root, mapper=None, **mapperArgs)
                
                    getKeys(self, datasetType=None, level=None)
                
                    queryMetadata(self, datasetType, keys, format=None, dataId={}, **rest)
                
                    datasetExists(self, datasetType, dataId={}, **rest)
                
                    get(self, datasetType, dataId={}, immediate=False, **rest)
                
                    put(self, obj, datasetType, dataId={}, **rest)
                
                    subset(self, datasetType, level=None, dataId={}, **rest))
                
                    """
                
                    @staticmethod
                    def getMapperClass(root):
                        """Return the mapper class associated with a repository root."""
                
                        # Find a "_mapper" file containing the mapper class name
                        basePath = root
                        mapperFile = "_mapper"
                        globals = {}
                        while not os.path.exists(os.path.join(basePath, mapperFile)):
                            # Break abstraction by following _parent links from CameraMapper
                            if os.path.exists(os.path.join(basePath, "_parent")):
                                basePath = os.path.join(basePath, "_parent")
                            else:
                                raise RuntimeError(
                                        "No mapper provided and no %s available" %
                                        (mapperFile,))
                        mapperFile = os.path.join(basePath, mapperFile)
                
                        # Read the name of the mapper class and instantiate it
                        with open(mapperFile, "r") as f:
                            mapperName = f.readline().strip()
                        components = mapperName.split(".")
                        if len(components) <= 1:
                            raise RuntimeError("Unqualified mapper name %s in %s" %
                                    (mapperName, mapperFile))
                        pkg = importlib.import_module(".".join(components[:-1]))
                        return getattr(pkg, components[-1])
                
                    def __init__(self, root, mapper=None, **mapperArgs):
                        """Construct the Butler.  If no mapper class is provided, then a file
                        named "_mapper" is expected to be found in the repository, which
                        must be a filesystem path.  The first line in that file is read and
                        must contain the fully-qualified name of a Mapper subclass, which is
                        then imported and instantiated using the root and the mapperArgs.
                
                        @param root (str)       the repository to be managed (at least
                                                initially).  May be None if a mapper is
                                                provided.
                        @param mapper (Mapper)  if present, the Mapper subclass instance
                                                to be used as the butler's mapper.
                        @param **mapperArgs     arguments to be passed to the mapper's
                                                __init__ method, in addition to the root."""
                
                        if mapper is not None:
                            self.mapper = mapper
                        else:
                            cls = Butler.getMapperClass(root)
                            self.mapper = cls(root=root, **mapperArgs)
                
                        # Always use an empty Persistence policy until we can get rid of it
                        persistencePolicy = pexPolicy.Policy()
                        self.persistence = Persistence.getPersistence(persistencePolicy)
                        self.log = pexLog.Log(pexLog.Log.getDefaultLog(),
                                "daf.persistence.butler")
                
                    def getKeys(self, datasetType=None, level=None):
                
                        """Returns a dict.  The dict keys are the valid data id keys at or
                        above the given level of hierarchy for the dataset type or the entire
                        collection if None.  The dict values are the basic Python types
                        corresponding to the keys (int, float, str).
                        
                        @param datasetType (str)  the type of dataset to get keys for, entire
                                                  collection if None.
                        @param level (str)        the hierarchy level to descend to or None.
                        @returns (dict) valid data id keys; values are corresponding types."""
                
                        return self.mapper.getKeys(datasetType, level)
                
                    def queryMetadata(self, datasetType, key, format=None, dataId={}, **rest):
                        """Returns the valid values for one or more keys when given a partial
                        input collection data id.
                        
                        @param datasetType (str)    the type of dataset to inquire about.
                        @param key (str)            a key giving the level of granularity of the inquiry.
                        @param format (str, tuple)  an optional key or tuple of keys to be returned. 
                        @param dataId (dict)        the partial data id.
                        @param **rest               keyword arguments for the partial data id.
                        @returns (list) a list of valid values or tuples of valid values as
                        specified by the format (defaulting to the same as the key) at the
                        key's level of granularity.
                        """
                
                        dataId = self._combineDicts(dataId, **rest)
                        if format is None:
                            format = (key,)
                        elif not hasattr(format, '__iter__'):
                            format = (format,)
                        tuples = self.mapper.queryMetadata(datasetType, key, format, dataId)
                        if len(format) == 1:
                            return [x[0] for x in tuples]
                        return tuples
                
                    def datasetExists(self, datasetType, dataId={}, **rest):
                        """Determines if a dataset file exists.
                
                        @param datasetType (str)   the type of dataset to inquire about.
                        @param dataId (dict)       the data id of the dataset.
                        @param **rest              keyword arguments for the data id.
                        @returns (bool) True if the dataset exists or is non-file-based.
                        """
                
                        dataId = self._combineDicts(dataId, **rest)
                        location = self.mapper.map(datasetType, dataId)
                        additionalData = location.getAdditionalData()
                        storageName = location.getStorageName()
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
196  <a href="#3026f37a">3026f37a</a> -         if storageName in ('BoostStorage', 'FitsStorage', 'PafStorage', 'EupsStorage',</div>
              ?                                                                        ---------------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
190  <a href="#6a906173">6a906173</a> +         if storageName in ('BoostStorage', 'FitsStorage', 'PafStorage',</div>
                                'PickleStorage', 'ConfigStorage', 'FitsCatalogStorage'):
                            locations = location.getLocations()
                            for locationString in locations:
                                logLoc = LogicalLocation(locationString, additionalData).locString()
                                if storageName == 'FitsStorage':
                                    # Strip off directives for cfitsio (in square brackets, e.g., extension name)
                                    bracket = logLoc.find('[')
                                    if bracket > 0:
                                        logLoc = logLoc[:bracket]
                                if not os.path.exists(logLoc):
                                    return False
                            return True
                        self.log.log(pexLog.Log.WARN,
                                "datasetExists() for non-file storage %s, dataset type=%s, keys=%s" %
                                (storageName, datasetType, str(dataId)))
                        return True
                
                    def get(self, datasetType, dataId={}, immediate=False, **rest):
                        """Retrieves a dataset given an input collection data id.
                        
                        @param datasetType (str)   the type of dataset to retrieve.
                        @param dataId (dict)       the data id.
                        @param immediate (bool)    don't use a proxy for delayed loading.
                        @param **rest              keyword arguments for the data id.
                        @returns an object retrieved from the dataset (or a proxy for one).
                        """
                        dataId = self._combineDicts(dataId, **rest)
                        location = self.mapper.map(datasetType, dataId)
                        self.log.log(pexLog.Log.DEBUG, "Get type=%s keys=%s from %s" %
                                (datasetType, dataId, str(location)))
                
                        if location.getPythonType() is not None:
                            # import this pythonType dynamically 
                            pythonTypeTokenList = location.getPythonType().split('.')
                            importClassString = pythonTypeTokenList.pop()
                            importClassString = importClassString.strip()
                            importPackage = ".".join(pythonTypeTokenList)
                            importType = __import__(importPackage, globals(), locals(), \
                                    [importClassString], -1) 
                            pythonType = getattr(importType, importClassString)
                        else:
                            pythonType = None
                        if hasattr(self.mapper, "bypass_" + datasetType):
                            bypassFunc = getattr(self.mapper, "bypass_" + datasetType)
                            callback = lambda: bypassFunc(datasetType, pythonType,
                                    location, dataId)
                        else:
                            callback = lambda: self._read(pythonType, location)
                        if self.mapper.canStandardize(datasetType):
                            innerCallback = callback
                            callback = lambda: self.mapper.standardize(datasetType,
                                    innerCallback(), dataId)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
249  <a href="#b8a8f17e">b8a8f17e</a> -         if self.mapper.isAggregate(datasetType):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
250  <a href="#b8a8f17e">b8a8f17e</a> -             callback = lambda: self.mapper.buildAggregate(datasetType,</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
251  <a href="#b8a8f17e">b8a8f17e</a> -                     dataId, self)</div>
                        if immediate:
                            return callback()
                        return ReadProxy(callback)
                
                    def put(self, obj, datasetType, dataId={}, doBackup=False, **rest):
                        """Persists a dataset given an output collection data id.
                        
                        @param obj                 the object to persist.
                        @param datasetType (str)   the type of dataset to persist.
                        @param dataId (dict)       the data id.
                        @param doBackup            if True, rename existing instead of overwriting
                        @param **rest         keyword arguments for the data id.
                
                        WARNING: Setting doBackup=True is not safe for parallel processing, as it
                        may be subject to race conditions.
                        """
                        if doBackup:
                            self.mapper.backup(datasetType, dataId)
                        dataId = self._combineDicts(dataId, **rest)
                        location = self.mapper.map(datasetType, dataId, write=True)
                        self.log.log(pexLog.Log.DEBUG, "Put type=%s keys=%s to %s" %
                                (datasetType, dataId, str(location)))
                        additionalData = location.getAdditionalData()
                        storageName = location.getStorageName()
                        locations = location.getLocations()
                        # TODO support multiple output locations
                        locationString = locations[0]
                        logLoc = LogicalLocation(locationString, additionalData)
                        trace = pexLog.BlockTimingLog(self.log, "put",
                                                      pexLog.BlockTimingLog.INSTRUM+1)
                        trace.setUsageFlags(trace.ALLUDATA)
                
                        if storageName == "PickleStorage":
                            trace.start("write to %s(%s)" % (storageName, logLoc.locString()))
                            outDir = os.path.dirname(logLoc.locString())
                            if outDir != "" and not os.path.exists(outDir):
                                try:
                                    os.makedirs(outDir)
                                except OSError, e:
                                    # Don't fail if directory exists due to race
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
292  <a href="#4506d9c2">4506d9c2</a> -                     if e.errno != errno.EEXIST:</div>
              ?                                   ^^^^^^^^^^^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
283  <a href="#4a6d88b0">4a6d88b0</a> +                     if e.errno != 17:</div>
              ?                                   ^^
                                        raise e
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
294  <a href="#4506d9c2">4506d9c2</a> -             # to avoid race cond, make a temporary file and rename it</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
295  <a href="#4506d9c2">4506d9c2</a> -             tmpFile = tempfile.mkstemp(dir=outDir)[1]</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
296  <a href="#4506d9c2">4506d9c2</a> -             with open(tmpFile, "wb") as outfile:</div>
              ?                        ^^^ ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
285  <a href="#b2289425">b2289425</a> +             with open(logLoc.locString(), "wb") as outfile:</div>
              ?                       +++++++++++ ^ ^^^^
                                cPickle.dump(obj, outfile, cPickle.HIGHEST_PROTOCOL)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
298  <a href="#4506d9c2">4506d9c2</a> -             os.rename(tmpFile, logLoc.locString())</div>
                            trace.done()
                            return
                
                        if storageName == "ConfigStorage":
                            trace.start("write to %s(%s)" % (storageName, logLoc.locString()))
                            outDir = os.path.dirname(logLoc.locString())
                            if outDir != "" and not os.path.exists(outDir):
                                try:
                                    os.makedirs(outDir)
                                except OSError, e:
                                    # Don't fail if directory exists due to race
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
310  <a href="#4506d9c2">4506d9c2</a> -                     if e.errno != errno.EEXIST:</div>
              ?                                   ^^^^^^^^^^^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
298  <a href="#e42658a3">e42658a3</a> +                     if e.errno != 17:</div>
              ?                                   ^^
                                        raise e
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
312  <a href="#4506d9c2">4506d9c2</a> -             # to avoid race cond, make a temporary file and rename it</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
313  <a href="#4506d9c2">4506d9c2</a> -             tmpFile = tempfile.mkstemp(dir=outDir)[1]</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
314  <a href="#4506d9c2">4506d9c2</a> -             obj.save(tmpFile)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
315  <a href="#4506d9c2">4506d9c2</a> -             os.rename(tmpFile, logLoc.locString())</div>
              ?               ---- ^  ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
300  <a href="#e42658a3">e42658a3</a> +             obj.save(logLoc.locString())</div>
              ?              +++  ^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
316  <a href="#e42658a3">e42658a3</a> -             trace.done()</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
317  <a href="#e42658a3">e42658a3</a> -             return</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
318  <a href="#e42658a3">e42658a3</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
319  <a href="#4c72f843">4c72f843</a> -         if storageName == 'EupsStorage':</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
320  <a href="#4c72f843">4c72f843</a> -             trace.start("write to %s(%s)" % (storageName, logLoc.locString()))</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
321  <a href="#d505cde2">d505cde2</a> -             outDir = os.path.dirname(logLoc.locString())</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
322  <a href="#d505cde2">d505cde2</a> -             if outDir != "" and not os.path.exists(outDir):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
323  <a href="#d505cde2">d505cde2</a> -                 try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
324  <a href="#d505cde2">d505cde2</a> -                     os.makedirs(outDir)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
325  <a href="#d505cde2">d505cde2</a> -                 except OSError, e:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
326  <a href="#4506d9c2">4506d9c2</a> -                     # Don't fail if directory exists due to race</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
327  <a href="#4506d9c2">4506d9c2</a> -                     if e.errno != errno.EEXIST:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
328  <a href="#d505cde2">d505cde2</a> -                         raise e</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
329  <a href="#4506d9c2">4506d9c2</a> -             # to avoid race cond, make a temporary file and rename it</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
330  <a href="#4506d9c2">4506d9c2</a> -             tmpFile = tempfile.mkstemp(dir=outDir)[1]</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
331  <a href="#4506d9c2">4506d9c2</a> -             obj.write(tmpFile)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
332  <a href="#4506d9c2">4506d9c2</a> -             os.rename(tmpFile, logLoc.locString())</div>
                            trace.done()
                            return
                
                        if storageName == "FitsCatalogStorage":
                            trace.start("write to %s(%s)" % (storageName, logLoc.locString()))
                            outDir = os.path.dirname(logLoc.locString())
                            if outDir != "" and not os.path.exists(outDir):
                                try:
                                    os.makedirs(outDir)
                                except OSError, e:
                                    # Don't fail if directory exists due to race
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
344  <a href="#4506d9c2">4506d9c2</a> -                     if e.errno != errno.EEXIST:</div>
              ?                                   ^^^^^^^^^^^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
312  <a href="#d275e00d">d275e00d</a> +                     if e.errno != 17:</div>
              ?                                   ^^
                                        raise e
                            flags = additionalData.getInt("flags", 0)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
347  <a href="#0789a647">0789a647</a> -             self._addMetadata(obj, dataId)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
348  <a href="#b9fa11f6">b9fa11f6</a> -             try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
349  <a href="#4506d9c2">4506d9c2</a> -                 # to avoid race cond, make a temporary file and rename it</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
350  <a href="#4506d9c2">4506d9c2</a> -                 tmpFile = tempfile.mkstemp(dir=outDir)[1]</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
351  <a href="#4506d9c2">4506d9c2</a> -                 obj.writeFits(tmpFile, flags=flags)</div>
              ? ----                           ^^^ ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
315  <a href="#7831a66a">7831a66a</a> +             obj.writeFits(logLoc.locString(), flags=flags)</div>
              ?                           +++++++++++ ^ ^^^^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
352  <a href="#4506d9c2">4506d9c2</a> -                 os.rename(tmpFile, logLoc.locString())</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
353  <a href="#b9fa11f6">b9fa11f6</a> -             finally:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
354  <a href="#b9fa11f6">b9fa11f6</a> -                 self._removeMetadata(obj)</div>
                            trace.done()
                            return
                
                        # Create a list of Storages for the item.
                        storageList = StorageList()
                        storage = self.persistence.getPersistStorage(storageName, logLoc)
                        storageList.append(storage)
                        trace.start("write to %s(%s)" % (storageName, logLoc.locString()))
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
363  <a href="#3b7c674c">3b7c674c</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
364  <a href="#e37f6603">e37f6603</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
365  <a href="#e37f6603">e37f6603</a> -         if storageName == 'FitsStorage':</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
366  <a href="#0789a647">0789a647</a> -             self._addMetadata(obj, dataId)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
367  <a href="#b9fa11f6">b9fa11f6</a> -             try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
368  <a href="#b9fa11f6">b9fa11f6</a> -                 self.persistence.persist(obj, storageList, additionalData)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
369  <a href="#b9fa11f6">b9fa11f6</a> -             finally:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
370  <a href="#b9fa11f6">b9fa11f6</a> -                 self._removeMetadata(obj)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
371  <a href="#e37f6603">e37f6603</a> -             trace.done()</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
372  <a href="#e37f6603">e37f6603</a> -             return</div>
                
                        # Persist the item.
                        if hasattr(obj, '__deref__'):
                            # We have a smart pointer, so dereference it.
                            self.persistence.persist(
                                    obj.__deref__(), storageList, additionalData)
                        else:
                            self.persistence.persist(obj, storageList, additionalData)
                        trace.done()
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
382  <a href="#3b7c674c">3b7c674c</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
383  <a href="#0789a647">0789a647</a> -     def _removeMetadata(self, obj):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
384  <a href="#ad63cb8b">ad63cb8b</a> -         """Remove specific k,v pairs which we recently added from metadata</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
385  <a href="#ad63cb8b">ad63cb8b</a> -         """</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
386  <a href="#ad63cb8b">ad63cb8b</a> -         try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
387  <a href="#0789a647">0789a647</a> -             md = obj.getMetadata()</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
388  <a href="#ad63cb8b">ad63cb8b</a> -         except AttributeError:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
389  <a href="#ad63cb8b">ad63cb8b</a> -             return</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
390  <a href="#ad63cb8b">ad63cb8b</a> -         if md is None:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
391  <a href="#ad63cb8b">ad63cb8b</a> -             return</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
392  <a href="#ad63cb8b">ad63cb8b</a> -         md.remove("HSCPIPE_VERSION")</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
393  <a href="#ad63cb8b">ad63cb8b</a> -         md.remove("HOST")</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
394  <a href="#ad63cb8b">ad63cb8b</a> -         md.remove("USER")</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
395  <a href="#ad63cb8b">ad63cb8b</a> -         md.remove("ROOT_PATH")</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
396  <a href="#0789a647">0789a647</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
397  <a href="#0789a647">0789a647</a> -     def _addMetadata(self, obj, dataId):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
398  <a href="#ad63cb8b">ad63cb8b</a> -         """Add some information to objects containing 'metadata'.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
399  <a href="#ad63cb8b">ad63cb8b</a> -         """</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
400  <a href="#ad63cb8b">ad63cb8b</a> -         try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
401  <a href="#ad63cb8b">ad63cb8b</a> -             md = obj.getMetadata()</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
402  <a href="#ad63cb8b">ad63cb8b</a> -         except AttributeError:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
403  <a href="#ad63cb8b">ad63cb8b</a> -             return</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
404  <a href="#ad63cb8b">ad63cb8b</a> -         if md is None:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
405  <a href="#0789a647">0789a647</a> -             return</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
406  <a href="#0789a647">0789a647</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
407  <a href="#0789a647">0789a647</a> -         # get the pipe version to stick in the header/metadata</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
408  <a href="#0789a647">0789a647</a> -         try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
409  <a href="#0789a647">0789a647</a> -             import hsc.pipe.tasks.version as hptv</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
410  <a href="#0789a647">0789a647</a> -             pipeVersion = hptv.__version__</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
411  <a href="#b9fa11f6">b9fa11f6</a> -         except ImportError:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
412  <a href="#b9fa11f6">b9fa11f6</a> -             pipeVersion = "unknown"</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
413  <a href="#b9fa11f6">b9fa11f6</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
414  <a href="#0789a647">0789a647</a> -         md.add("HSCPIPE_VERSION", pipeVersion)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
415  <a href="#0789a647">0789a647</a> -         md.add("HOST", socket.gethostname())</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
416  <a href="#0789a647">0789a647</a> -         md.add("USER", getpass.getuser())</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
417  <a href="#0789a647">0789a647</a> -         md.add("ROOT_PATH", self.mapper.root)</div>
                
                    def subset(self, datasetType, level=None, dataId={}, **rest):
                        """Extracts a subset of a dataset collection.
                        
                        Given a partial dataId specified in dataId and **rest, find all
                        datasets at a given level specified by a dataId key (e.g. visit or
                        sensor or amp for a camera) and return a collection of their dataIds
                        as ButlerDataRefs.
                
                        @param datasetType (str)  the type of dataset collection to subset
                        @param level (str)        the level of dataId at which to subset
                        @param dataId (dict)      the data id.
                        @param **rest             keyword arguments for the data id.
                        @returns (ButlerSubset) collection of ButlerDataRefs for datasets
                        matching the data id."""
                
                        if level is None:
                            level = self.mapper.getDefaultLevel()
                        dataId = self._combineDicts(dataId, **rest)
                        return ButlerSubset(self, datasetType, level, dataId)
                
                    def dataRef(self, datasetType, level=None, dataId={}, **rest):
                        """Returns a single ButlerDataRef.
                
                        Given a complete dataId specified in dataId and **rest, find the
                        unique dataset at the given level specified by a dataId key (e.g.
                        visit or sensor or amp for a camera) and return a ButlerDataRef.
                
                        @param datasetType (str)  the type of dataset collection to reference
                        @param level (str)        the level of dataId at which to reference
                        @param dataId (dict)      the data id.
                        @param **rest             keyword arguments for the data id.
                        @returns (ButlerDataRef) ButlerDataRef for dataset matching the data id
                        """
                
                        subset = self.subset(datasetType, level, dataId, **rest)
                        if len(subset) != 1:
                            raise RuntimeError, """No unique dataset for:
                    Dataset type = %s
                    Level = %s
                    Data ID = %s
                    Keywords = %s""" % (str(datasetType), str(level), str(dataId), str(rest))
                        return ButlerDataRef(subset, subset.cache[0])
                
                    def _combineDicts(self, dataId, **rest):
                        finalId = {}
                        finalId.update(dataId)
                        finalId.update(rest)
                        return finalId
                
                    def _read(self, pythonType, location):
                        trace = pexLog.BlockTimingLog(self.log, "read",
                                                      pexLog.BlockTimingLog.INSTRUM+1)
                        
                        additionalData = location.getAdditionalData()
                        # Create a list of Storages for the item.
                        storageName = location.getStorageName()
                        results = []
                        locations = location.getLocations()
                        returnList = True
                        if len(locations) == 1:
                            returnList = False
                
                        for locationString in locations:
                            logLoc = LogicalLocation(locationString, additionalData)
                            trace.start("read from %s(%s)" % (storageName, logLoc.locString()))
                            
                            if storageName == "PafStorage":
                                finalItem = pexPolicy.Policy.createPolicy(logLoc.locString())
                            elif storageName == "PickleStorage":
                                if not os.path.exists(logLoc.locString()):
                                    raise RuntimeError, \
                                            "No such pickle file: " + logLoc.locString()
                                with open(logLoc.locString(), "rb") as infile:
                                    finalItem = cPickle.load(infile)
                            elif storageName == "FitsCatalogStorage":
                                if not os.path.exists(logLoc.locString()):
                                    raise RuntimeError, \
                                            "No such FITS catalog file: " + logLoc.locString()
                                hdu = additionalData.getInt("hdu", 0)
                                flags = additionalData.getInt("flags", 0)
                                finalItem = pythonType.readFits(logLoc.locString(), hdu, flags)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
500  <a href="#d505cde2">d505cde2</a> -             elif storageName == "EupsStorage":</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
501  <a href="#d505cde2">d505cde2</a> -                 if not os.path.exists(logLoc.locString()):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
502  <a href="#d505cde2">d505cde2</a> -                     raise RuntimeError, "No such eups.versions file: " + logLoc.locString()</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
503  <a href="#d505cde2">d505cde2</a> -                 finalItem = pythonType(logLoc.locString())</div>
                            elif storageName == "ConfigStorage":
                                if not os.path.exists(logLoc.locString()):
                                    raise RuntimeError, \
                                            "No such config file: " + logLoc.locString()
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
508  <a href="#0ee7da3a">0ee7da3a</a> -                 try:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
509  <a href="#0ee7da3a">0ee7da3a</a> -                     finalItem = pythonType()</div>
              ? ----
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
419  <a href="#44f60f31">44f60f31</a> +                 finalItem = pythonType()</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
510  <a href="#0ee7da3a">0ee7da3a</a> -                     finalItem.load(logLoc.locString())</div>
              ? ----
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
420  <a href="#44f60f31">44f60f31</a> +                 finalItem.load(logLoc.locString())</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
511  <a href="#0ee7da3a">0ee7da3a</a> -                 except AssertionError:</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
512  <a href="#0ee7da3a">0ee7da3a</a> -                     # assert in the config file says wrong class, but it may be a derived class</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
513  <a href="#0ee7da3a">0ee7da3a</a> -                     finalItem = pexConfig.load(logLoc.locString())</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
514  <a href="#0ee7da3a">0ee7da3a</a> -                     if not isinstance(finalItem, pythonType):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
515  <a href="#0ee7da3a">0ee7da3a</a> -                         raise TypeError("Incorrect type when loading config: expected %s, got %s"</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
516  <a href="#c0082eae">c0082eae</a> -                                         % (pythonType, type(finalItem)))</div>
                            else:
                                storageList = StorageList()
                                storage = self.persistence.getRetrieveStorage(storageName, logLoc)
                                storageList.append(storage)
                                itemData = self.persistence.unsafeRetrieve(
                                        location.getCppType(), storageList, additionalData)
                                finalItem = pythonType.swigConvert(itemData)
                            trace.done()
                            results.append(finalItem)
                
                        if not returnList:
                            results = results[0]
                        return results
                
                    def __reduce__(self):
                        return (_unreduce, (self.mapper,))
                
                
                def _unreduce(mapper):
                    return Butler(root=None, mapper=mapper)
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="d505cde2"/></a>d505cde2</h3>

<pre>
commit d505cde2cd801c86919915285cd717a24aaf5a52
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Thu May 1 15:55:24 2014 +0900

    move eups_versions code to separate class.
</pre>
<h3><a name="b8a8f17e"/></a>b8a8f17e</h3>

<pre>
commit b8a8f17eb4b4e066d89dc43f28688a92b75fca70
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Tue Feb 26 21:54:54 2013 +0900

    Add new Mapper API for datasets that are built (by a mapper subclass) from other datasets (one possible solution for #2695).
</pre>
<h3><a name="f9540de3"/></a>f9540de3</h3>

<pre>
commit f9540de3677226c061dba36dd019f115e7eae336
Author: Hisanori Furusawa <furusawa.hisanori@nao.ac.jp>
Date:   Wed Apr 15 16:48:07 2015 +0900

    import errno to use errno.EEXIST
</pre>
<h3><a name="3026f37a"/></a>3026f37a</h3>

<pre>
commit 3026f37a17be10b4fe966b5bf9c2131e629bb221
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Wed Apr 2 16:35:06 2014 +0900

    declare EupsStorage in datasetExists method
</pre>
<h3><a name="0ee7da3a"/></a>0ee7da3a</h3>

<pre>
commit 0ee7da3a68e7c988c647cff45410e1e226800ae0
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Thu Apr 4 23:33:45 2013 -0400

    Be more permissive about types when loading configs
</pre>
<h3><a name="b9fa11f6"/></a>b9fa11f6</h3>

<pre>
commit b9fa11f6e081e21279f801b1e4bb9b1c3fe0914f
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Fri Apr 18 17:45:39 2014 +0900

    remove metadata even if writeFits fails (try/finally)
</pre>
<h3><a name="ad63cb8b"/></a>ad63cb8b</h3>

<pre>
commit ad63cb8b85628b123e1d8841196c44d648680758
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Thu Apr 17 12:04:24 2014 +0900

    change hasattr check for metadata to a try/except.
</pre>
<h3><a name="4c72f843"/></a>4c72f843</h3>

<pre>
commit 4c72f8435c55ad8855f4fc87de8e69805402a621
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Wed Apr 2 16:18:23 2014 +0900

    add write eups versions
</pre>
<h3><a name="e37f6603"/></a>e37f6603</h3>

<pre>
commit e37f6603b49b8ee5347fc4d2ca11500d25041276
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Sat Mar 22 02:17:51 2014 +0900

    dump HSCPIPE_VERSION to fits headers via butler put() method
</pre>
<h3><a name="c0082eae"/></a>c0082eae</h3>

<pre>
commit c0082eae326e1f5bc0b947a0a8cd57f40e70b79d
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Mon Apr 8 11:51:10 2013 -0400

    Fix string formatting bug when raising exception on bad config types.
</pre>
<h3><a name="e42658a3"/></a>e42658a3</h3>

<pre>
commit e42658a37c44aaec82450d34fcade3707e001e9b
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Mon Feb 27 15:45:32 2012 -0600

    Add ConfigStorage for Config objects with save() methods.
</pre>
<h3><a name="0789a647"/></a>0789a647</h3>

<pre>
commit 0789a6476d4547bcb90a69210addd9b705316253
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Wed Apr 16 10:10:16 2014 +0900

    Add HOST,USER,PATH to metadata for fits outputs
</pre>
<h3><a name="4506d9c2"/></a>4506d9c2</h3>

<pre>
commit 4506d9c2f919ec7adf875451bcc71cc30703259a
Author: Hisanori Furusawa <furusawa.hisanori@nao.ac.jp>
Date:   Fri Mar 27 14:31:58 2015 +0900

    write and rename temp file for more storage types
</pre>
<h3><a name="3b7c674c"/></a>3b7c674c</h3>

<pre>
commit 3b7c674c47f5d4cea81eaacb36cbdf04bf6d2cb7
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Apr 1 00:19:15 2010 +0000

    Initial checkin of data butler code.  Missing actual mapper classes.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="4a6d88b0"/></a>4a6d88b0</h3>

<pre>
commit 4a6d88b01b2dc6d8ae5adcb22fee520725070040
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Wed Dec 15 18:05:51 2010 +0000

    Fix race condition in PickleStorage output.
</pre>
<h3><a name="d275e00d"/></a>d275e00d</h3>

<pre>
commit d275e00d768c263914987f9970a798fc0923048b
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Wed Feb 29 13:02:37 2012 -0500

    added write support for FitsCatalogStorage
</pre>
<h3><a name="44f60f31"/></a>44f60f31</h3>

<pre>
commit 44f60f31205243f1c9fe8622224171d9872c28ab
Author: Serge Monkewitz <smm@ipac.caltech.edu>
Date:   Thu May 3 21:42:47 2012 -0500

    Butler did not support reading config files. Fix that.
</pre>
<h3><a name="6a906173"/></a>6a906173</h3>

<pre>
commit 6a906173a9a32ac213ea84fea5ad7579d6c5927b
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue May 4 00:57:31 2010 +0000

    Add !PickleStorage and a test.
</pre>
<h3><a name="b2289425"/></a>b2289425</h3>

<pre>
commit b22894255d89ae7a75ff2de9c20b9e24a7d35616
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Nov 12 23:48:21 2010 +0000

    Make output directory for PickleStorage if it doesn't exist.
</pre>
<h3><a name="7831a66a"/></a>7831a66a</h3>

<pre>
commit 7831a66a06f1695b0e63cf154c06df75a7300293
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Tue Jun 18 20:57:33 2013 -0600

    Look for flags and hdu arguments in additionalData in FitsCatalogStorage
</pre>
<h3><a name="e42658a3"/></a>e42658a3</h3>

<pre>
commit e42658a37c44aaec82450d34fcade3707e001e9b
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Mon Feb 27 15:45:32 2012 -0600

    Add ConfigStorage for Config objects with save() methods.
</pre>
</div>


[Return to list](#homelist)
# <a name="src/DbStorageLocation.cc"/></a>src/DbStorageLocation.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** \file
                 * \brief Implementation for DbStorageLocation class
                 *
                 * \author $Author$
                 * \version $Revision$
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/DbStorageLocation.h"
                
                #include <boost/regex.hpp>
                
                #include "lsst/pex/exceptions.h"
                #include "lsst/daf/persistence/DbAuth.h"
                
                namespace lsst {
                namespace daf {
                namespace persistence {
                
                /** Default constructor.
                 */
                DbStorageLocation::DbStorageLocation(void) :
                    lsst::daf::base::Citizen(typeid(*this)),
                    _dbType(), _hostname(), _port(), _username(), _password(), _dbName() {
                }
                
                /** Constructor from CORAL-style URL.
                 * \param[in] url CORAL-style connection string (database type, hostname,
                 * port, database name)
                 */
                DbStorageLocation::DbStorageLocation(std::string const& url) :
                    lsst::daf::base::Citizen(typeid(*this)) {
                    boost::smatch what;
                    boost::regex
                        expression("(\\w+)://(\\S+):(\\d+)/(\\S+)");
                    if (boost::regex_match(url, what, expression)) {
                        _dbType = what[1];
                        _hostname = what[2];
                        _port = what[3];
                        _dbName = what[4];
                        _username = DbAuth::username(_hostname, _port);
                        _password = DbAuth::password(_hostname, _port);
                    }
                    else {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
78   <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::InvalidParameterException,</div>
              ?                                                                   ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
78   <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::InvalidParameterError,</div>
              ?                                                                   ^^ ^
                            "Unparseable connection string passed to DbStorageLocation: " +
                            url);
                    }
                }
                
                /** Destructor.
                 */
                DbStorageLocation::~DbStorageLocation(void) {
                }
                
                /** Produce a string (URL) representation of the DbStorageLocation.
                 * \return String suitable for constructing another DbStorageLocation
                 */
                std::string DbStorageLocation::toString(void) const {
                    return _dbType + "://" + _username + ":" + _password + "@" +
                        _hostname + ":" + _port + "/" + _dbName;
                }
                
                /** Produce a CORAL-style connection string representation of the
                 * DbStorageLocation.
                 * \return String suitable for passing to CORAL functions
                 */
                std::string DbStorageLocation::getConnString(void) const {
                    return _dbType + "://" + _hostname + ":" + _port + "/" + _dbName;
                }
                
                /** Accessor for database type.
                 * \return Reference to database type string.
                 */
                std::string const& DbStorageLocation::getDbType(void) const {
                    return _dbType;
                }
                
                /** Accessor for database hostname.
                 * \return Reference to database hostname string.
                 */
                std::string const& DbStorageLocation::getHostname(void) const {
                    return _hostname;
                }
                
                /** Accessor for database port number.
                 * \return Reference to database port number string.
                 */
                std::string const& DbStorageLocation::getPort(void) const {
                    return _port;
                }
                
                /** Accessor for username.
                 * \return Reference to username string.
                 */
                std::string const& DbStorageLocation::getUsername(void) const {
                    return _username;
                }
                
                /** Accessor for password.
                 * \return Reference to password string.
                 */
                std::string const& DbStorageLocation::getPassword(void) const {
                    return _password;
                }
                
                /** Accessor for database name.
                 * \return Reference to database name string.
                 */
                std::string const& DbStorageLocation::getDbName(void) const {
                    return _dbName;
                }
                
                }}} // namespace lsst::daf::persistence
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="9966404e"/></a>9966404e</h3>

<pre>
commit 9966404e8df345526d211ae57b1dc976149a8efd
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Dec 18 22:56:53 2008 +0000

    Merged revisions 6561-6817 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/persistence/tickets/492
    
    ........
      r6561 | ktlim | 2008-11-25 21:59:52 -0800 (Tue, 25 Nov 2008) | 2 lines
    
      Create branch for #492 (add PropertySetFormatter).
    ........
      r6712 | ktlim | 2008-12-09 19:35:00 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Replace DataPropertyFormatter with PropertySetFormatter.
    ........
      r6713 | ktlim | 2008-12-09 19:36:51 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change DataProperty to PropertySet.
    ........
      r6714 | ktlim | 2008-12-09 19:37:09 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change to new exceptions.
    ........
      r6715 | ktlim | 2008-12-09 19:37:25 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Add needed packages to table.
    ........
      r6732 | ktlim | 2008-12-13 15:31:12 -0800 (Sat, 13 Dec 2008) | 1 line
    
      Update tests to use PropertySet instead of DataProperty.
    ........
      r6739 | ktlim | 2008-12-14 15:00:54 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update build files to more modern structures.
    ........
      r6740 | ktlim | 2008-12-14 15:01:59 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update to more modern .i structure.
    ........
      r6763 | ktlim | 2008-12-15 15:53:26 -0800 (Mon, 15 Dec 2008) | 1 line
    
      Fix standards incompatibility detected by gcc4.
    ........
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="src/DbTsvStorage.cc"/></a>src/DbTsvStorage.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** \file
                 * \brief Implementation of DbTsvStorage class
                 *
                 * Writes rows to file, then uses "LOAD DATA INFILE" to load.
                 *
                 * \author $Author: ktlim $
                 * \version $Revision: 2336 $
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/DbTsvStorage.h"
                
                #include <iomanip>
                #include <stdlib.h>
                #include <string.h>
                #include <unistd.h>
                
                #include <mysql/mysql.h>
                
                #include "lsst/pex/exceptions.h"
                #include "lsst/daf/base/DateTime.h"
                #include "lsst/daf/persistence/DbStorageLocation.h"
                #include "lsst/daf/persistence/LogicalLocation.h"
                
                using lsst::daf::base::DateTime;
                
                namespace lsst {
                namespace daf {
                namespace persistence {
                
                /** Constructor.
                */
                DbTsvStorage::DbTsvStorage(void) : _saveTemp(false) {
                }
                
                /** Minimal destructor.
                 */
                DbTsvStorage::~DbTsvStorage(void) {
                }
                
                /** Allow a policy to be used to configure the DbTsvStorage.
                 * \param[in] policy
                 */
                void DbTsvStorage::setPolicy(lsst::pex::policy::Policy::Ptr policy) {
                    _tempPath = "/tmp";
                    if (policy && policy->exists("TempPath")) {
                        _tempPath = policy->getString("TempPath");
                    }
                    if (policy && policy->exists("SaveTemp") && policy->getBool("SaveTemp")) {
                        _saveTemp = true;
                    }
                }
                
                /** Set the database location to persist to.
                 * \param[in] location Database connection string to insert to.
                 */
                void DbTsvStorage::setPersistLocation(LogicalLocation const& location) {
                    _persisting = true;
                    _location = location.locString();
                    // Set the timezone for any DATE/TIME/DATETIME fields.
                    setenv("TZ", "UTC", 1);
                }
                
                /** Set the database location to retrieve from.
                 * \param[in] location Database connection string to retrieve from.
                 */
                void DbTsvStorage::setRetrieveLocation(LogicalLocation const& location) {
                    _persisting = false;
                    DbStorage::setRetrieveLocation(location);
                }
                
                /** Start a transaction.
                 */
                void DbTsvStorage::startTransaction(void) {
                    if (!_persisting) DbStorage::startTransaction();
                }
                
                /** End a transaction.
                 */
                void DbTsvStorage::endTransaction(void) {
                    if (!_persisting) {
                        DbStorage::endTransaction();
                        return;
                    }
                
                    // close stream
                    _osp->close();
                
                    MYSQL* db = mysql_init(0);
                    if (db == 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
125  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException, "Unable to allocate MySQL connection");</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
125  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError, "Unable to allocate MySQL connection");</div>
                    }
                    DbStorageLocation dbLoc(_location);
                    unsigned int port = strtoul(dbLoc.getPort().c_str(), 0, 10);
                    if (mysql_real_connect(db,
                                           dbLoc.getHostname().c_str(),
                                           dbLoc.getUsername().c_str(),
                                           dbLoc.getPassword().c_str(),
                                           dbLoc.getDbName().c_str(),
                                           port, 0,
                                           CLIENT_COMPRESS | CLIENT_LOCAL_FILES) == 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
136  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException,</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
136  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                            "Unable to connect to MySQL database: " + _location);
                    }
                    if (mysql_options(db, MYSQL_OPT_LOCAL_INFILE, 0) != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
140  <a href="#f7d17d26">f7d17d26</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException,</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
140  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                            std::string("Unable to set LOCAL INFILE option - * ") +
                            mysql_error(db));
                    }
                
                    std::string query = "LOAD DATA LOCAL INFILE";
                    query += " '";
                    query += _fileName;
                    query += "'";
                    query += " REPLACE";
                    query += " INTO TABLE `" + _tableName;
                    query += "` (";
                    for (std::map<std::string, int>::const_iterator it = _colMap.begin();
                         it != _colMap.end(); ++it) {
                        _rowBuffer[it->second] = it->first;
                    }
                    for (std::vector<std::string>::const_iterator it = _rowBuffer.begin();
                         it != _rowBuffer.end(); ++it) {
                        if (it != _rowBuffer.begin()) query += " ,";
                        query += *it;
                    }
                    query += ")";
                
                    if (mysql_query(db, query.c_str()) != 0) {
                        mysql_close(db);
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
165  <a href="#9966404e">9966404e</a> -         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeErrorException,</div>
              ?                                                              ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
165  <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(lsst::pex::exceptions::RuntimeError,</div>
                            "Unable to load data into database table: " + _tableName +
                            "- * " + mysql_error(db));
                    }
                    mysql_close(db);
                
                    // unlink file
                    if (!_saveTemp) {
                        unlink(_fileName);
                    }
                    delete[] _fileName;
                }
                
                /** Create a new table from an existing template table.
                 * \param[in] tableName Name of the new table
                 * \param[in] templateName Name of the existing template table
                 * \param[in] mayAlreadyExist False (default) if the table must not be present
                 */
                void DbTsvStorage::createTableFromTemplate(std::string const& tableName,
                                                        std::string const& templateName,
                                                        bool mayAlreadyExist) {
                    if (_persisting) {
                        DbStorage dbs;
                        dbs.setPersistLocation(LogicalLocation(_location));
                        dbs.startTransaction();
                        dbs.createTableFromTemplate(tableName, templateName, mayAlreadyExist);
                        dbs.endTransaction();
                    }
                    else {
                        DbStorage::createTableFromTemplate(tableName, templateName,
                                                           mayAlreadyExist);
                    }
                }
                
                /** Drop a table.
                 * \param[in] tableName Name of the table to drop
                 */
                void DbTsvStorage::dropTable(std::string const& tableName) {
                    if (_persisting) {
                        DbStorage dbs;
                        dbs.setPersistLocation(LogicalLocation(_location));
                        dbs.startTransaction();
                        dbs.dropTable(tableName);
                        dbs.endTransaction();
                    }
                    else {
                        DbStorage::dropTable(tableName);
                    }
                }
                
                /** Truncate a table.
                 * \param[in] tableName Name of the table to truncate
                 */
                void DbTsvStorage::truncateTable(std::string const& tableName) {
                    if (_persisting) {
                        DbStorage dbs;
                        dbs.setPersistLocation(LogicalLocation(_location));
                        dbs.startTransaction();
                        dbs.truncateTable(tableName);
                        dbs.endTransaction();
                    }
                    else {
                        DbStorage::truncateTable(tableName);
                    }
                }
                
                /** Set the table to insert rows into.
                 * \param[in] tableName Name of the table
                 */
                void DbTsvStorage::setTableForInsert(std::string const& tableName) {
                    _tableName = tableName;
                    std::string templ = _tempPath + "/" + tableName + ".XXXXXX";
                    _fileName = new char[templ.size() + 1];
                    strncpy(_fileName, templ.c_str(), templ.size());
                    _fileName[templ.size()] = '\0';
                    int fd = mkstemp(_fileName);
                    // \todo check for errors
                    close(fd);
                    _osp.reset(new std::ofstream(_fileName));
                }
                
                /** Get the index of a given column.  Create a new entry in the row buffer if
                 * the column hasn't already been seen.  May modify the row buffer, so do not
                 * call this inside "_rowBuffer[]".
                 * \param[in] columnName Name of the column
                 * \return Index of the column in the row buffer
                 */
                int DbTsvStorage::_getColumnIndex(std::string const& columnName) {
                    std::map<std::string, int>::iterator i = _colMap.find(columnName);
                    if (i == _colMap.end()) {
                        _colMap.insert(std::pair<std::string, int>(columnName,
                                                                   _rowBuffer.size()));
                        _rowBuffer.push_back(std::string());
                        return _rowBuffer.size() - 1;
                    }
                    else {
                        return i->second;
                    }
                }
                
                /** Set the value to insert in a given column.
                 * \param[in] columnName Name of the column
                 * \param[in] value Value to set in the column
                 */
                template <typename T>
                void DbTsvStorage::setColumn(std::string const& columnName, T const& value) {
                    int colIndex = _getColumnIndex(columnName);
                
                    // set value in row buffer
                    // \todo quote value as appropriate
                    _convertStream.str(std::string());
                    _convertStream << value;
                    _rowBuffer[colIndex] = _convertStream.str();
                
                    // \todo Optimization: if next column, output now, plus any others saved
                }
                
                // Specialization for char to persist as TINYINT instead of [VAR]CHAR(1).
                template<>
                void DbTsvStorage::setColumn(std::string const& columnName,
                                             char const& value) {
                    int colIndex = _getColumnIndex(columnName);
                    _convertStream.str(std::string());
                    _convertStream << static_cast<int>(value);
                    _rowBuffer[colIndex] = _convertStream.str();
                }
                
                // Specializations for float and double to set precision correctly.
                template<>
                void DbTsvStorage::setColumn(std::string const& columnName,
                                             double const& value) {
                    int colIndex = _getColumnIndex(columnName);
                    _convertStream.str(std::string());
                    _convertStream << std::setprecision(17) << value;
                    _rowBuffer[colIndex] = _convertStream.str();
                }
                
                template<>
                void DbTsvStorage::setColumn(std::string const& columnName,
                                             float const& value) {
                    int colIndex = _getColumnIndex(columnName);
                    _convertStream.str(std::string());
                    _convertStream << std::setprecision(9) << value;
                    _rowBuffer[colIndex] = _convertStream.str();
                }
                
                // Specialization for DateTime.
                template<>
                void DbTsvStorage::setColumn(std::string const& columnName,
                                             DateTime const& value) {
                    int colIndex = _getColumnIndex(columnName);
                    _convertStream.str(std::string());
                    struct tm t = value.gmtime();
                    char buf[20];
                    strftime(buf, sizeof(buf), "%F %T", &t);
                    _rowBuffer[colIndex] = std::string(buf);
                }
                
                /** Set a given column to NULL.
                 * \param[in] columnName Name of the column
                 */
                void DbTsvStorage::setColumnToNull(std::string const& columnName) {
                    int colIndex = _getColumnIndex(columnName);
                    _rowBuffer[colIndex] = "\\N";
                }
                
                /** Insert the row.
                 * Row values must have been set with setColumn() calls.
                 */
                void DbTsvStorage::insertRow(void) {
                    // Output row to stream
                    for (std::vector<std::string>::const_iterator i = _rowBuffer.begin();
                         i != _rowBuffer.end(); ++i) {
                        if (i != _rowBuffer.begin()) *_osp << '\t';
                        *_osp << *i;
                    }
                    // \todo Optimization: if columns all outputted, just put out endl
                    *_osp << std::endl;
                }
                
                
                // Forward template member functions to the base class.
                
                /** Request a column in the query output and bind a destination location.
                 * \param[in] columnName Name of the column
                 * \param[in] location Pointer to the destination
                 * \param[in] isExpr True if the name is actually an expression
                 *
                 * The order of outParam() calls is the order of appearance in the output row.
                 * Use either outColumn() or outParam() but not both.
                 */
                template <typename T>
                void DbTsvStorage::outParam(std::string const& columnName, T* location,
                                            bool isExpr) {
                    DbStorage::outParam<T>(columnName, location, isExpr);
                }
                
                /** Bind a value to a WHERE condition parameter.
                 * \param[in] paramName Name of the parameter (prefixed by ":" in the WHERE
                 * clause)
                 * \param[in] value Value to be bound to the parameter.
                 */
                template <typename T>
                void DbTsvStorage::condParam(std::string const& paramName, T const& value) {
                    DbStorage::condParam<T>(paramName, value);
                }
                
                /** Get the value of a column of the query result row by position.
                 * \param[in] pos Position of the column (starts at 0)
                 */
                template <typename T>
                T const& DbTsvStorage::getColumnByPos(int pos) {
                    return DbStorage::getColumnByPos<T>(pos);
                }
                
                
                // Explicit template member function instantiations.
                // Ignore for doxygen processing.
                //! \cond
                template void DbTsvStorage::setColumn<>(std::string const& columnName, char const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, short const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, int const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, long const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, long long const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, float const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, double const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, std::string const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, bool const& value);
                template void DbTsvStorage::setColumn<>(std::string const& columnName, DateTime const& value);
                
                template void DbTsvStorage::outParam<>(std::string const& columnName, char* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, short* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, int* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, long* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, long long* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, float* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, double* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, std::string* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, bool* location, bool isExpr);
                template void DbTsvStorage::outParam<>(std::string const& columnName, DateTime* location, bool isExpr);
                
                template void DbTsvStorage::condParam<>(std::string const& paramName, char const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, short const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, int const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, long const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, long long const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, float const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, double const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, std::string const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, bool const& value);
                template void DbTsvStorage::condParam<>(std::string const& paramName, DateTime const& value);
                
                template char const& DbTsvStorage::getColumnByPos<>(int pos);
                template short const& DbTsvStorage::getColumnByPos<>(int pos);
                template int const& DbTsvStorage::getColumnByPos<>(int pos);
                template long const& DbTsvStorage::getColumnByPos<>(int pos);
                template long long const& DbTsvStorage::getColumnByPos<>(int pos);
                template float const& DbTsvStorage::getColumnByPos<>(int pos);
                template double const& DbTsvStorage::getColumnByPos<>(int pos);
                template std::string const& DbTsvStorage::getColumnByPos<>(int pos);
                template bool const& DbTsvStorage::getColumnByPos<>(int pos);
                template DateTime const& DbTsvStorage::getColumnByPos<>(int pos);
                //! \endcond
                
                }}} // namespace lsst::daf::persistence
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="9966404e"/></a>9966404e</h3>

<pre>
commit 9966404e8df345526d211ae57b1dc976149a8efd
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Thu Dec 18 22:56:53 2008 +0000

    Merged revisions 6561-6817 via svnmerge from
    svn+ssh://svn.lsstcorp.org/DMS/daf/persistence/tickets/492
    
    ........
      r6561 | ktlim | 2008-11-25 21:59:52 -0800 (Tue, 25 Nov 2008) | 2 lines
    
      Create branch for #492 (add PropertySetFormatter).
    ........
      r6712 | ktlim | 2008-12-09 19:35:00 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Replace DataPropertyFormatter with PropertySetFormatter.
    ........
      r6713 | ktlim | 2008-12-09 19:36:51 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change DataProperty to PropertySet.
    ........
      r6714 | ktlim | 2008-12-09 19:37:09 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Change to new exceptions.
    ........
      r6715 | ktlim | 2008-12-09 19:37:25 -0800 (Tue, 09 Dec 2008) | 1 line
    
      Add needed packages to table.
    ........
      r6732 | ktlim | 2008-12-13 15:31:12 -0800 (Sat, 13 Dec 2008) | 1 line
    
      Update tests to use PropertySet instead of DataProperty.
    ........
      r6739 | ktlim | 2008-12-14 15:00:54 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update build files to more modern structures.
    ........
      r6740 | ktlim | 2008-12-14 15:01:59 -0800 (Sun, 14 Dec 2008) | 1 line
    
      Update to more modern .i structure.
    ........
      r6763 | ktlim | 2008-12-15 15:53:26 -0800 (Mon, 15 Dec 2008) | 1 line
    
      Fix standards incompatibility detected by gcc4.
    ........
</pre>
<h3><a name="f7d17d26"/></a>f7d17d26</h3>

<pre>
commit f7d17d26c2ecf02e426a5838c72d76b6f2a5ddc1
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Oct 19 13:17:13 2010 +0000

    Turn on LOCAL INFILE option in case it wasn't configured in mysqlclient.  Improve error message in case of failure.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="python/lsst/daf/persistence/__init__.py"/></a>python/lsst/daf/persistence/__init__.py
### Diff:

<pre>
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                """Python interface to lsst::daf::persistence classes
                """
                from persistenceLib import *
                from butlerLocation import *
                from readProxy import *
                from butlerSubset import *
                from butler import *
                from mapper import *
                from butlerFactory import *
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
32   <a href="#d505cde2">d505cde2</a> - from eupsVersions import *</div>
                from .version import *
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="d505cde2"/></a>d505cde2</h3>

<pre>
commit d505cde2cd801c86919915285cd717a24aaf5a52
Author: Steven Bickerton <steven.bickerton@gmail.com>
Date:   Thu May 1 15:55:24 2014 +0900

    move eups_versions code to separate class.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
</div>


[Return to list](#homelist)
# <a name="src/FitsStorage.cc"/></a>src/FitsStorage.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** \file
                 * \brief Implementation of FitsStorage class
                 *
                 * \author $Author$
                 * \version $Revision$
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/FitsStorage.h"
                
                #include <fstream>
                
                #include "lsst/daf/persistence/LogicalLocation.h"
                
                namespace lsst {
                namespace daf {
                namespace persistence {
                
                /** Constructor.
                 */
                FitsStorage::FitsStorage(void) : Storage(typeid(*this)) {
                }
                
                /** Destructor.
                 */
                FitsStorage::~FitsStorage(void) {
                }
                
                /** Allow a Policy to be used to configure the FitsStorage.
                 * \param[in] policy
                 */
                void FitsStorage::setPolicy(lsst::pex::policy::Policy::Ptr policy) {
                }
                
                /** Set the destination of the FITS file for persistence.
                 * \param[in] location Pathname to write to.
                 */
                void FitsStorage::setPersistLocation(LogicalLocation const& location) {
                    _path = location.locString();
                    _hdu = 0;
                    verifyPathName(_path);
                }
                
                /** Set the source of the FITS file for retrieval.
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
79   <a href="#f69b65eb">f69b65eb</a> -  * \param[in] location Pathname to read from, optionally followed by '#' and</div>
              ?                                                                      ^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
79   <a href="#df6066ec">df6066ec</a> +  * \param[in] location Pathname to read from, optionally followed by bracketed</div>
              ?                                                                      ^^ ^^^^^
                 * HDU number.
                 */
                void FitsStorage::setRetrieveLocation(LogicalLocation const& location) {
                    _path = location.locString();
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
84   <a href="#f69b65eb">f69b65eb</a> -     size_t loc = _path.find_last_of('#');</div>
              ?                                      ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
84   <a href="#df6066ec">df6066ec</a> +     size_t loc = _path.find_last_of('[');</div>
              ?                                      ^
                    if (loc == std::string::npos) {
                        _hdu = 0;
                    }
                    else {
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
89   <a href="#1f8ed596">1f8ed596</a> +         // HDUs for setHdu() are off by one from bracket extensions.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
89   <a href="#f69b65eb">f69b65eb</a> -         _hdu = strtol(_path.substr(loc + 1).c_str(), 0, 10);</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#1f8ed596">1f8ed596</a> +         _hdu = strtol(_path.substr(loc + 1).c_str(), 0, 10) + 1;</div>
              ?                                                            ++++
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
90   <a href="#f69b65eb">f69b65eb</a> -         _path = _path.substr(0, loc);</div>
                    }
                }
                
                /** Start a transaction.
                 * No transaction support for now.
                 */
                void FitsStorage::startTransaction(void) {
                }
                
                /** End a transaction.
                 * No transaction support for now.
                 */
                void FitsStorage::endTransaction(void) {
                }
                
                /** Return the pathname for the FITS file.
                 * \return Pathname
                 */
                std::string const& FitsStorage::getPath(void) {
                    return _path;
                }
                
                /** Return the HDU to read from the FITS file.
                 * \return Number of the HDU, PDU = 0
                 */
                int FitsStorage::getHdu(void) {
                    return _hdu;
                }
                
                }}} // namespace lsst::daf::persistence
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="f69b65eb"/></a>f69b65eb</h3>

<pre>
commit f69b65ebab9e2c985d935e21ee205bcf0b953a00
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Mar 28 01:07:49 2008 +0000

    Initial move of mwi/persistence to daf/persistence.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="df6066ec"/></a>df6066ec</h3>

<pre>
commit df6066ec5d47d542b9a5a3e14ef1af3a0859521b
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Thu Mar 27 03:41:05 2014 -0500

    Look for HDU in bracketed extension instead of '#' fragment identifier.
</pre>
<h3><a name="1f8ed596"/></a>1f8ed596</h3>

<pre>
commit 1f8ed5967807f1d67aaa6d9ea0d1fa9251e40dc1
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Thu Mar 27 13:36:45 2014 -0500

    Fix off-by-one error.
</pre>
</div>


[Return to list](#homelist)
# <a name="src/BoostStorage.cc"/></a>src/BoostStorage.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** \file
                 * \brief Implementation of BoostStorage class
                 *
                 * \author $Author$
                 * \version $Revision$
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/BoostStorage.h"
                
                #include <boost/format.hpp>
                #include <fstream>
                #include <unistd.h>
                
                #include "lsst/daf/persistence/LogicalLocation.h"
                
                namespace lsst {
                namespace daf {
                namespace persistence {
                
                /** Constructor.
                 */
                BoostStorage::BoostStorage(void) : Storage(typeid(*this)),
                    _ostream(0), _istream(0), _oarchive(0), _iarchive(0) {
                }
                
                /** Destructor.
                 */
                BoostStorage::~BoostStorage(void) {
                }
                
                /** Allow a Policy to be used to configure the BoostStorage.
                 * \param[in] policy
                 */
                void BoostStorage::setPolicy(lsst::pex::policy::Policy::Ptr policy) {
                }
                
                /** Set the destination of the serialization file for persistence.
                 * \param[in] location Pathname to write to.
                 */
                void BoostStorage::setPersistLocation(LogicalLocation const& location) {
                    verifyPathName(location.locString());
                    _ostream.reset(new std::ofstream(location.locString().c_str()));
                    _oarchive.reset(new boost::archive::text_oarchive(*_ostream));
                }
                
                /** Set the source of the serialization file for retrieval.
                 * \param[in] location Pathname to read from.
                 */
                void BoostStorage::setRetrieveLocation(LogicalLocation const& location) {
                    char const* fname = location.locString().c_str();
                    if (::access(fname, R_OK | F_OK) != 0) {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#8752b04b">8752b04b</a> -         throw LSST_EXCEPT(pexExcept::NotFoundException,</div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
87   <a href="#0c1dd2d0">0c1dd2d0</a> +         throw LSST_EXCEPT(pexExcept::NotFoundError,</div>
              ?                                               ^^ ^
                                          (boost::format("Unable to access file: %1%")
                                           % fname).str());
                    }
                    _istream.reset(new std::ifstream(fname));
                    _iarchive.reset(new boost::archive::text_iarchive(*_istream));
                }
                
                /** Start a transaction.
                 * No transaction support for now.
                 */
                void BoostStorage::startTransaction(void) {
                }
                
                /** End a transaction.
                 * No transaction support for now.
                 */
                void BoostStorage::endTransaction(void) {
                    _oarchive.reset(0);
                    _ostream.reset(0);
                    _iarchive.reset(0);
                    _istream.reset(0);
                }
                
                /** Get a \c boost::serialization archive suitable for output.
                 * \return Reference to a text output archive
                 */
                boost::archive::text_oarchive& BoostStorage::getOArchive(void) {
                    return *_oarchive;
                }
                
                /** Get a \c boost::serialization archive suitable for input.
                 * \return Reference to a text input archive
                 */
                boost::archive::text_iarchive& BoostStorage::getIArchive(void) {
                    return *_iarchive;
                }
                
                }}} // namespace lsst::daf::persistence
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="8752b04b"/></a>8752b04b</h3>

<pre>
commit 8752b04bd7b1c7a44a684ee6ed84936892861ad9
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Wed Sep 1 06:39:41 2010 +0000

    Check for Boost file existence and issue improved exception if file does not exist or is unreadable.  #1427
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="tests/Persistence_3.cc"/></a>tests/Persistence_3.cc
### Diff:

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * \file Persistence_3.cc
                 *
                 * This test checks that Persistable objects can be persisted and retrieved
                 * as components of PropertySet objects to and from BoostStorage.
                 */
                
                #include <sstream>
                #include <sys/time.h>
                #include "lsst/daf/base/PropertySet.h"
                #include "lsst/daf/persistence/BoostStorage.h"
                #include "lsst/daf/persistence/DbStorage.h"
                #include "lsst/daf/persistence/Formatter.h"
                #include "lsst/daf/persistence/LogicalLocation.h"
                #include "lsst/daf/persistence/Persistence.h"
                #include "lsst/pex/exceptions.h"
                
                #include <boost/serialization/export.hpp>
                
                #define BOOST_TEST_MODULE Persistence_3
                #define BOOST_TEST_DYN_LINK
                #include "boost/test/unit_test.hpp"
                
                namespace test = boost::test_tools;
                namespace dafBase = lsst::daf::base;
                namespace dafPersist = lsst::daf::persistence;
                
                // A small Persistable.
                
                // Forward declaration may be needed with gcc 4+.
                class MyFormatter;
                
                class MyPersistable : public dafBase::Persistable {
                public:
                    typedef boost::shared_ptr<MyPersistable> Ptr;
                    MyPersistable(double ra = 0.0, double decl = 0.0) : _ra(ra), _decl(decl) { };
                    double getRa(void) const { return _ra; };
                    double getDecl(void) const { return _decl; };
                private:
                    LSST_PERSIST_FORMATTER(MyFormatter);
                    double _ra;
                    double _decl;
                };
                
                BOOST_CLASS_EXPORT(MyPersistable);
                
                // A small Formatter.
                class MyFormatter : public dafPersist::Formatter {
                public:
                    MyFormatter(void) : dafPersist::Formatter(typeid(*this)) { };
                    virtual void write(dafBase::Persistable const* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    virtual dafBase::Persistable* read(dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    virtual void update(dafBase::Persistable* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    template <class Archive> static void delegateSerialize(Archive& ar, unsigned int const version, dafBase::Persistable* persistable);
                private:
                    static dafPersist::Formatter::Ptr createInstance(lsst::pex::policy::Policy::Ptr policy);
                    static dafPersist::FormatterRegistration registration;
                };
                
                // Include this file when implementing a Formatter.
                #include "lsst/daf/persistence/FormatterImpl.h"
                
                // Register the formatter factory function.
                dafPersist::FormatterRegistration MyFormatter::registration("MyPersistable", typeid(MyPersistable), createInstance);
                
                // The definition of the factory function.
                dafPersist::Formatter::Ptr MyFormatter::createInstance(lsst::pex::policy::Policy::Ptr policy) {
                    return dafPersist::Formatter::Ptr(new MyFormatter);
                }
                
                // Persistence for MyPersistables.
                // Supports BoostStorage only.
                void MyFormatter::write(dafBase::Persistable const* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    BOOST_FAIL("write() called unexpectedly");
                }
                
                // Retrieval for MyPersistables.
                // Supports BoostStorage only.
                dafBase::Persistable* MyFormatter::read(dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    BOOST_FAIL("read() called unexpectedly");
                    return 0;
                }
                
                void MyFormatter::update(dafBase::Persistable* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    BOOST_FAIL("update() called unexpectedly");
                }
                
                // Actually serialize the MyPersistable.
                // Send/get the RA and declination to/from the archive.
                template <class Archive> void MyFormatter::delegateSerialize(Archive& ar, unsigned int const version, dafBase::Persistable* persistable) {
                    MyPersistable* mp = dynamic_cast<MyPersistable*>(persistable);
                    ar & boost::serialization::base_object<dafBase::Persistable>(*mp);
                    ar & mp->_ra;
                    ar & mp->_decl;
                };
                
                ///////////////////////////////////////////////////////////////////////////////
                
                BOOST_AUTO_TEST_SUITE(Persistence3Suite)
                
                BOOST_AUTO_TEST_CASE(Persistence3Test) {
                    // Define a blank Policy.
                    lsst::pex::policy::Policy::Ptr policy(new lsst::pex::policy::Policy);
                
                    // Get a unique id for this test.
                    struct timeval tv;
                    gettimeofday(&tv, 0);      
                    long long testId = tv.tv_sec * 1000000LL + tv.tv_usec;
                
                    std::ostringstream os;
                    os << testId;
                    std::string testIdString = os.str();
                
                    dafBase::PropertySet::Ptr additionalData(new dafBase::PropertySet);
                    additionalData->add("info.visitId", testId);
                    additionalData->add("info.sliceId", 0);
                
                
                    dafBase::Persistable::Ptr ppOrig(new MyPersistable(1.73205, 1.61803));
                    dafBase::PropertySet::Ptr theProperty(new dafBase::PropertySet);
                    theProperty->add("prop", ppOrig);
                
                    dafPersist::LogicalLocation pathLoc("tests/data/MyPersistable.boost." + testIdString);
                
                    {
                        dafPersist::Persistence::Ptr persist = dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getPersistStorage("BoostStorage", pathLoc));
                        persist->persist(*theProperty, storageList, additionalData);
                    }
                
                    {
                        dafPersist::Persistence::Ptr persist = dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getRetrieveStorage("BoostStorage", pathLoc));
                        dafBase::Persistable::Ptr pp = persist->retrieve("PropertySet", storageList, additionalData);
                        BOOST_CHECK_MESSAGE(pp != 0, "Didn't get a Persistable");
                        BOOST_CHECK_MESSAGE(typeid(*pp) == typeid(dafBase::PropertySet), "Didn't get PropertySet");
                        dafBase::PropertySet::Ptr dp = boost::dynamic_pointer_cast<dafBase::PropertySet, dafBase::Persistable>(pp);
                        BOOST_CHECK_MESSAGE(dp, "Couldn't cast to PropertySet");
                        BOOST_CHECK_MESSAGE(dp != theProperty, "Got same PropertySet");
                        dafBase::Persistable::Ptr pp1 = dp->getAsPersistablePtr("prop");
                        BOOST_CHECK_MESSAGE(pp1, "Couldn't retrieve Persistable");
                        BOOST_CHECK_MESSAGE(typeid(*pp1) == typeid(MyPersistable), "Not a MyPersistable");
                        MyPersistable::Ptr mp = boost::dynamic_pointer_cast<MyPersistable, dafBase::Persistable>(pp1);
                        BOOST_CHECK_MESSAGE(mp, "Couldn't retrieve MyPersistable");
                        BOOST_CHECK_MESSAGE(mp->getRa() == 1.73205, "RA is incorrect");
                        BOOST_CHECK_MESSAGE(mp->getDecl() == 1.61803, "Decl is incorrect");
                    }
                    {
                        dafPersist::Persistence::Ptr persist = dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        dafPersist::LogicalLocation pathLoc("this.does.not.exist");
                        BOOST_CHECK_THROW(persist->getRetrieveStorage("BoostStorage", pathLoc),
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
177  <a href="#8752b04b">8752b04b</a> -                           pexExcept::NotFoundException);</div>
              ?                                               ^^^^^^ ^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
177  <a href="#0c1dd2d0">0c1dd2d0</a> +                           pexExcept::NotFoundError);</div>
              ?                                               ^^ ^
                    }
                
                }
                
                BOOST_AUTO_TEST_SUITE_END()
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="8752b04b"/></a>8752b04b</h3>

<pre>
commit 8752b04bd7b1c7a44a684ee6ed84936892861ad9
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Wed Sep 1 06:39:41 2010 +0000

    Check for Boost file existence and issue improved exception if file does not exist or is unreadable.  #1427
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="tests/Persistence_1.cc"/></a>tests/Persistence_1.cc
### Diff:

<pre>
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                /**
                 * This test tests much of the persistence framework, including Persistable,
                 * Persistence, Formatter, BoostStorage, DbStorage, and DbTsvStorage.
                 */
                extern "C" {
                #  include <sys/time.h>
                }
                #include "lsst/daf/persistence/BoostStorage.h"
                #include "lsst/daf/persistence/DbStorage.h"
                #include "lsst/daf/persistence/DbTsvStorage.h"
                #include "lsst/daf/persistence/Formatter.h"
                #include "lsst/daf/persistence/LogicalLocation.h"
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
35   <a href="#615041f9">615041f9</a> + #include "lsst/daf/persistence/DbAuth.h"</div>
                #include "lsst/daf/persistence/Persistence.h"
                
                #define BOOST_TEST_MODULE Persistence_1
                #define BOOST_TEST_DYN_LINK
                #include "boost/test/unit_test.hpp"
                
                namespace test = boost::test_tools;
                namespace dafBase = lsst::daf::base;
                namespace dafPersist = lsst::daf::persistence;
                
                // A small Persistable.
                
                // Forward declaration may be needed with gcc 4+.
                class MyFormatter;
                
                class MyPersistable : public dafBase::Persistable {
                public:
                    typedef boost::shared_ptr<MyPersistable> Ptr;
                    MyPersistable(double ra = 0.0, double decl = 0.0) : _ra(ra), _decl(decl) { };
                    double getRa(void) const { return _ra; };
                    double getDecl(void) const { return _decl; };
                private:
                    LSST_PERSIST_FORMATTER(MyFormatter);
                    double _ra;
                    double _decl;
                };
                
                // A small Formatter.
                class MyFormatter : public dafPersist::Formatter {
                public:
                    MyFormatter(void) : dafPersist::Formatter(typeid(*this)) { };
                    virtual void write(dafBase::Persistable const* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    virtual dafBase::Persistable* read(dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    virtual void update(dafBase::Persistable* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData);
                    template <class Archive> static void delegateSerialize(Archive& ar, unsigned int const version, dafBase::Persistable* persistable);
                private:
                    static dafPersist::Formatter::Ptr createInstance(lsst::pex::policy::Policy::Ptr policy);
                    static dafPersist::FormatterRegistration registration;
                };
                
                // Include this file when implementing a Formatter.
                #include "lsst/daf/persistence/FormatterImpl.h"
                
                // Register the formatter factory function.
                dafPersist::FormatterRegistration MyFormatter::registration("MyPersistable", typeid(MyPersistable), createInstance);
                
                // The definition of the factory function.
                dafPersist::Formatter::Ptr MyFormatter::createInstance(lsst::pex::policy::Policy::Ptr policy) {
                    return dafPersist::Formatter::Ptr(new MyFormatter);
                }
                
                // Persistence for MyPersistables.
                // Supports BoostStorage, DbStorage, and DbTsvStorage.
                void MyFormatter::write(dafBase::Persistable const* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    BOOST_CHECK_MESSAGE(persistable != 0, "Persisting null");
                    BOOST_CHECK_MESSAGE(storage, "No Storage provided");
                    long long testId = additionalData->get<long long>("visitId");
                    MyPersistable const* mp = dynamic_cast<MyPersistable const*>(persistable);
                    BOOST_CHECK_MESSAGE(mp != 0, "Persisting non-MyPersistable");
                    if (typeid(*storage) == typeid(dafPersist::BoostStorage)) {
                        dafPersist::BoostStorage* boost =
                            dynamic_cast<dafPersist::BoostStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(boost != 0, "Didn't get BoostStorage");
                        boost->getOArchive() & *mp;
                        return;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::DbStorage)) {
                        dafPersist::DbStorage* db =
                            dynamic_cast<dafPersist::DbStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(db != 0, "Didn't get DbStorage");
                        db->setTableForInsert("DbStorage_Test_1");
                        db->setColumn<long long>("id", testId);
                        db->setColumn<double>("ra", mp->_ra);
                        db->setColumn<double>("decl", mp->_decl);
                        db->setColumn<int>("something", 42);
                        db->insertRow();
                        return;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::DbTsvStorage)) {
                        dafPersist::DbTsvStorage* db =
                            dynamic_cast<dafPersist::DbTsvStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(db != 0, "Didn't get DbTsvStorage");
                        db->setTableForInsert("DbTsvStorage_Test_1");
                        db->setColumn<long long>("id", testId);
                        db->setColumn<double>("ra", mp->_ra);
                        db->setColumn<double>("decl", mp->_decl);
                        db->setColumnToNull("something");
                        db->insertRow();
                        return;
                    }
                    BOOST_FAIL("Didn't recognize Storage type");
                
                }
                
                // Retrieval for MyPersistables.
                // Supports BoostStorage, DbStorage, and DbTsvStorage.
                dafBase::Persistable* MyFormatter::read(dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    MyPersistable* mp = new MyPersistable;
                
                    long long testId = additionalData->get<long long>("visitId");
                    if (typeid(*storage) == typeid(dafPersist::BoostStorage)) {
                        dafPersist::BoostStorage* boost =
                            dynamic_cast<dafPersist::BoostStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(boost != 0, "Didn't get BoostStorage");
                        boost->getIArchive() & *mp;
                        return mp;
                    }
                    else if (typeid(*storage) == typeid(dafPersist::DbStorage) ||
                             typeid(*storage) == typeid(dafPersist::DbTsvStorage)) {
                        dafPersist::DbStorage* db =
                            dynamic_cast<dafPersist::DbStorage*>(storage.get());
                        BOOST_CHECK_MESSAGE(db != 0, "Didn't get DbStorage");
                        db->setTableForQuery("DbStorage_Test_1");
                        db->condParam<long long>("id", testId);
                        db->setQueryWhere("id = :id");
                        db->outParam("decl", &(mp->_decl));
                        db->outParam("ra", &(mp->_ra));
                
                        db->query();
                
                        BOOST_CHECK_MESSAGE(db->next() == true, "Failed to get row");
                        BOOST_CHECK_MESSAGE(db->columnIsNull(0) == false, "Null column 0");
                        BOOST_CHECK_MESSAGE(db->columnIsNull(1) == false, "Null column 1");
                        BOOST_CHECK_MESSAGE(db->next() == false, "Got more than one row");
                
                        db->finishQuery();
                        return mp;
                    }
                    BOOST_FAIL("Didn't recognize Storage type");
                    return mp;
                }
                
                void MyFormatter::update(dafBase::Persistable* persistable, dafPersist::Storage::Ptr storage, dafBase::PropertySet::Ptr additionalData) {
                    BOOST_FAIL("Shouldn't be updating");
                }
                
                // Actually serialize the MyPersistable.
                // Send/get the RA and declination to/from the archive.
                template <class Archive> void MyFormatter::delegateSerialize(Archive& ar, unsigned int const version, dafBase::Persistable* persistable) {
                    MyPersistable* mp = dynamic_cast<MyPersistable*>(persistable);
                    ar & boost::serialization::base_object<dafBase::Persistable>(*mp);
                    ar & mp->_ra;
                    ar & mp->_decl;
                };
                
                ///////////////////////////////////////////////////////////////////////////////
                
                BOOST_AUTO_TEST_SUITE(PersistenceSuite)
                
                BOOST_AUTO_TEST_CASE(PersistenceTest) {
                    // Define a blank Policy.
                    lsst::pex::policy::Policy::Ptr policy(new lsst::pex::policy::Policy);
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
189  <a href="#615041f9">615041f9</a> +     //If the user cannot access the test database, exit</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
190  <a href="#615041f9">615041f9</a> +     //without failing</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
191  <a href="#615041f9">615041f9</a> +     dafPersist::DbAuth testAuth;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
192  <a href="#615041f9">615041f9</a> +     testAuth.setPolicy(policy);</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
193  <a href="#615041f9">615041f9</a> +     if(!testAuth.available("lsst10.ncsa.uiuc.edu","3306")){</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
194  <a href="#615041f9">615041f9</a> +         return;</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
195  <a href="#615041f9">615041f9</a> +     }</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
196  <a href="#615041f9">615041f9</a> + </div>
                    // Get a unique id for this test.
                    struct timeval tv;
                    gettimeofday(&tv, 0);      
                    long long testId = tv.tv_sec * 1000000LL + tv.tv_usec;
                
                    std::ostringstream os;
                    os << testId;
                    std::string testIdString = os.str();
                
                    dafBase::PropertySet::Ptr additionalData(new dafBase::PropertySet);
                    additionalData->add("visitId", testId);
                    additionalData->add("sliceId", 0);
                
                    MyPersistable mp(1.73205, 1.61803);
                
                    dafPersist::LogicalLocation pathLoc("tests/data/MyPersistable.boost." + testIdString);
                    dafPersist::LogicalLocation dbLoc("mysql://lsst10.ncsa.uiuc.edu:3306/test");
                
                    {
                        dafPersist::Persistence::Ptr persist =
                            dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getPersistStorage("BoostStorage", pathLoc));
                        persist->persist(mp, storageList, additionalData);
                    }
                
                    {
                        dafPersist::Persistence::Ptr persist =
                            dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getPersistStorage("DbStorage", dbLoc));
                        persist->persist(mp, storageList, additionalData);
                    }
                
                    {
                        dafPersist::Persistence::Ptr persist =
                            dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getRetrieveStorage("BoostStorage", pathLoc));
                        dafBase::Persistable::Ptr pp = persist->retrieve("MyPersistable", storageList, additionalData);
                        BOOST_CHECK(pp != 0);
                        BOOST_CHECK(typeid(*pp) == typeid(MyPersistable));
                        MyPersistable::Ptr mp1 = boost::dynamic_pointer_cast<MyPersistable, dafBase::Persistable>(pp);
                        BOOST_CHECK(mp1);
                        BOOST_CHECK(mp1.get() != &mp);
                        BOOST_CHECK_EQUAL(mp1->getRa(), 1.73205);
                        BOOST_CHECK_EQUAL(mp1->getDecl(), 1.61803);
                    }
                
                    {
                        dafPersist::Persistence::Ptr persist =
                            dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getRetrieveStorage("DbStorage", dbLoc));
                        dafBase::Persistable::Ptr pp = persist->retrieve("MyPersistable", storageList, additionalData);
                        BOOST_CHECK(pp);
                        BOOST_CHECK(typeid(*pp) == typeid(MyPersistable));
                        MyPersistable::Ptr mp1 = boost::dynamic_pointer_cast<MyPersistable, dafBase::Persistable>(pp);
                        BOOST_CHECK(mp1);
                        BOOST_CHECK(mp1.get() != &mp);
                        BOOST_CHECK_EQUAL(mp1->getRa(), 1.73205);
                        BOOST_CHECK_EQUAL(mp1->getDecl(), 1.61803);
                    }
                
                    {
                        dafPersist::Persistence::Ptr persist =
                            dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getPersistStorage("DbTsvStorage", dbLoc));
                        persist->persist(mp, storageList, additionalData);
                    }
                
                    {
                        dafPersist::Persistence::Ptr persist =
                            dafPersist::Persistence::getPersistence(policy);
                        dafPersist::Storage::List storageList;
                        storageList.push_back(persist->getRetrieveStorage("DbTsvStorage", dbLoc));
                        dafBase::Persistable::Ptr pp = persist->retrieve("MyPersistable", storageList, additionalData);
                        BOOST_CHECK(pp);
                        BOOST_CHECK(typeid(*pp) == typeid(MyPersistable));
                        MyPersistable::Ptr mp1 = boost::dynamic_pointer_cast<MyPersistable, dafBase::Persistable>(pp);
                        BOOST_CHECK(mp1);
                        BOOST_CHECK(mp1.get() != &mp);
                        BOOST_CHECK_EQUAL(mp1->getRa(), 1.73205);
                        BOOST_CHECK_EQUAL(mp1->getDecl(), 1.61803);
                    }
                }
                
                BOOST_AUTO_TEST_SUITE_END()
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="615041f9"/></a>615041f9</h3>

<pre>
commit 615041f9996a0243e2ea3dec88dc42f64d9545d2
Author: danielsf <scott.f.daniel@gmail.com>
Date:   Fri May 8 10:17:06 2015 -0700

    removed the code that skips unit tests from the tests/SConscript
    
    added code to Persistence_2.py in tests/ that will simply exit
    without running any tests if the user does not have credentials
    for the necessary database
    
    added code to the C++ unit tests to exit without failing
    if the user does not have credentials to access the
    test database
    
    added comments explaining changes to unit test
</pre>
</div>


[Return to list](#homelist)
# <a name="ups/daf_persistence.table"/></a>ups/daf_persistence.table
### Diff:

<pre>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1    <a href="#ae7060f1">ae7060f1</a> - setupRequired(mysqlclient >= 5.1.44)</div>
              ?                          ----------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
1    <a href="#1c5efa13">1c5efa13</a> + setupRequired(mysqlclient)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
2    <a href="#60e51570">60e51570</a> - setupRequired(pex_logging >= 4.7.3.0)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
3    <a href="#60e51570">60e51570</a> - setupRequired(pex_policy >= 4.7.3.0)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
4    <a href="#eac8c14f">eac8c14f</a> - setupRequired(pex_config)</div>
              ?                   ^  --
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
2    <a href="#1c5efa13">1c5efa13</a> + setupRequired(pex_logging)</div>
              ?                   ^ +++
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
3    <a href="#1c5efa13">1c5efa13</a> + setupRequired(pex_policy)</div>
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#f69b65eb">f69b65eb</a> - envAppend(LD_LIBRARY_PATH, ${PRODUCT_DIR}/lib)</div>
              ?    ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
5    <a href="#f8ba5a94">f8ba5a94</a> + envPrepend(LD_LIBRARY_PATH, ${PRODUCT_DIR}/lib)</div>
              ?    ^^^
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
7    <a href="#f69b65eb">f69b65eb</a> - envAppend(DYLD_LIBRARY_PATH, ${PRODUCT_DIR}/lib)</div>
              ?    ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
6    <a href="#f8ba5a94">f8ba5a94</a> + envPrepend(DYLD_LIBRARY_PATH, ${PRODUCT_DIR}/lib)</div>
              ?    ^^^
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
9    <a href="#f69b65eb">f69b65eb</a> - envAppend(PYTHONPATH, ${PRODUCT_DIR}/python)</div>
              ?    ^^
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
8    <a href="#f8ba5a94">f8ba5a94</a> + envPrepend(PYTHONPATH, ${PRODUCT_DIR}/python)</div>
              ?    ^^^
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="60e51570"/></a>60e51570</h3>

<pre>
commit 60e515708e058f6074713c479a52ae323cbdbed7
Author: Serge Monkewitz <smm@ipac.caltech.edu>
Date:   Tue Dec 13 07:41:15 2011 -0600

    Adjust table file
</pre>
<h3><a name="eac8c14f"/></a>eac8c14f</h3>

<pre>
commit eac8c14f55173957e4a8bf852e172c813f1db4fc
Author: Paul Price <price@astro.princeton.edu>
Date:   Wed May 14 17:20:37 2014 -0400

    ups: pex_config is required for butler
</pre>
<h3><a name="ae7060f1"/></a>ae7060f1</h3>

<pre>
commit ae7060f1bc7bc63523ea90c9cb88bcde584c4191
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Tue Oct 19 14:30:28 2010 +0000

    Update mysqlclient version for gcc44 compatibility.
</pre>
<h3><a name="f69b65eb"/></a>f69b65eb</h3>

<pre>
commit f69b65ebab9e2c985d935e21ee205bcf0b953a00
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Mar 28 01:07:49 2008 +0000

    Initial move of mwi/persistence to daf/persistence.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="f8ba5a94"/></a>f8ba5a94</h3>

<pre>
commit f8ba5a943012af7d47b24dbacfd3577a6aaf1320
Author: Robyn Allsman <robyn@LSST.org>
Date:   Fri Nov 14 21:21:47 2014 -0600

    Replace envAppend with envPrepend in ups table files.
</pre>
<h3><a name="1c5efa13"/></a>1c5efa13</h3>

<pre>
commit 1c5efa139be152a6feb73c00174ad2d47967a236
Author: Mario Juric <mjuric@lsst.org>
Date:   Wed Mar 5 16:29:13 2014 -0600

    removed explicit versions from the table file.
</pre>
</div>


[Return to list](#homelist)
# <a name="src/LogicalLocation.cc"/></a>src/LogicalLocation.cc
### Diff:

<pre>
                // -*- lsst-c++ -*-
                
                /* 
                 * LSST Data Management System
                 * Copyright 2008, 2009, 2010 LSST Corporation.
                 * 
                 * This product includes software developed by the
                 * LSST Project (http://www.lsst.org/).
                 *
                 * This program is free software: you can redistribute it and/or modify
                 * it under the terms of the GNU General Public License as published by
                 * the Free Software Foundation, either version 3 of the License, or
                 * (at your option) any later version.
                 * 
                 * This program is distributed in the hope that it will be useful,
                 * but WITHOUT ANY WARRANTY; without even the implied warranty of
                 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 * GNU General Public License for more details.
                 * 
                 * You should have received a copy of the LSST License Statement and 
                 * the GNU General Public License along with this program.  If not, 
                 * see <http://www.lsstcorp.org/LegalNotices/>.
                 */
                 
                
                /** \file
                 * \brief Implementation of LogicalLocation class.
                 *
                 * \author $Author: ktlim $
                 * \version $Revision: 2286 $
                 * \date $Date$
                 *
                 * Contact: Kian-Tat Lim (ktl@slac.stanford.edu)
                 *
                 * \ingroup daf_persistence
                 */
                
                #ifndef __GNUC__
                #  define __attribute__(x) /*NOTHING*/
                #endif
                static char const* SVNid __attribute__((unused)) = "$Id$";
                
                #include "lsst/daf/persistence/LogicalLocation.h"
                
                #include "boost/regex.hpp"
                #include "lsst/pex/exceptions.h"
                #include "lsst/pex/logging/Trace.h"
                
                namespace dafBase = lsst::daf::base;
                namespace dafPersist = lsst::daf::persistence;
                namespace pexExcept = lsst::pex::exceptions;
                namespace pexLog = lsst::pex::logging;
                
                dafBase::PropertySet::Ptr dafPersist::LogicalLocation::_map;
                
                /** Constructor from string and additional data.
                 */
                dafPersist::LogicalLocation::LogicalLocation(
                    std::string const& locString, CONST_PTR(dafBase::PropertySet) additionalData) :
                    lsst::daf::base::Citizen(typeid(*this)), _locString() {
                    boost::regex expr("(%.*?)\\((\\w+?)\\)");
                    boost::sregex_iterator i = make_regex_iterator(locString, expr);
                    boost::sregex_iterator last;
                    pexLog::TTrace<5>("daf.persistence.LogicalLocation",
                                      "Input string: " + locString);
                    while (i != boost::sregex_iterator()) {
                        last = i;
                        if ((*i).prefix().matched) {
                            _locString += (*i).prefix().str();
                        }
                        std::string fmt = (*i).str(1);
                        std::string key = (*i).str(2);
                        pexLog::TTrace<5>("daf.persistence.LogicalLocation", "Key: " + key);
                        if (_map && _map->exists(key)) {
                            if (_map->typeOf(key) == typeid(int)) {
                                int value = _map->getAsInt(key);
                                pexLog::TTrace<5>("daf.persistence.LogicalLocation",
                                                  "Map Val: %d", value);
                                if (fmt == "%") {
                                    _locString += (boost::format("%1%") % value).str();
                                }
                                else {
                                    _locString += (boost::format(fmt) % value).str();
                                }
                            }
                            else {
                                std::string value = _map->getAsString(key);
                                pexLog::TTrace<5>("daf.persistence.LogicalLocation",
                                                  "Map Val: " + value);
                                _locString += value;
                            }
                        }
                        else if (additionalData && additionalData->exists(key)) {
                            if (additionalData->typeOf(key) == typeid(int)) {
                                int value = additionalData->getAsInt(key);
                                pexLog::TTrace<5>("daf.persistence.LogicalLocation",
                                                  "Map Val: %d", value);
                                if (fmt == "%") {
                                    _locString += (boost::format("%1%") % value).str();
                                }
                                else {
                                    _locString += (boost::format(fmt) % value).str();
                                }
                            }
                            else {
                                std::string value = additionalData->getAsString(key);
                                pexLog::TTrace<5>("daf.persistence.LogicalLocation",
                                                  "Map Val: " + value);
                                _locString += value;
                            }
                        }
                        else {
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
113  <a href="#0d56eb6c">0d56eb6c</a> -             throw LSST_EXCEPT(pexExcept::RuntimeErrorException,</div>
              ?                                                      ---------
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
113  <a href="#0c1dd2d0">0c1dd2d0</a> +             throw LSST_EXCEPT(pexExcept::RuntimeError,</div>
                                              "Unknown substitution: " + key);
                        }
                        ++i;
                    }
                    if (last == boost::sregex_iterator()) {
                        _locString = locString;
                        pexLog::TTrace<5>("daf.persistence.LogicalLocation",
                                          "Copy to: " + _locString);
                    }
                    else {
                        _locString += (*last).suffix().str();
                        pexLog::TTrace<5>("daf.persistence.LogicalLocation",
                                          "Result: " + _locString);
                    }
                }
                
                /** Accessor.
                 */
                std::string const& dafPersist::LogicalLocation::locString(void) const {
                    return _locString;
                }
                
                /** Set the logical-to-less-logical map.
                  */
                void dafPersist::LogicalLocation::setLocationMap(PTR(dafBase::PropertySet) map) {
                    dafBase::PersistentCitizenScope scope;
                    if (map) {
                        _map = map->deepCopy();
                    } else {
                        _map.reset();
                    }
                }
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="0d56eb6c"/></a>0d56eb6c</h3>

<pre>
commit 0d56eb6c5d259cf185b4e5bf9c5cf53b956864b4
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Wed Mar 11 06:14:32 2009 +0000

    Add mappings (static and per-locator) to LogicalLocation (#691), with test.  Add debug output to DbStorageImpl (#696).  Clean up tests/SConscript a little.
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="0c1dd2d0"/></a>0c1dd2d0</h3>

<pre>
commit 0c1dd2d0b1f7616ea7ab50992470f2aedbfd4e55
Author: Russell Owen <rowen@uw.edu>
Date:   Tue Jun 17 16:09:51 2014 -0700

    Rename exceptions.
</pre>
</div>


[Return to list](#homelist)
# <a name="tests/Persistence_2.py"/></a>tests/Persistence_2.py
### Diff:

<pre>
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
23   <a href="#615041f9">615041f9</a> + import sys</div>
                import lsst.daf.base as dafBase
                import lsst.daf.persistence as dafPersist
                import lsst.pex.policy as pexPolicy
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
27   <a href="#f69b65eb">f69b65eb</a> + </div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
28   <a href="#615041f9">615041f9</a> + if not dafPersist.DbAuth.available("lsst10.ncsa.uiuc.edu", "3306"):</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
29   <a href="#615041f9">615041f9</a> +     print "*** WARNING*** Database authenticator unavailable.  Skipping test."</div>
<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
30   <a href="#615041f9">615041f9</a> +     sys.exit()</div>
                
                def test1():
                    """
                    Test PropertySet persistence to database without policy.
                    """
                
                    dp = dafBase.PropertySet()
                    dp.addInt("intField", 1)
                    dp.addDouble("doubleField", 1.2)
                    dp.addString("varcharField", "Testing")
                    dp.addBool("boolField", True)
                    dp.addLongLong("int64Field", 9876543210L)
                    dp.addFloat("floatField", 3.14)
                
                    pol = pexPolicy.Policy()
                
                    additionalData = dafBase.PropertySet()
                    additionalData.add("itemName", "Persistence_Test_2")
                
                    loc = dafPersist.LogicalLocation("mysql://lsst10.ncsa.uiuc.edu:3306/test")
                
                    persistence = dafPersist.Persistence.getPersistence(pol)
                
                    storageList = dafPersist.StorageList()
                    storage = persistence.getPersistStorage("DbStorage", loc)
                    storageList.append(storage)
                    persistence.persist(dp, storageList, additionalData)
                
                def test2():
                    """
                    Test PropertySet persistence to database with policy mapping itemName to
                    database table name.
                    """
                
                    dp = dafBase.PropertySet()
                    dp.addInt("intField", 2)
                    dp.addDouble("doubleField", 2.3)
                    dp.addString("varcharField", "gnitseT")
                    dp.addBool("boolField", False)
                    dp.addLongLong("int64Field", 9988776655L)
                    dp.addFloat("floatField", 2.718)
                
                    pol = pexPolicy.Policy()
                    itemPol = pexPolicy.Policy()
                    itemPol.set("TableName", "Persistence_Test_2")
                    pol.set("Formatter.PropertySet.testItem", itemPol)
                
                    additionalData = dafBase.PropertySet()
                    additionalData.add("itemName", "testItem")
                
                    loc = dafPersist.LogicalLocation("mysql://lsst10.ncsa.uiuc.edu:3306/test")
                
                    persistence = dafPersist.Persistence.getPersistence(pol)
                
                    storageList = dafPersist.StorageList()
                    storage = persistence.getPersistStorage("DbStorage", loc)
                    storageList.append(storage)
                    persistence.persist(dp, storageList, additionalData)
                
                def test3():
                    """
                    Test PropertySet persistence to database with policy mapping itemName to
                    database table name and mapping property keys to table columns.
                    """
                
                    dp = dafBase.PropertySet()
                    dp.addInt("i", 3)
                    dp.addDouble("d", 3.4)
                    dp.addString("v", "LastOne")
                    dp.addBool("b", True)
                    dp.addLongLong("I", 9998887776L)
                    dp.addFloat("f", 1.414)
                
                    pol = pexPolicy.Policy()
                    itemPol = pexPolicy.Policy()
                    itemPol.set("TableName", "Persistence_Test_2")
                    itemPol.add("KeyList", "floatField=f")
                    itemPol.add("KeyList", "int64Field=I")
                    itemPol.add("KeyList", "boolField=b")
                    itemPol.add("KeyList", "varcharField=v")
                    itemPol.add("KeyList", "doubleField=d")
                    itemPol.add("KeyList", "intField=i")
                    pol.set("Formatter.PropertySet.testItem", itemPol)
                
                    additionalData = dafBase.PropertySet()
                    additionalData.add("itemName", "testItem")
                
                    loc = dafPersist.LogicalLocation("mysql://lsst10.ncsa.uiuc.edu:3306/test")
                
                    persistence = dafPersist.Persistence.getPersistence(pol)
                
                    storageList = dafPersist.StorageList()
                    storage = persistence.getPersistStorage("DbStorage", loc)
                    storageList.append(storage)
                    persistence.persist(dp, storageList, additionalData)
                
                test1()
                test2()
                test3()
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
<h3><a name="615041f9"/></a>615041f9</h3>

<pre>
commit 615041f9996a0243e2ea3dec88dc42f64d9545d2
Author: danielsf <scott.f.daniel@gmail.com>
Date:   Fri May 8 10:17:06 2015 -0700

    removed the code that skips unit tests from the tests/SConscript
    
    added code to Persistence_2.py in tests/ that will simply exit
    without running any tests if the user does not have credentials
    for the necessary database
    
    added code to the C++ unit tests to exit without failing
    if the user does not have credentials to access the
    test database
    
    added comments explaining changes to unit test
</pre>
<h3><a name="f69b65eb"/></a>f69b65eb</h3>

<pre>
commit f69b65ebab9e2c985d935e21ee205bcf0b953a00
Author: ktlim <ktlim@git.lsstcorp.org>
Date:   Fri Mar 28 01:07:49 2008 +0000

    Initial move of mwi/persistence to daf/persistence.
</pre>
</div>


[Return to list](#homelist)
# <a name="python/lsst/daf/persistence/mapper.py"/></a>python/lsst/daf/persistence/mapper.py
### Diff:

<pre>
                #!/usr/bin/env python
                
                # 
                # LSST Data Management System
                # Copyright 2008, 2009, 2010 LSST Corporation.
                # 
                # This product includes software developed by the
                # LSST Project (http://www.lsst.org/).
                #
                # This program is free software: you can redistribute it and/or modify
                # it under the terms of the GNU General Public License as published by
                # the Free Software Foundation, either version 3 of the License, or
                # (at your option) any later version.
                # 
                # This program is distributed in the hope that it will be useful,
                # but WITHOUT ANY WARRANTY; without even the implied warranty of
                # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                # GNU General Public License for more details.
                # 
                # You should have received a copy of the LSST License Statement and 
                # the GNU General Public License along with this program.  If not, 
                # see <http://www.lsstcorp.org/LegalNotices/>.
                #
                
                
                """This module defines the Mapper base class."""
                
                class Mapper(object):
                    """Mapper is a base class for all mappers.
                
                    Subclasses may define the following methods:
                    
                    map_{datasetType}(self, dataId, write)
                        Map a dataset id for the given dataset type into a ButlerLocation.
                        If write=True, this mapping is for an output dataset.
                
                    query_{datasetType}(self, key, format, dataId)
                        Return the possible values for the format fields that would produce
                        datasets at the granularity of key in combination with the provided
                        partial dataId.
                
                    std_{datasetType}(self, item)
                        Standardize an object of the given data set type.
                
                    Methods that must be overridden:
                
                    keys(self)
                        Return a list of the keys that can be used in data ids.
                
                    Other public methods:
                
                    __init__(self)
                
                    getDatasetTypes(self)
                
                    map(self, datasetType, dataId, write=False)
                
                    queryMetadata(self, datasetType, key, format, dataId)
                
                    canStandardize(self, datasetType)
                
                    standardize(self, datasetType, item, dataId)
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
63   <a href="#605333fd">605333fd</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
64   <a href="#b8a8f17e">b8a8f17e</a> -     isAggregate(self, datasetType)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
65   <a href="#b8a8f17e">b8a8f17e</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
66   <a href="#b8a8f17e">b8a8f17e</a> -     buildAggregate(self, datasetType, dataId, butler)</div>
                
                    validate(self, dataId)
                    """
                
                    def __new__(cls, *args, **kwargs):
                        """Create a new Mapper, saving arguments for pickling.
                
                        This is in __new__ instead of __init__ to save the user
                        from having to save the arguments themselves (either explicitly,
                        or by calling the super's __init__ with all their
                        *args,**kwargs.  The resulting pickling system (of __new__,
                        __getstate__ and __setstate__ is similar to how __reduce__
                        is usually used, except that we save the user from any
                        responsibility (except when overriding __new__, but that
                        is not common).
                        """
                        self = super(Mapper, cls).__new__(cls)
                        self._arguments = (args, kwargs)
                        return self
                
                    def __init__(self):
                        pass
                
                    def __getstate__(self):
                        return self._arguments
                
                    def __setstate__(self, state):
                        self._arguments = state
                        args, kwargs = state
                        self.__init__(*args, **kwargs)
                
                    def keys(self):
                        raise NotImplementedError("keys() unimplemented")
                
                    def queryMetadata(self, datasetType, key, format, dataId):
                        """Return possible values for keys given a partial data id."""
                
                        func = getattr(self, 'query_' + datasetType)
                        return func(key, format, self.validate(dataId))
                
                    def getDatasetTypes(self):
                        """Return a list of the mappable dataset types."""
                
                        list = []
                        for attr in dir(self):
                            if attr.startswith("map_"):
                                list.append(attr[4:])
                        return list
                
                    def map(self, datasetType, dataId, write=False):
                        """Map a data id using the mapping method for its dataset type."""
                
                        func = getattr(self, 'map_' + datasetType)
                        return func(self.validate(dataId), write)
                
                    def canStandardize(self, datasetType):
                        """Return true if this mapper can standardize an object of the given
                        dataset type."""
                
                        return hasattr(self, 'std_' + datasetType)
                
                    def standardize(self, datasetType, item, dataId):
                        """Standardize an object using the standardization method for its data
                        set type, if it exists."""
                
                        if hasattr(self, 'std_' + datasetType):
                            func = getattr(self, 'std_' + datasetType)
                            return func(item, self.validate(dataId))
                        return item
                
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
137  <a href="#b8a8f17e">b8a8f17e</a> -     def isAggregate(self, datasetType):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
138  <a href="#b8a8f17e">b8a8f17e</a> -         """Return True if the mapper defines the given object as an aggregate</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
139  <a href="#b8a8f17e">b8a8f17e</a> -         of other objects to be loaded from the butler.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
140  <a href="#b8a8f17e">b8a8f17e</a> -         """</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
141  <a href="#b8a8f17e">b8a8f17e</a> -         return hasattr(self, 'build_' + datasetType)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
142  <a href="#b8a8f17e">b8a8f17e</a> - </div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
143  <a href="#b8a8f17e">b8a8f17e</a> -     def buildAggregate(self, datasetType, dataId, butler):</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
144  <a href="#b8a8f17e">b8a8f17e</a> -         """Load an aggegrate object's components from the butler and build it.</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
145  <a href="#b8a8f17e">b8a8f17e</a> -         """</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
146  <a href="#b8a8f17e">b8a8f17e</a> -         func = getattr(self, 'build_' + datasetType)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
147  <a href="#b8a8f17e">b8a8f17e</a> -         return func(dataId, butler)</div>
<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">
148  <a href="#b8a8f17e">b8a8f17e</a> - </div>
                    def validate(self, dataId):
                        """Validate a dataId's contents.
                        
                        If the dataId is valid, return it.  If an invalid component can be
                        transformed into a valid one, copy the dataId, fix the component, and
                        return the copy.  Otherwise, raise an exception."""
                
                        return dataId
                
                    def backup(self, datasetType, dataId):
                        """Rename any existing object with the given type and dataId.
                
                        Not implemented in the base mapper.
                        """
                        raise NotImplementedError("Base-class Mapper does not implement backups")
</pre>
[Return to list](#homelist)


<div style="background-color:Khaki; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_hsc/daf_persistence/</h2>
<h3><a name="605333fd"/></a>605333fd</h3>

<pre>
commit 605333fd1387e13da268c8f1c39a15eb630290c5
Author: Kian-Tat Lim <ktl@slac.stanford.edu>
Date:   Fri Feb 24 14:24:14 2012 -0800

    Add validation function for dataIds to mapper.
</pre>
<h3><a name="b8a8f17e"/></a>b8a8f17e</h3>

<pre>
commit b8a8f17eb4b4e066d89dc43f28688a92b75fca70
Author: Jim Bosch <jbosch@astro.princeton.edu>
Date:   Tue Feb 26 21:54:54 2013 +0900

    Add new Mapper API for datasets that are built (by a mapper subclass) from other datasets (one possible solution for #2695).
</pre>
</div>


<div style="background-color:LightBlue; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left: 8px; padding-right: 8px; padding-top: 8px;">

<h2>Commits in /Users/nate/repos_lsst/daf_persistence/</h2>
</div>


[Return to list](#homelist)
